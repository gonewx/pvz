package systems

import (
	"testing"

	"github.com/decker502/pvz/internal/reanim"
	"github.com/decker502/pvz/pkg/components"
	"github.com/decker502/pvz/pkg/ecs"
	"github.com/hajimehoshi/ebiten/v2"
)

// TestPrepareStaticPreview_NormalPath tests PrepareStaticPreview when a complete visible frame exists
func TestPrepareStaticPreview_NormalPath(t *testing.T) {
	// Given: 一个有完整可见帧的 Reanim 组件
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entity := em.CreateEntity()

	reanimComp := createTestReanimWithCompleteFrames()
	ecs.AddComponent(em, entity, reanimComp)

	// When: 调用 PrepareStaticPreview
	err := rs.PrepareStaticPreview(entity, "TestPlant")

	// Then: 应该成功选择第一个完整帧
	if err != nil {
		t.Fatalf("PrepareStaticPreview failed: %v", err)
	}

	comp, exists := ecs.GetComponent[*components.ReanimComponent](em, entity)
	if !exists {
		t.Fatal("ReanimComponent not found")
	}

	if comp.BestPreviewFrame != 0 {
		t.Errorf("Expected BestPreviewFrame to be 0, got %d", comp.BestPreviewFrame)
	}

	if comp.CurrentAnim != "static_preview" {
		t.Errorf("Expected CurrentAnim to be 'static_preview', got '%s'", comp.CurrentAnim)
	}

	if comp.IsLooping {
		t.Error("Expected IsLooping to be false for static preview")
	}

	if !comp.IsFinished {
		t.Error("Expected IsFinished to be true for static preview")
	}
}

// TestPrepareStaticPreview_HeuristicFallback tests PrepareStaticPreview when no complete frame exists
func TestPrepareStaticPreview_HeuristicFallback(t *testing.T) {
	// Given: 一个没有完整可见帧的 Reanim 组件（所有帧都缺少部分部件）
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entity := em.CreateEntity()

	totalFrames := 100
	reanimComp := createTestReanimWithIncompleteFrames(totalFrames)
	ecs.AddComponent(em, entity, reanimComp)

	// When: 调用 PrepareStaticPreview
	err := rs.PrepareStaticPreview(entity, "TestPlant")

	// Then: 应该使用启发式策略（40% 位置）
	if err != nil {
		t.Fatalf("PrepareStaticPreview failed: %v", err)
	}

	comp, _ := ecs.GetComponent[*components.ReanimComponent](em, entity)
	expectedFrame := int(float64(totalFrames) * 0.4) // 40

	if comp.BestPreviewFrame != expectedFrame {
		t.Errorf("Expected BestPreviewFrame to be %d (40%% of %d), got %d",
			expectedFrame, totalFrames, comp.BestPreviewFrame)
	}

	if comp.CurrentAnim != "static_preview" {
		t.Errorf("Expected CurrentAnim to be 'static_preview', got '%s'", comp.CurrentAnim)
	}
}

// TestPrepareStaticPreview_EmptyReanim tests PrepareStaticPreview with no tracks
func TestPrepareStaticPreview_EmptyReanim(t *testing.T) {
	// Given: 一个空的 Reanim 组件
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entity := em.CreateEntity()

	reanimComp := &components.ReanimComponent{
		ReanimXML: &reanim.ReanimXML{
			FPS:    12,
			Tracks: []reanim.Track{}, // 空轨道
		},
		PartImages: make(map[string]*ebiten.Image),
	}
	ecs.AddComponent(em, entity, reanimComp)

	// When: 调用 PrepareStaticPreview
	err := rs.PrepareStaticPreview(entity, "EmptyPlant")

	// Then: 应该成功处理（使用默认值）
	if err != nil {
		t.Fatalf("PrepareStaticPreview should handle empty Reanim, got error: %v", err)
	}

	comp, _ := ecs.GetComponent[*components.ReanimComponent](em, entity)

	// 空 Reanim 应该使用帧 0
	if comp.BestPreviewFrame != 0 {
		t.Errorf("Expected BestPreviewFrame to be 0 for empty Reanim, got %d", comp.BestPreviewFrame)
	}
}

// TestFindFirstCompleteVisibleFrame tests the findFirstCompleteVisibleFrame method
func TestFindFirstCompleteVisibleFrame(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	testCases := []struct {
		name          string
		reanimComp    *components.ReanimComponent
		expectedFrame int
	}{
		{
			name:          "All frames complete",
			reanimComp:    createTestReanimWithCompleteFrames(),
			expectedFrame: 0, // 第一个完整帧
		},
		{
			name:          "No complete frames",
			reanimComp:    createTestReanimWithIncompleteFrames(50),
			expectedFrame: -1, // 没有完整帧
		},
		{
			name:          "First frame incomplete, second complete",
			reanimComp:    createTestReanimWithFirstFrameIncomplete(),
			expectedFrame: 1, // 第二个帧是第一个完整帧
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Build merged tracks
			tc.reanimComp.MergedTracks = reanim.BuildMergedTracks(tc.reanimComp.Reanim)

			// Call findFirstCompleteVisibleFrame
			result := rs.findFirstCompleteVisibleFrame(tc.reanimComp)

			if result != tc.expectedFrame {
				t.Errorf("Expected frame %d, got %d", tc.expectedFrame, result)
			}
		})
	}
}

// TestFindPreviewFrameHeuristic tests the findPreviewFrameHeuristic method
func TestFindPreviewFrameHeuristic(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	testCases := []struct {
		name          string
		totalFrames   int
		expectedFrame int
	}{
		{
			name:          "100 frames",
			totalFrames:   100,
			expectedFrame: 40, // 40% of 100
		},
		{
			name:          "50 frames",
			totalFrames:   50,
			expectedFrame: 20, // 40% of 50
		},
		{
			name:          "1 frame",
			totalFrames:   1,
			expectedFrame: 0, // 40% of 1 = 0
		},
		{
			name:          "0 frames",
			totalFrames:   0,
			expectedFrame: 0, // Edge case: 0 frames
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			reanimComp := createTestReanimWithIncompleteFrames(tc.totalFrames)
			reanimComp.MergedTracks = reanim.BuildMergedTracks(reanimComp.Reanim)

			result := rs.findPreviewFrameHeuristic(reanimComp)

			if result != tc.expectedFrame {
				t.Errorf("Expected frame %d for %d total frames, got %d",
					tc.expectedFrame, tc.totalFrames, result)
			}
		})
	}
}

// createTestReanimWithCompleteFrames creates a ReanimComponent with complete visible frames
func createTestReanimWithCompleteFrames() *components.ReanimComponent {
	// Create a Reanim with 3 part tracks, all frames have images and are visible
	return &components.ReanimComponent{
		ReanimXML: &reanim.ReanimXML{
			FPS: 12,
			Tracks: []reanim.Track{
				{
					Name: "part1",
					Frames: []reanim.Frame{
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART1"},
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART1"},
					},
				},
				{
					Name: "part2",
					Frames: []reanim.Frame{
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART2"},
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART2"},
					},
				},
				{
					Name: "part3",
					Frames: []reanim.Frame{
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART3"},
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART3"},
					},
				},
			},
		},
		PartImages: make(map[string]*ebiten.Image),
	}
}

// createTestReanimWithIncompleteFrames creates a ReanimComponent where no frame has all parts visible
func createTestReanimWithIncompleteFrames(totalFrames int) *components.ReanimComponent {
	// Create frames for part1 and part2, but they never align on the same frame
	frames1 := make([]reanim.Frame, totalFrames)
	frames2 := make([]reanim.Frame, totalFrames)

	for i := 0; i < totalFrames; i++ {
		// part1 visible on even frames, hidden on odd frames
		if i%2 == 0 {
			frames1[i] = reanim.Frame{
				X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
				FrameNum: intPtr(0), ImagePath: "IMAGE_PART1",
			}
		} else {
			frames1[i] = reanim.Frame{
				X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
				FrameNum: intPtr(-1), ImagePath: "IMAGE_PART1", // Hidden
			}
		}

		// part2 visible on odd frames, hidden on even frames
		if i%2 == 1 {
			frames2[i] = reanim.Frame{
				X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
				FrameNum: intPtr(0), ImagePath: "IMAGE_PART2",
			}
		} else {
			frames2[i] = reanim.Frame{
				X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
				FrameNum: intPtr(-1), ImagePath: "IMAGE_PART2", // Hidden
			}
		}
	}

	return &components.ReanimComponent{
		ReanimXML: &reanim.ReanimXML{
			FPS: 12,
			Tracks: []reanim.Track{
				{Name: "part1", Frames: frames1},
				{Name: "part2", Frames: frames2},
			},
		},
		PartImages: make(map[string]*ebiten.Image),
	}
}

// createTestReanimWithFirstFrameIncomplete creates a ReanimComponent where first frame is incomplete
func createTestReanimWithFirstFrameIncomplete() *components.ReanimComponent {
	return &components.ReanimComponent{
		ReanimXML: &reanim.ReanimXML{
			FPS: 12,
			Tracks: []reanim.Track{
				{
					Name: "part1",
					Frames: []reanim.Frame{
						// Frame 0: hidden (f=-1)
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(-1), ImagePath: "IMAGE_PART1"},
						// Frame 1: visible
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART1"},
					},
				},
				{
					Name: "part2",
					Frames: []reanim.Frame{
						// Frame 0: no image
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: ""},
						// Frame 1: visible
						{X: floatPtr(0), Y: floatPtr(0), ScaleX: floatPtr(1), ScaleY: floatPtr(1),
							FrameNum: intPtr(0), ImagePath: "IMAGE_PART2"},
					},
				},
			},
		},
		PartImages: make(map[string]*ebiten.Image),
	}
}

// Helper functions to create pointers
func intPtr(i int) *int {
	return &i
}

func floatPtr(f float64) *float64 {
	return &f
}

// TestGetTrackTransform tests the GetTrackTransform method
// Story 10.5: 测试获取轨道实时坐标的API
func TestGetTrackTransform(t *testing.T) {
	// 创建 EntityManager
	em := ecs.NewEntityManager()

	// 创建 ReanimSystem
	rs := NewReanimSystem(em)

	// 测试用例 1: 正常获取轨道坐标
	t.Run("Normal track transform", func(t *testing.T) {
		// 创建测试实体
		entityID := em.CreateEntity()

		// Story 13.2: 创建测试用的 Reanim 组件，使用 AnimStates 而非 CurrentFrame
		reanimComp := &components.ReanimComponent{
			CurrentAnim: "test_anim",
			MergedTracks: map[string][]reanim.Frame{
				"idle_mouth": {
					// Frame 0
					{X: floatPtr(10.0), Y: floatPtr(20.0)},
					// Frame 1
					{X: floatPtr(15.0), Y: floatPtr(25.0)},
					// Frame 2 (当前帧)
					{X: floatPtr(20.0), Y: floatPtr(30.0)},
					// Frame 3
					{X: floatPtr(25.0), Y: floatPtr(35.0)},
				},
			},
			AnimStates: map[string]*components.AnimState{
				"test_anim": {
					Name:         "test_anim",
					LogicalFrame: 2, // 使用第3帧（0-based）
					IsActive:     true,
				},
			},
		}
		ecs.AddComponent(em, entityID, reanimComp)

		// 调用 GetTrackTransform
		x, y, err := rs.GetTrackTransform(entityID, "idle_mouth")

		// 验证结果
		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
		if x != 20.0 {
			t.Errorf("Expected x=20.0, got %f", x)
		}
		if y != 30.0 {
			t.Errorf("Expected y=30.0, got %f", y)
		}
	})

	// 测试用例 2: 轨道不存在
	t.Run("Track not found", func(t *testing.T) {
		entityID := em.CreateEntity()
		// Story 13.2: 使用 AnimStates
		reanimComp := &components.ReanimComponent{
			CurrentAnim: "test_anim",
			MergedTracks: map[string][]reanim.Frame{
				"other_track": {
					{X: floatPtr(10.0), Y: floatPtr(20.0)},
				},
			},
			AnimStates: map[string]*components.AnimState{
				"test_anim": {
					Name:         "test_anim",
					LogicalFrame: 0,
					IsActive:     true,
				},
			},
		}
		ecs.AddComponent(em, entityID, reanimComp)

		_, _, err := rs.GetTrackTransform(entityID, "nonexistent_track")

		if err == nil {
			t.Fatal("Expected error for nonexistent track, got nil")
		}
		expectedErrMsg := "track 'nonexistent_track' not found"
		if !containsString(err.Error(), expectedErrMsg) {
			t.Errorf("Expected error message to contain '%s', got '%s'", expectedErrMsg, err.Error())
		}
	})

	// 测试用例 3: 实体无 ReanimComponent
	t.Run("Entity without ReanimComponent", func(t *testing.T) {
		entityID := em.CreateEntity()

		_, _, err := rs.GetTrackTransform(entityID, "idle_mouth")

		if err == nil {
			t.Fatal("Expected error for entity without ReanimComponent, got nil")
		}
		expectedErrMsg := "does not have ReanimComponent"
		if !containsString(err.Error(), expectedErrMsg) {
			t.Errorf("Expected error message to contain '%s', got '%s'", expectedErrMsg, err.Error())
		}
	})

	// 测试用例 4: 帧号越界（使用最后一帧）
	t.Run("Frame index out of bounds", func(t *testing.T) {
		entityID := em.CreateEntity()
		// Story 13.2: 使用 AnimStates
		reanimComp := &components.ReanimComponent{
			CurrentAnim: "test_anim",
			MergedTracks: map[string][]reanim.Frame{
				"idle_mouth": {
					{X: floatPtr(10.0), Y: floatPtr(20.0)},
					{X: floatPtr(15.0), Y: floatPtr(25.0)},
				},
			},
			AnimStates: map[string]*components.AnimState{
				"test_anim": {
					Name:         "test_anim",
					LogicalFrame: 100, // 超出范围
					IsActive:     true,
				},
			},
		}
		ecs.AddComponent(em, entityID, reanimComp)

		x, y, err := rs.GetTrackTransform(entityID, "idle_mouth")

		// 应该使用最后一帧（Frame 1）
		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
		if x != 15.0 {
			t.Errorf("Expected x=15.0 (last frame), got %f", x)
		}
		if y != 25.0 {
			t.Errorf("Expected y=25.0 (last frame), got %f", y)
		}
	})

	// 测试用例 5: 坐标为 nil（默认 0, 0）
	t.Run("Nil coordinates", func(t *testing.T) {
		entityID := em.CreateEntity()
		// Story 13.2: 使用 AnimStates
		reanimComp := &components.ReanimComponent{
			CurrentAnim: "test_anim",
			MergedTracks: map[string][]reanim.Frame{
				"idle_mouth": {
					{X: nil, Y: nil}, // 坐标为 nil
				},
			},
			AnimStates: map[string]*components.AnimState{
				"test_anim": {
					Name:         "test_anim",
					LogicalFrame: 0,
					IsActive:     true,
				},
			},
		}
		ecs.AddComponent(em, entityID, reanimComp)

		x, y, err := rs.GetTrackTransform(entityID, "idle_mouth")

		if err != nil {
			t.Fatalf("Expected no error, got %v", err)
		}
		if x != 0.0 {
			t.Errorf("Expected x=0.0 (default), got %f", x)
		}
		if y != 0.0 {
			t.Errorf("Expected y=0.0 (default), got %f", y)
		}
	})

	// 测试用例 6: 轨道无帧数据
	t.Run("Track with no frames", func(t *testing.T) {
		entityID := em.CreateEntity()
		// Story 13.2: 使用 AnimStates
		reanimComp := &components.ReanimComponent{
			CurrentAnim: "test_anim",
			MergedTracks: map[string][]reanim.Frame{
				"idle_mouth": {}, // 空轨道
			},
			AnimStates: map[string]*components.AnimState{
				"test_anim": {
					Name:         "test_anim",
					LogicalFrame: 0,
					IsActive:     true,
				},
			},
		}
		ecs.AddComponent(em, entityID, reanimComp)

		_, _, err := rs.GetTrackTransform(entityID, "idle_mouth")

		if err == nil {
			t.Fatal("Expected error for track with no frames, got nil")
		}
		expectedErrMsg := "has no frames"
		if !containsString(err.Error(), expectedErrMsg) {
			t.Errorf("Expected error message to contain '%s', got '%s'", expectedErrMsg, err.Error())
		}
	})
}

// containsString checks if a string contains a substring
func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > len(substr) &&
		(s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
			func() bool {
				for i := 0; i <= len(s)-len(substr); i++ {
					if s[i:i+len(substr)] == substr {
						return true
					}
				}
				return false
			}()))
}

// ==================================================================
// Story 6.9: Multi-Animation Overlay API Tests
// ==================================================================

// TestPlayAnimations_MultipleAnimations tests playing multiple animations simultaneously
func TestPlayAnimations_MultipleAnimations(t *testing.T) {
	// Setup
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	// Create a minimal Reanim with two animation definition tracks
	reanimData := &reanim.ReanimXML{
		FPS: 12,
		Tracks: []reanim.Track{
			{
				Name: "anim_idle",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0)}, // Frame 0: visible
					{FrameNum: intPtr(0)}, // Frame 1: visible
				},
			},
			{
				Name: "anim_shooting",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0)}, // Frame 0: visible
					{FrameNum: intPtr(0)}, // Frame 1: visible
				},
			},
			{
				Name: "part_body",
				Frames: []reanim.Frame{
					{ImagePath: "body_img", X: floatPtr(0), Y: floatPtr(0)},
					{ImagePath: "body_img", X: floatPtr(0), Y: floatPtr(0)},
				},
			},
		},
	}

	reanimComp := &components.ReanimComponent{
		ReanimXML:  reanimData,
		PartImages: make(map[string]*ebiten.Image),
	}
	ecs.AddComponent(em, entityID, reanimComp)
	ecs.AddComponent(em, entityID, &components.PositionComponent{X: 100, Y: 100})

	// Test: PlayAnimations with multiple animations
	err := rs.PlayAnimations(entityID, []string{"anim_idle", "anim_shooting"})
	if err != nil {
		t.Fatalf("PlayAnimations failed: %v", err)
	}

	// Verify: Both animations are in Anims map and active
	if len(reanimComp.AnimStates) != 2 {
		t.Errorf("Expected 2 animations in Anims, got %d", len(reanimComp.AnimStates))
	}

	idleAnim, hasIdle := reanimComp.AnimStates["anim_idle"]
	if !hasIdle {
		t.Error("Expected anim_idle in Anims map")
	} else if !idleAnim.IsActive {
		t.Error("Expected anim_idle to be active")
	}

	shootingAnim, hasShooting := reanimComp.AnimStates["anim_shooting"]
	if !hasShooting {
		t.Error("Expected anim_shooting in Anims map")
	} else if !shootingAnim.IsActive {
		t.Error("Expected anim_shooting to be active")
	}

	// Verify: AnimVisiblesMap contains both animations
	if _, hasIdleVisibles := reanimComp.AnimVisiblesMap["anim_idle"]; !hasIdleVisibles {
		t.Error("Expected anim_idle in AnimVisiblesMap")
	}
	if _, hasShootingVisibles := reanimComp.AnimVisiblesMap["anim_shooting"]; !hasShootingVisibles {
		t.Error("Expected anim_shooting in AnimVisiblesMap")
	}
}

// TestAddAnimation_PreservesExisting tests that AddAnimation preserves existing animations
func TestAddAnimation_PreservesExisting(t *testing.T) {
	// Setup
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	// Create a minimal Reanim with three animation definition tracks
	reanimData := &reanim.ReanimXML{
		FPS: 12,
		Tracks: []reanim.Track{
			{
				Name: "anim_walk",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0)},
				},
			},
			{
				Name: "anim_burning",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0)},
				},
			},
			{
				Name: "anim_frozen",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0)},
				},
			},
		},
	}

	reanimComp := &components.ReanimComponent{
		ReanimXML:  reanimData,
		PartImages: make(map[string]*ebiten.Image),
	}
	ecs.AddComponent(em, entityID, reanimComp)
	ecs.AddComponent(em, entityID, &components.PositionComponent{X: 100, Y: 100})

	// Step 1: Play walk animation
	err := rs.PlayAnimation(entityID, "anim_walk")
	if err != nil {
		t.Fatalf("PlayAnimation failed: %v", err)
	}

	// Verify: Only walk animation is active
	if len(reanimComp.AnimStates) != 1 {
		t.Errorf("Expected 1 animation after PlayAnimation, got %d", len(reanimComp.AnimStates))
	}

	// Step 2: Add burning effect
	err = rs.AddAnimation(entityID, "anim_burning")
	if err != nil {
		t.Fatalf("AddAnimation failed: %v", err)
	}

	// Verify: Both walk and burning animations are active
	if len(reanimComp.AnimStates) != 2 {
		t.Errorf("Expected 2 animations after AddAnimation, got %d", len(reanimComp.AnimStates))
	}

	if _, hasWalk := reanimComp.AnimStates["anim_walk"]; !hasWalk {
		t.Error("Expected anim_walk to still be present after AddAnimation")
	}
	if _, hasBurning := reanimComp.AnimStates["anim_burning"]; !hasBurning {
		t.Error("Expected anim_burning to be added")
	}

	// Step 3: Add frozen effect
	err = rs.AddAnimation(entityID, "anim_frozen")
	if err != nil {
		t.Fatalf("AddAnimation failed: %v", err)
	}

	// Verify: All three animations are active
	if len(reanimComp.AnimStates) != 3 {
		t.Errorf("Expected 3 animations after second AddAnimation, got %d", len(reanimComp.AnimStates))
	}

	if _, hasWalk := reanimComp.AnimStates["anim_walk"]; !hasWalk {
		t.Error("Expected anim_walk to still be present")
	}
	if _, hasBurning := reanimComp.AnimStates["anim_burning"]; !hasBurning {
		t.Error("Expected anim_burning to still be present")
	}
	if _, hasFrozen := reanimComp.AnimStates["anim_frozen"]; !hasFrozen {
		t.Error("Expected anim_frozen to be added")
	}
}

// TestRemoveAnimation tests removing a specific animation
func TestRemoveAnimation(t *testing.T) {
	// Setup
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	// Create a minimal Reanim with two animation definition tracks
	reanimData := &reanim.ReanimXML{
		FPS: 12,
		Tracks: []reanim.Track{
			{
				Name: "anim_walk",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0)},
				},
			},
			{
				Name: "anim_burning",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0)},
				},
			},
		},
	}

	reanimComp := &components.ReanimComponent{
		ReanimXML:  reanimData,
		PartImages: make(map[string]*ebiten.Image),
	}
	ecs.AddComponent(em, entityID, reanimComp)
	ecs.AddComponent(em, entityID, &components.PositionComponent{X: 100, Y: 100})

	// Step 1: Play both animations
	err := rs.PlayAnimations(entityID, []string{"anim_walk", "anim_burning"})
	if err != nil {
		t.Fatalf("PlayAnimations failed: %v", err)
	}

	// Verify: Both animations are active
	if len(reanimComp.AnimStates) != 2 {
		t.Errorf("Expected 2 animations initially, got %d", len(reanimComp.AnimStates))
	}

	// Step 2: Remove burning animation
	err = rs.RemoveAnimation(entityID, "anim_burning")
	if err != nil {
		t.Fatalf("RemoveAnimation failed: %v", err)
	}

	// Verify: Only walk animation remains
	if len(reanimComp.AnimStates) != 1 {
		t.Errorf("Expected 1 animation after RemoveAnimation, got %d", len(reanimComp.AnimStates))
	}

	if _, hasWalk := reanimComp.AnimStates["anim_walk"]; !hasWalk {
		t.Error("Expected anim_walk to still be present")
	}
	if _, hasBurning := reanimComp.AnimStates["anim_burning"]; hasBurning {
		t.Error("Expected anim_burning to be removed")
	}

	// Step 3: Remove non-existent animation (should not error)
	err = rs.RemoveAnimation(entityID, "anim_nonexistent")
	if err != nil {
		t.Errorf("RemoveAnimation should not error for non-existent animation, got: %v", err)
	}

	// Verify: Walk animation still present
	if len(reanimComp.AnimStates) != 1 {
		t.Errorf("Expected 1 animation after removing non-existent, got %d", len(reanimComp.AnimStates))
	}
}

// ==================================================================
// Story 6.9 QA Fix: Performance Benchmarks (AC5 Validation)
// ==================================================================
//
// These benchmarks validate that multi-animation rendering has no
// significant performance regression as required by AC5:
// - FPS ≥ 60 (frame time ≤ 16.67ms)
// - Rendering time < 5ms/frame
//
// Benchmark scenarios:
// 1. Single animation (baseline - 95% of cases)
// 2. Double animation (PeaShooter attack - 4% of cases)
// 3. Triple animation (stress test - <1% of cases)

// BenchmarkSingleAnimationUpdate benchmarks ReanimSystem.Update with one active animation (baseline).
// This represents the most common scenario (向日葵, 墙果 etc.) and establishes the performance baseline.
//
// Expected: ~1000-5000 ns/op (1-5 µs per entity update)
func BenchmarkSingleAnimationUpdate(b *testing.B) {
	// Setup: Create entity with single animation
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	// Create minimal reanim data with one animation
	reanimData := &reanim.ReanimXML{
		FPS: 12,
		Tracks: []reanim.Track{
			{
				Name: "anim_idle",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0), X: floatPtr(0), Y: floatPtr(0)},
					{FrameNum: intPtr(0), X: floatPtr(1), Y: floatPtr(1)},
					{FrameNum: intPtr(0), X: floatPtr(2), Y: floatPtr(2)},
				},
			},
			{
				Name: "part_body",
				Frames: []reanim.Frame{
					{ImagePath: "body", X: floatPtr(0), Y: floatPtr(0)},
					{ImagePath: "body", X: floatPtr(1), Y: floatPtr(1)},
					{ImagePath: "body", X: floatPtr(2), Y: floatPtr(2)},
				},
			},
		},
	}

	reanimComp := &components.ReanimComponent{
		ReanimXML:  reanimData,
		PartImages: make(map[string]*ebiten.Image),
	}
	ecs.AddComponent(em, entityID, reanimComp)
	ecs.AddComponent(em, entityID, &components.PositionComponent{X: 100, Y: 100})

	// Play single animation
	err := rs.PlayAnimation(entityID, "anim_idle")
	if err != nil {
		b.Fatalf("Failed to play animation: %v", err)
	}

	// Benchmark: Update loop (simulates frame updates)
	deltaTime := 1.0 / 60.0 // 60 FPS = 16.67ms per frame

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rs.Update(deltaTime)
	}
}

// BenchmarkDoubleAnimationUpdate benchmarks ReanimSystem.Update with two active animations.
// This represents the PeaShooter attack scenario (body + head animations).
//
// Expected: Similar to single animation (~1000-5000 ns/op)
// Acceptable overhead: < 20% compared to single animation
func BenchmarkDoubleAnimationUpdate(b *testing.B) {
	// Setup: Create entity with two animations
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	// Create minimal reanim data with two animations
	reanimData := &reanim.ReanimXML{
		FPS: 12,
		Tracks: []reanim.Track{
			{
				Name: "anim_shooting",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0), X: floatPtr(0), Y: floatPtr(0)},
					{FrameNum: intPtr(0), X: floatPtr(1), Y: floatPtr(1)},
					{FrameNum: intPtr(0), X: floatPtr(2), Y: floatPtr(2)},
				},
			},
			{
				Name: "anim_head_idle",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0), X: floatPtr(0), Y: floatPtr(0)},
					{FrameNum: intPtr(0), X: floatPtr(1), Y: floatPtr(1)},
					{FrameNum: intPtr(0), X: floatPtr(2), Y: floatPtr(2)},
				},
			},
			{
				Name: "part_body",
				Frames: []reanim.Frame{
					{ImagePath: "body", X: floatPtr(0), Y: floatPtr(0)},
					{ImagePath: "body", X: floatPtr(1), Y: floatPtr(1)},
					{ImagePath: "body", X: floatPtr(2), Y: floatPtr(2)},
				},
			},
			{
				Name: "part_head",
				Frames: []reanim.Frame{
					{ImagePath: "head", X: floatPtr(0), Y: floatPtr(0)},
					{ImagePath: "head", X: floatPtr(1), Y: floatPtr(1)},
					{ImagePath: "head", X: floatPtr(2), Y: floatPtr(2)},
				},
			},
		},
	}

	reanimComp := &components.ReanimComponent{
		ReanimXML:  reanimData,
		PartImages: make(map[string]*ebiten.Image),
	}
	ecs.AddComponent(em, entityID, reanimComp)
	ecs.AddComponent(em, entityID, &components.PositionComponent{X: 100, Y: 100})

	// Play two animations simultaneously (PeaShooter attack scenario)
	err := rs.PlayAnimations(entityID, []string{"anim_shooting", "anim_head_idle"})
	if err != nil {
		b.Fatalf("Failed to play animations: %v", err)
	}

	// Benchmark: Update loop
	deltaTime := 1.0 / 60.0 // 60 FPS

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rs.Update(deltaTime)
	}
}

// BenchmarkTripleAnimationUpdate benchmarks ReanimSystem.Update with three active animations.
// This represents an edge case stress test (e.g., walk + burn + frozen effects).
//
// Expected: Slightly higher than double animation but still < 10000 ns/op (10 µs)
// Acceptable overhead: < 50% compared to single animation
func BenchmarkTripleAnimationUpdate(b *testing.B) {
	// Setup: Create entity with three animations
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	// Create minimal reanim data with three animations
	reanimData := &reanim.ReanimXML{
		FPS: 12,
		Tracks: []reanim.Track{
			{
				Name: "anim_walk",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0), X: floatPtr(0), Y: floatPtr(0)},
					{FrameNum: intPtr(0), X: floatPtr(1), Y: floatPtr(1)},
				},
			},
			{
				Name: "anim_burning",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0), X: floatPtr(0), Y: floatPtr(0)},
					{FrameNum: intPtr(0), X: floatPtr(1), Y: floatPtr(1)},
				},
			},
			{
				Name: "anim_frozen",
				Frames: []reanim.Frame{
					{FrameNum: intPtr(0), X: floatPtr(0), Y: floatPtr(0)},
					{FrameNum: intPtr(0), X: floatPtr(1), Y: floatPtr(1)},
				},
			},
			{
				Name: "part_body",
				Frames: []reanim.Frame{
					{ImagePath: "body", X: floatPtr(0), Y: floatPtr(0)},
					{ImagePath: "body", X: floatPtr(1), Y: floatPtr(1)},
				},
			},
		},
	}

	reanimComp := &components.ReanimComponent{
		ReanimXML:  reanimData,
		PartImages: make(map[string]*ebiten.Image),
	}
	ecs.AddComponent(em, entityID, reanimComp)
	ecs.AddComponent(em, entityID, &components.PositionComponent{X: 100, Y: 100})

	// Play three animations simultaneously (stress test)
	err := rs.PlayAnimations(entityID, []string{"anim_walk", "anim_burning", "anim_frozen"})
	if err != nil {
		b.Fatalf("Failed to play animations: %v", err)
	}

	// Benchmark: Update loop
	deltaTime := 1.0 / 60.0 // 60 FPS

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		rs.Update(deltaTime)
	}
}

// ==================================================================
// Story 13.3: Parent-Child Offset System Unit Tests
// ==================================================================
//
// These tests verify the parent-child offset calculation system
// as required by Task 5 of Story 13.3.

// TestSetParentTracks_Success tests the SetParentTracks API
func TestSetParentTracks_Success(t *testing.T) {
	// Setup
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	reanimComp := &components.ReanimComponent{
		ReanimXML:    &reanim.ReanimXML{FPS: 12},
		ParentTracks: nil, // Initially nil
	}
	ecs.AddComponent(em, entityID, reanimComp)

	// Test: Set parent tracks
	parentTracks := map[string]string{
		"anim_face": "anim_stem",
		"left_arm":  "body",
		"right_arm": "body",
	}
	err := rs.SetParentTracks(entityID, parentTracks)

	// Verify
	if err != nil {
		t.Fatalf("SetParentTracks failed: %v", err)
	}

	comp, _ := ecs.GetComponent[*components.ReanimComponent](em, entityID)
	if len(comp.ParentTracks) != 3 {
		t.Errorf("Expected 3 parent tracks, got %d", len(comp.ParentTracks))
	}

	if comp.ParentTracks["anim_face"] != "anim_stem" {
		t.Errorf("Expected anim_face -> anim_stem, got %s", comp.ParentTracks["anim_face"])
	}
	if comp.ParentTracks["left_arm"] != "body" {
		t.Errorf("Expected left_arm -> body, got %s", comp.ParentTracks["left_arm"])
	}
}

// TestSetParentTracks_EntityWithoutReanimComponent tests error handling
func TestSetParentTracks_EntityWithoutReanimComponent(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity() // No ReanimComponent

	err := rs.SetParentTracks(entityID, map[string]string{"a": "b"})

	if err == nil {
		t.Fatal("Expected error for entity without ReanimComponent")
	}
}

// TestSetParentTrack_Success tests the SetParentTrack API
func TestSetParentTrack_Success(t *testing.T) {
	// Setup
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	reanimComp := &components.ReanimComponent{
		ReanimXML:    &reanim.ReanimXML{FPS: 12},
		ParentTracks: nil, // Initially nil
	}
	ecs.AddComponent(em, entityID, reanimComp)

	// Test: Set individual parent track
	err := rs.SetParentTrack(entityID, "anim_face", "anim_stem")

	// Verify
	if err != nil {
		t.Fatalf("SetParentTrack failed: %v", err)
	}

	comp, _ := ecs.GetComponent[*components.ReanimComponent](em, entityID)
	if comp.ParentTracks == nil {
		t.Fatal("ParentTracks should be initialized")
	}
	if comp.ParentTracks["anim_face"] != "anim_stem" {
		t.Errorf("Expected anim_face -> anim_stem, got %s", comp.ParentTracks["anim_face"])
	}
}

// TestSetParentTrack_MultipleInvocations tests adding multiple parent tracks
func TestSetParentTrack_MultipleInvocations(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)
	entityID := em.CreateEntity()

	reanimComp := &components.ReanimComponent{
		ReanimXML: &reanim.ReanimXML{FPS: 12},
	}
	ecs.AddComponent(em, entityID, reanimComp)

	// Add multiple parent tracks
	rs.SetParentTrack(entityID, "anim_face", "anim_stem")
	rs.SetParentTrack(entityID, "left_arm", "body")
	rs.SetParentTrack(entityID, "right_arm", "body")

	// Verify all are present
	comp, _ := ecs.GetComponent[*components.ReanimComponent](em, entityID)
	if len(comp.ParentTracks) != 3 {
		t.Errorf("Expected 3 parent tracks, got %d", len(comp.ParentTracks))
	}
}

// TestGetParentOffset_BasicOffset tests basic offset calculation
func TestGetParentOffset_BasicOffset(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	// Create ReanimComponent with parent track data
	// Parent track "anim_stem" moves from (37.6, 48.7) to (40.0, 50.0)
	comp := &components.ReanimComponent{
		CurrentAnim: "anim_shooting",
		TrackBindings: map[string]string{
			"anim_stem": "anim_shooting",
		},
		AnimStates: map[string]*components.AnimState{
			"anim_shooting": {
				Name:         "anim_shooting",
				LogicalFrame: 2, // Currently at frame 2 (3rd visible frame)
				IsActive:     true,
			},
		},
		MergedTracks: map[string][]reanim.Frame{
			"anim_stem": {
				// Frame 0 (first visible, initial position)
				{X: floatPtr(37.6), Y: floatPtr(48.7)},
				// Frame 1
				{X: floatPtr(38.8), Y: floatPtr(49.35)},
				// Frame 2 (current position)
				{X: floatPtr(40.0), Y: floatPtr(50.0)},
			},
		},
		AnimVisiblesMap: map[string][]int{
			"anim_shooting": {0, 0, 0}, // All frames visible
		},
	}

	// Calculate offset
	offsetX, offsetY := rs.getParentOffset("anim_stem", comp)

	// Expected offset: (40.0 - 37.6, 50.0 - 48.7) = (2.4, 1.3)
	expectedOffsetX := 2.4
	expectedOffsetY := 1.3

	if !floatEquals(offsetX, expectedOffsetX, 0.01) {
		t.Errorf("Expected offsetX=%.2f, got %.2f", expectedOffsetX, offsetX)
	}
	if !floatEquals(offsetY, expectedOffsetY, 0.01) {
		t.Errorf("Expected offsetY=%.2f, got %.2f", expectedOffsetY, offsetY)
	}
}

// TestGetParentOffset_NoParentTrack tests offset when parent track doesn't exist
func TestGetParentOffset_NoParentTrack(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		CurrentAnim:   "anim_idle",
		TrackBindings: map[string]string{},
		MergedTracks:  map[string][]reanim.Frame{},
	}

	// Calculate offset for non-existent parent track
	offsetX, offsetY := rs.getParentOffset("nonexistent_track", comp)

	// Expected: (0, 0) - no offset for missing track
	if offsetX != 0 || offsetY != 0 {
		t.Errorf("Expected zero offset for missing track, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// TestGetParentOffset_NoVisibleFrames tests offset when parent has no visible frames
func TestGetParentOffset_NoVisibleFrames(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		CurrentAnim: "anim_test",
		TrackBindings: map[string]string{
			"parent_track": "anim_test",
		},
		AnimStates: map[string]*components.AnimState{
			"anim_test": {
				Name:         "anim_test",
				LogicalFrame: 0,
				IsActive:     true,
			},
		},
		MergedTracks: map[string][]reanim.Frame{
			"parent_track": {
				{X: floatPtr(10.0), Y: floatPtr(20.0)},
			},
		},
		AnimVisiblesMap: map[string][]int{
			"anim_test": {-1}, // All frames hidden
		},
	}

	// Calculate offset
	offsetX, offsetY := rs.getParentOffset("parent_track", comp)

	// Expected: (0, 0) - no offset when no visible frames
	if offsetX != 0 || offsetY != 0 {
		t.Errorf("Expected zero offset for track with no visible frames, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// TestGetParentOffset_NilPositionData tests offset when frame has nil X/Y
func TestGetParentOffset_NilPositionData(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		CurrentAnim: "anim_test",
		TrackBindings: map[string]string{
			"parent_track": "anim_test",
		},
		AnimStates: map[string]*components.AnimState{
			"anim_test": {
				Name:         "anim_test",
				LogicalFrame: 0,
				IsActive:     true,
			},
		},
		MergedTracks: map[string][]reanim.Frame{
			"parent_track": {
				{X: nil, Y: nil}, // Nil position data
			},
		},
		AnimVisiblesMap: map[string][]int{
			"anim_test": {0}, // Frame visible
		},
	}

	// Calculate offset
	offsetX, offsetY := rs.getParentOffset("parent_track", comp)

	// Expected: (0, 0) - no offset when position data is nil
	if offsetX != 0 || offsetY != 0 {
		t.Errorf("Expected zero offset for nil position data, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// TestGetParentOffset_ZeroOffset tests offset when parent hasn't moved
func TestGetParentOffset_ZeroOffset(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	// Parent track stays at same position (50.0, 60.0)
	comp := &components.ReanimComponent{
		CurrentAnim: "anim_static",
		TrackBindings: map[string]string{
			"parent_track": "anim_static",
		},
		AnimStates: map[string]*components.AnimState{
			"anim_static": {
				Name:         "anim_static",
				LogicalFrame: 1,
				IsActive:     true,
			},
		},
		MergedTracks: map[string][]reanim.Frame{
			"parent_track": {
				{X: floatPtr(50.0), Y: floatPtr(60.0)}, // Initial
				{X: floatPtr(50.0), Y: floatPtr(60.0)}, // Current (same)
			},
		},
		AnimVisiblesMap: map[string][]int{
			"anim_static": {0, 0},
		},
	}

	offsetX, offsetY := rs.getParentOffset("parent_track", comp)

	// Expected: (0, 0) - no movement
	if offsetX != 0 || offsetY != 0 {
		t.Errorf("Expected zero offset for static parent, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// TestGetParentOffset_MissingAnimation tests offset when animation doesn't exist
func TestGetParentOffset_MissingAnimation(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		CurrentAnim:     "anim_missing",
		TrackBindings:   map[string]string{},
		AnimStates:      map[string]*components.AnimState{}, // No animation state
		MergedTracks:    map[string][]reanim.Frame{},
		AnimVisiblesMap: map[string][]int{},
	}

	// Calculate offset
	offsetX, offsetY := rs.getParentOffset("parent_track", comp)

	// Expected: (0, 0) - no offset when animation missing
	if offsetX != 0 || offsetY != 0 {
		t.Errorf("Expected zero offset for missing animation, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// ==================================================================
// Helper Functions for Story 13.3 Tests
// ==================================================================

// floatEquals checks if two floats are approximately equal within epsilon
func floatEquals(a, b, epsilon float64) bool {
	diff := a - b
	if diff < 0 {
		diff = -diff
	}
	return diff < epsilon
}

// ==================================================================
// Story 13.4: Render Cache Optimization Tests
// ==================================================================

// TestGetCurrentLogicalFrame_SingleAnimation 测试单动画场景
func TestGetCurrentLogicalFrame_SingleAnimation(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		CurrentAnimations: []string{"anim_idle"},
		AnimStates: map[string]*components.AnimState{
			"anim_idle": {
				Name:         "anim_idle",
				LogicalFrame: 5,
				IsActive:     true,
			},
		},
	}

	frame := rs.getCurrentLogicalFrame(comp)

	if frame != 5 {
		t.Errorf("Expected logical frame 5, got %d", frame)
	}
}

// TestGetCurrentLogicalFrame_MultiAnimation 测试多动画场景（返回主动画帧）
func TestGetCurrentLogicalFrame_MultiAnimation(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		CurrentAnimations: []string{"anim_shooting", "anim_head_idle"},
		AnimStates: map[string]*components.AnimState{
			"anim_shooting": {
				Name:         "anim_shooting",
				LogicalFrame: 10,
				IsActive:     true,
			},
			"anim_head_idle": {
				Name:         "anim_head_idle",
				LogicalFrame: 3,
				IsActive:     true,
			},
		},
	}

	frame := rs.getCurrentLogicalFrame(comp)

	// 应该返回第一个动画（主动画）的帧
	if frame != 10 {
		t.Errorf("Expected logical frame 10 (from primary animation), got %d", frame)
	}
}

// TestGetCurrentLogicalFrame_NoAnimation 测试无动画场景（返回 0）
func TestGetCurrentLogicalFrame_NoAnimation(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		CurrentAnimations: []string{},
		AnimStates:        map[string]*components.AnimState{},
	}

	frame := rs.getCurrentLogicalFrame(comp)

	if frame != 0 {
		t.Errorf("Expected logical frame 0 for no animation, got %d", frame)
	}
}

// TestGetParentOffsetIfNeeded_NoParent 测试无父轨道场景
func TestGetParentOffsetIfNeeded_NoParent(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		ParentTracks:  map[string]string{},
		TrackBindings: map[string]string{},
	}

	offsetX, offsetY := rs.getParentOffsetIfNeeded("some_track", comp)

	if offsetX != 0 || offsetY != 0 {
		t.Errorf("Expected (0, 0) for track without parent, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// TestGetParentOffsetIfNeeded_SameAnimation 测试子父使用相同动画（不应用偏移）
func TestGetParentOffsetIfNeeded_SameAnimation(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		ParentTracks: map[string]string{
			"child_track": "parent_track",
		},
		TrackBindings: map[string]string{
			"child_track":  "anim_shooting",
			"parent_track": "anim_shooting", // 相同动画
		},
	}

	offsetX, offsetY := rs.getParentOffsetIfNeeded("child_track", comp)

	// 子父使用相同动画，不应用偏移
	if offsetX != 0 || offsetY != 0 {
		t.Errorf("Expected (0, 0) for same animation, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// TestGetParentOffsetIfNeeded_DifferentAnimation 测试子父使用不同动画（应用偏移）
func TestGetParentOffsetIfNeeded_DifferentAnimation(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	comp := &components.ReanimComponent{
		ParentTracks: map[string]string{
			"child_track": "parent_track",
		},
		TrackBindings: map[string]string{
			"child_track":  "anim_head_idle",
			"parent_track": "anim_shooting", // 不同动画
		},
		AnimStates: map[string]*components.AnimState{
			"anim_shooting": {
				Name:         "anim_shooting",
				LogicalFrame: 1, // 当前在第2个可见帧
				IsActive:     true,
			},
		},
		MergedTracks: map[string][]reanim.Frame{
			"parent_track": {
				{X: floatPtr(0.0), Y: floatPtr(0.0)},    // 初始位置（第一个可见帧）
				{X: floatPtr(15.0), Y: floatPtr(25.0)},  // 当前位置（第二个可见帧）
			},
		},
		AnimVisiblesMap: map[string][]int{
			"anim_shooting": {0, 0}, // 两帧都可见
		},
	}

	offsetX, offsetY := rs.getParentOffsetIfNeeded("child_track", comp)

	// 偏移 = 当前位置 - 初始位置 = (15, 25) - (0, 0) = (15, 25)
	if offsetX != 15.0 || offsetY != 25.0 {
		t.Errorf("Expected (15.0, 25.0) offset, got (%.2f, %.2f)", offsetX, offsetY)
	}
}

// TestPrepareRenderCache_BasicScenario 测试基本缓存构建（单个动画）
func TestPrepareRenderCache_BasicScenario(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	// 创建测试图片
	img1 := ebiten.NewImage(10, 10)
	img2 := ebiten.NewImage(20, 20)

	comp := &components.ReanimComponent{
		CurrentAnimations: []string{"anim_idle"},
		TrackBindings: map[string]string{
			"track1": "anim_idle",
			"track2": "anim_idle",
		},
		AnimStates: map[string]*components.AnimState{
			"anim_idle": {
				Name:         "anim_idle",
				LogicalFrame: 0,
				IsActive:     true,
			},
		},
		MergedTracks: map[string][]reanim.Frame{
			"track1": {
				{ImagePath: "IMAGE_PART1", X: floatPtr(10.0), Y: floatPtr(20.0)},
			},
			"track2": {
				{ImagePath: "IMAGE_PART2", X: floatPtr(30.0), Y: floatPtr(40.0)},
			},
		},
		PartImages: map[string]*ebiten.Image{
			"IMAGE_PART1": img1,
			"IMAGE_PART2": img2,
		},
		AnimVisiblesMap: map[string][]int{
			"anim_idle": {0}, // 所有帧可见
		},
		AnimTracks: []reanim.Track{
			{Name: "track1"},
			{Name: "track2"},
		},
		CachedRenderData: make([]components.RenderPartData, 0, 10),
	}

	// 构建缓存
	rs.prepareRenderCache(comp)

	// 验证缓存长度
	if len(comp.CachedRenderData) != 2 {
		t.Errorf("Expected cache length 2, got %d", len(comp.CachedRenderData))
	}

	// 验证第一个缓存项
	if comp.CachedRenderData[0].Img != img1 {
		t.Error("Expected first cache item to have img1")
	}
	if *comp.CachedRenderData[0].Frame.X != 10.0 {
		t.Errorf("Expected X=10.0, got %.2f", *comp.CachedRenderData[0].Frame.X)
	}

	// 验证第二个缓存项
	if comp.CachedRenderData[1].Img != img2 {
		t.Error("Expected second cache item to have img2")
	}
	if *comp.CachedRenderData[1].Frame.Y != 40.0 {
		t.Errorf("Expected Y=40.0, got %.2f", *comp.CachedRenderData[1].Frame.Y)
	}
}

// TestPrepareRenderCache_CacheReuse 测试缓存切片重用
func TestPrepareRenderCache_CacheReuse(t *testing.T) {
	em := ecs.NewEntityManager()
	rs := NewReanimSystem(em)

	img := ebiten.NewImage(10, 10)

	comp := &components.ReanimComponent{
		CurrentAnimations: []string{"anim_idle"},
		TrackBindings: map[string]string{
			"track1": "anim_idle",
		},
		AnimStates: map[string]*components.AnimState{
			"anim_idle": {
				Name:         "anim_idle",
				LogicalFrame: 0,
				IsActive:     true,
			},
		},
		MergedTracks: map[string][]reanim.Frame{
			"track1": {
				{ImagePath: "IMAGE_PART1", X: floatPtr(10.0), Y: floatPtr(20.0)},
			},
		},
		PartImages: map[string]*ebiten.Image{
			"IMAGE_PART1": img,
		},
		AnimVisiblesMap: map[string][]int{
			"anim_idle": {0},
		},
		AnimTracks: []reanim.Track{
			{Name: "track1"},
		},
		CachedRenderData: make([]components.RenderPartData, 0, 10),
	}

	// 第一次构建
	rs.prepareRenderCache(comp)
	if len(comp.CachedRenderData) != 1 {
		t.Errorf("Expected cache length 1 after first build, got %d", len(comp.CachedRenderData))
	}

	// 验证容量不变
	if cap(comp.CachedRenderData) != 10 {
		t.Errorf("Expected capacity 10, got %d", cap(comp.CachedRenderData))
	}

	// 第二次构建（应该重用切片）
	rs.prepareRenderCache(comp)
	if len(comp.CachedRenderData) != 1 {
		t.Errorf("Expected cache length 1 after second build, got %d", len(comp.CachedRenderData))
	}

	// 容量应该保持不变（切片重用成功）
	if cap(comp.CachedRenderData) != 10 {
		t.Errorf("Expected capacity 10 after reuse, got %d", cap(comp.CachedRenderData))
	}
}
