# Project Brief: 植物大战僵尸 Go 复刻版

## **1. Executive Summary (执行摘要)**

本项目旨在通过使用Go语言及Ebitengine游戏引擎，一比一复刻经典的《植物大战僵尸》PC中文年度版核心玩法，以此作为游戏开发的学习实践。首个可交付版本(MVP)将专注于完整实现游戏的前院白天场景（1-1至1-10关卡），包含核心的植物种植、阳光收集、以及与基础僵尸的对抗机制。该项目优先面向PC平台（Windows/macOS/Linux），并计划构建一个可扩展的基础，以便未来能够继续添加更多游戏内容，如夜晚、泳池等关卡和其他游戏模式。

## **2. Problem Statement (目标陈述)**

我们的核心目标是学习游戏开发，具体挑战是精确地再现《植物大战僵尸》PC年度版的核心游戏体验。这个挑战可以分解为以下几个关键任务：

*   **游戏引擎与资源集成：** 关键挑战在于如何有效地使用 Go 和 Ebitengine 引擎加载并管理所有已准备好的游戏资源，包括但不限于植物、僵尸的动画序列图（spritesheets）、UI元素、背景音乐和音效。**一个核心前提是：所有必要的图片和音频素材均已齐备，无需美术或音频创作。**
*   **核心游戏循环复现：** 必须实现游戏的主循环逻辑，包括关卡的开始与结束、僵尸的生成与波次推进、胜利/失败条件的判断。
*   **游戏机制实现：** 需要精确实现前院白天关卡中的核心玩法机制，包括：
    *   **阳光系统**：自然的阳光掉落和向日葵的阳光生产。
    *   **植物系统**：向日葵、豌豆射手等基础植物的种植、冷却时间和攻击行为。
    *   **僵尸系统**：普通僵尸、路障僵尸等基础僵尸的移动、啃食和死亡行为。
    *   **交互系统**：玩家通过鼠标点击收集阳光、选择植物卡片、在草坪格子上种植植物以及使用铲子移除植物。
*   **UI与状态管理：** 需要复刻游戏的主界面UI，包括植物选择栏、阳光计数器、关卡进度条等，并确保这些UI元素能准确反映和更新游戏内部的状态。

## **3. Proposed Solution (解决方案)**

我们将采用一种模块化、事件驱动的方法，使用 **Go + Ebitengine** 技术栈来构建一个结构清晰、易于扩展的游戏。解决方案的核心思想是将游戏的不同方面（如植物、僵尸、游戏逻辑、UI）分离成独立的模块，并通过一个中心游戏循环进行协调。

*   **资源管理器 (Resource Manager):** 我们将构建一个集中的资源管理器。该模块将在游戏启动时，一次性加载所有已备好的图片和音频素材。它会负责处理雪碧图（spritesheets）的切割，将大的图片文件解析成独立的动画帧，并为游戏中所有对象（植物、僵尸、子弹等）提供按需访问这些资源的接口。

*   **实体-组件系统 (Entity-Component System - ECS) 理念:** 虽然不一定严格实现ECS框架，但我们将借鉴其核心思想。游戏中的每一个对象（如一个豌豆射手、一个僵尸）都将作为一个“实体(Entity)”，其行为和属性（如生命值、攻击力、移动速度）将由不同的“组件(Component)”来定义。这种方法使得添加新类型的植物或僵尸变得非常容易，只需组合不同的组件即可。

*   **游戏状态机 (Game State Machine):** 我们将实现一个状态机来管理整个游戏的不同阶段，例如：主菜单、关卡选择、游戏进行中、暂停、胜利/失败界面等。这确保了在不同游戏状态下，只有相关的逻辑被执行和渲染。

*   **基于网格的逻辑 (Grid-Based Logic):** 游戏的核心玩法将基于一个二维网格（代表草坪）。我们将创建一个网格管理器来处理所有与位置相关的逻辑，比如植物的种植位置、僵尸的行进路线以及子弹的碰撞检测。

*   **UI系统:** 利用Ebitengine的绘图功能，我们将构建一个独立的UI系统，用于渲染和管理所有界面元素（如植物卡片、阳光计数器）。这个系统将从主游戏逻辑中读取状态（例如当前阳光数量）来更新显示，并通过事件（例如点击卡片）将玩家的输入传递给游戏逻辑控制器。

## **4. Goals & Success Metrics (目标与成功指标)**

### **Business Objectives (项目目标)**
*   **主要目标：** 成功掌握使用Go语言和Ebitengine引擎进行2D游戏开发的核心流程和关键技术。
*   **次要目标：** 创建一个功能完整、可独立运行的游戏项目，作为个人作品集中的一个高质量范例。
*   **扩展目标：** 构建一个模块化、可扩展的代码基础，为未来添加更多关卡和游戏模式（如夜晚、泳池、小游戏）提供可能性。

### **User Success Metrics (用户成功指标)**
由于这是一个复刻项目，“用户”即为我们自己（开发者）。成功的标准是游戏体验的忠实度。
*   **玩法一致性：** 游戏的核心玩法（阳光生产与收集、植物种植与攻击、僵尸生成与行进）与原版PC游戏在前院白天关卡的体验“感觉”一致。
*   **视觉保真度：** 游戏中的动画、UI布局和视觉效果与原版游戏几乎没有差别。
*   **音频同步性：** 背景音乐、植物攻击音效、僵尸呻吟声等音频能在正确的时机播放。

### **Key Performance Indicators (关键绩效指标 - 针对学习目标)**
*   **代码模块化程度：** 能够轻松地添加一个新的、简单的植物或僵尸类型，而无需大规模修改现有代码。
*   **可测试性：** 游戏的核心逻辑（如伤害计算、阳光生成逻辑）是独立的、可进行单元测试的。
*   **功能完成度：** MVP范围内的所有核心功能（前院白天10个关卡）都已实现并通过测试。

## **5. MVP Scope (最小可行产品范围)**

### **Core Features (Must Have - 核心功能)**
*   **游戏场景:** 完整的前院白天草坪场景（5行9列网格）。
*   **游戏流程:**
    *   可运行的游戏主菜单界面（包含“开始冒险”、“退出游戏”按钮）。
    *   完整的关卡流程，包括“一大波僵尸正在接近”的提示和最后一波僵尸的旗帜。
    *   胜利（完成关卡）和失败（僵尸到达房子）的游戏结束条件及相应界面。
*   **植物系统 (Plants System):**
    *   **向日葵 (Sun Flower):** 能够生产阳光。
    *   **豌豆射手 (Pea Shooter):** 能够发射豌豆攻击僵尸。
    *   **坚果墙 (Wall-nut):** 能够阻挡僵尸，具有较高的生命值。
    *   **樱桃炸弹 (Cherry Bomb):** 种植后立即爆炸，消灭周围一定范围内的僵尸。
*   **僵尸系统 (Zombies System):**
    *   **普通僵尸 (Zombie):** 标准的移动和啃食行为。
    *   **路障僵尸 (Conehead Zombie):** 持有路障，生命值更高。
    *   **铁桶僵尸 (Buckethead Zombie):** 持有铁桶，生命值极高。
*   **玩家交互系统 (Player Interaction):**
    *   **阳光收集:** 点击收集从天上掉落和向日葵生产的阳光。
    *   **植物选择与种植:** 从植物选择栏点击卡片，在草坪网格上种植植物，并处理冷却时间。
    *   **铲子功能:** 可以使用铲子移除已种植的植物。

### **Out of Scope for MVP (MVP范围之外)**
*   所有其他植物和僵尸: 包括但不限于食人花、寒冰射手、读报僵尸、撑杆跳僵尸等。
*   所有其他游戏场景: 夜晚、泳池、屋顶场景及其相关的环境机制（如蘑菇、睡莲）。
*   所有其他游戏模式: 小游戏、解谜模式、生存模式、禅境花园。
*   游戏内商店和金币系统。
*   “疯狂戴夫”的角色和对话系统。
*   复杂的设置选项: 如音量调节、画质选择等。
*   游戏存档与读档功能。

### **MVP Success Criteria (MVP成功标准)**
MVP被视为成功，当且仅当一个玩家可以从主菜单开始，完整地玩通前院白天的所有10个关卡，并且所有在“核心功能”中列出的植物、僵尸和交互都按照原版游戏的逻辑正常工作。

## **6. Technical Considerations (技术注意事项)**

### **Platform Requirements (平台要求)**
*   **目标平台:** PC (Windows, macOS, Linux)。利用Ebitengine的跨平台能力进行构建和打包。
*   **性能要求:** 游戏应能在主流的集成显卡上流畅运行（60 FPS），CPU和内存占用率应保持在合理水平，避免出现卡顿或延迟。

### **Technology Preferences (技术偏好)**
*   **语言:** Go (最新稳定版)。
*   **游戏引擎:** Ebitengine (最新稳定版)。
*   **核心原则:** 尽可能只使用Go标准库和Ebitengine自身提供的功能，避免引入过多的第三方依赖，以保持项目的简洁性，更好地服务于学习目标。

### **Architecture Considerations (架构注意事项)**
*   **代码组织:** 项目结构应清晰地分离不同功能模块，例如 `assets` (资源), `components` (游戏对象组件), `scenes` (游戏场景/状态), `systems` (处理逻辑), 和 `main.go` (主入口)。
*   **游戏对象设计:** 采用基于组件的设计模式。例如，一个“僵尸”实体将由“健康组件”、“移动组件”、“攻击组件”和“渲染组件”等组合而成。
*   **碰撞检测:** 利用Ebitengine的API实现一个基于矩形包围盒（Rectangular Bounding Box）的简单碰撞检测系统，用于处理豌豆子弹与僵尸、僵尸与植物之间的交互。
*   **可扩展性:** 整体架构设计应考虑到未来的扩展性，使得在MVP完成后，添加新的植物、僵尸或游戏场景（如夜晚）时，对现有代码的侵入性降到最低。

## **7. Constraints & Assumptions (限制与假设)**

### **Constraints (限制因素)**
*   **资源限制:** 本项目不设专门的美术、音效或策划人员。所有视觉和音频资源完全依赖于已备好的素材库。
*   **技术限制:** 必须严格使用Go + Ebitengine技术栈，不得引入其他游戏引擎或图形库。
*   **范围限制:** 开发范围严格限定于MVP（最小可行产品）定义的功能，任何超出范围的功能（如新植物、新僵尸、新模式）都必须在MVP完成后再进行规划。
*   **时间/预算:** 作为一个学习项目，本项目没有严格的时间表或预算限制。进度由学习和开发节奏驱动。

### **Key Assumptions (关键假设)**
*   **资源完整性:** 我们假设已备好的素材库包含了实现MVP所需的所有图片和音频资源，且资源格式与Ebitengine兼容。
*   **引擎能力:** 我们假设Ebitengine的功能足以支持实现原版游戏的所有核心机制和视觉效果，无需进行引擎层面的定制开发。
*   **玩法逻辑清晰:** 我们假设原版游戏的核心玩法逻辑可以通过观察和分析被完全理解和复现。

## **8. Risks & Open Questions (风险与开放问题)**

### **Key Risks (主要风险)**
*   **性能风险:** 随着屏幕上的植物、僵尸和子弹数量增多，游戏可能会遇到性能瓶颈。需要持续关注渲染效率和内存管理。
*   **逻辑复杂度风险:** 某些游戏逻辑（如僵尸的AI行为、植物与僵尸的复杂交互）可能比表面上看起来更复杂，导致实现周期超出预期。
*   **“感觉”不一致风险:** 最大的挑战之一是调校各种参数（如僵尸移动速度、植物攻击频率、阳光掉落率），以达到与原版游戏完全一致的“手感”和节奏。这可能需要大量的微调和测试。

### **Open Questions (开放问题)**
*   **动画系统实现:** 如何在Ebitengine中最高效地实现和管理基于雪碧图（spritesheet）的复杂动画状态机（例如，僵尸从走到啃食再到死亡的动画切换）？
*   **数据驱动设计:** 我们应该在多大程度上采用数据驱动的方法？例如，是否应该将所有植物和僵尸的属性（生命值、攻击力、冷却时间等）存储在外部文件（如JSON或YAML）中，以便于调整和扩展？