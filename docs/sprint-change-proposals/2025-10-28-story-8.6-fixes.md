# Sprint Change Proposal - Story 8.6 修正

**日期**: 2025-10-28
**触发 Story**: Story 8.6 (关卡 1-2 至 1-4 实现)
**变更类型**: 配置错误修正 + 缺失功能识别
**影响范围**: 关卡 1-2 配置、植物解锁系统、铺草皮动画系统
**状态**: 🟡 等待用户审批

---

## 变更摘要 (Change Summary)

在实现 Story 8.6 (关卡 1-2 至 1-4) 过程中,用户发现以下问题:

1. **背景图和铺草皮动画配置错误**: 关卡 1-2 应该延续上一关场景(第3行草皮已铺好),但当前配置不正确
2. **铲子解锁配置确认**: 用户确认关卡 1-2 不应该解锁铲子(配置正确)
3. **向日葵无法种植**: 关卡 1-2 配置了向日葵为可用植物,但实际无法种植

---

## 1. 识别的问题 (Identified Issues)

### ✅ 问题 1: 背景图和铺草皮动画配置错误

**现状**:
- 关卡 1-2 配置文件 `level-1-2.yaml` 使用了 `IMAGE_BACKGROUND1UNSODDED`(完全未铺草皮背景)
- 当前草皮动画行为: 第2、3、4行**同时**铺草皮

**期望行为** (参考 `.meta/levels/chapter1.md:89`):
> 背景图渲染:使用配置中的背景图,要延续上一关的场景,初始化时第3行的草皮就是铺好的(即初始就要渲染好这一行的草皮),铺草皮动画是和level 1-1时一样的渲染方式,但是分别同时渲染第2行和第4行的草皮。

**资源约束** (用户确认):
- ✅ 只有 `IMAGE_BACKGROUND1UNSODDED`(完全未铺草皮)
- ✅ 只有 `IMAGE_BACKGROUND1`(完全铺好草皮)
- ❌ **没有** `IMAGE_BACKGROUND1_SODROW3`(第3行已铺草皮)

**解决方案**:
- 使用 `IMAGE_BACKGROUND1UNSODDED` + **初始化时预先渲染第3行草皮**
- 铺草皮动画只在第2/4行播放(第3行跳过)

**根本原因**:
1. **配置缺失**: 未配置 `preSoddedLanes` 和 `soddingAnimLanes` 字段
2. **系统功能缺失**: SoddingSystem 不支持"跳过特定行"和"预渲染特定行"

---

### ✅ 问题 2: 铲子解锁配置确认

**现状**:
- 关卡 1-2 配置文件 `level-1-2.yaml` **未配置** `unlockTools`
- 用户报告: "本关也没有解锁铲子"

**期望行为** (参考 `.meta/levels/chapter1.md:102`):
- **关卡 1-4 完成后解锁铲子** (不是 1-2 或 1-3)
- `level-1-3.yaml:19` 已正确配置: `unlockTools: ["shovel"]`

**结论**:
- ✅ 1-2 配置**正确**(不应该解锁铲子)
- ⚠️ **实际问题**: 铲子工具系统尚未实现(Task 14 已标记为延后)
- 📝 **需要**: 在文档中明确说明铲子功能状态

---

### ✅ 问题 3: 向日葵无法种植

**现状**:
- 关卡 1-2 配置: `availablePlants: ["peashooter", "sunflower"]`
- 用户报告: "为什么配置了有效植物有向日葵,但是向日葵无法种植"

**期望行为**:
- 玩家应该能够选择并种植向日葵

**根本原因分析**:

#### 代码路径追踪:
1. **配置读取**: `level_config.go:21` 定义 `AvailablePlants []string`
2. **卡片创建**: `plant_selection_module.go:141-146` 使用 `levelConfig.AvailablePlants` 创建卡片
3. **植物类型映射**: `plant_selection_module.go:120-138` 定义 `plantTypeMap`
4. **关键发现**: `plantTypeMap` **包含** `"sunflower": components.PlantSunflower`

#### 可能原因:
- **PlantUnlockManager 冲突**: `plant_unlock_manager.go:28-36` 默认只解锁 `peashooter`
- **卡片过滤逻辑**: 可能存在某处根据解锁状态过滤卡片
- **向日葵工厂缺失**: 可能 `entities/plant_factory.go` 缺少向日葵实体创建函数

#### 需要验证的代码位置:
- `pkg/entities/plant_factory.go` - 向日葵工厂函数
- `pkg/systems/plant_selection_system.go` - 卡片创建逻辑
- `pkg/modules/plant_selection_module.go:160-187` - 卡片实体创建循环

**解决方案**:
- 创建详细的调试任务 `.ai/debug-tasks/sunflower-plant-issue.md`
- 优先级 P0 (阻塞关卡 1-2 游玩)

---

## 2. Epic 影响评估 (Epic Impact Assessment)

### 当前 Epic 状态

**Epic 8 - Story 8.6**:
- ✅ 可以继续完成
- ⚠️ 需要修正配置错误
- ⚠️ 需要明确铲子功能延后状态

### 影响的任务清单

| Task | 状态 | 影响 |
|------|------|------|
| Task 1 (1-2 配置) | ❌ 部分错误 | 需要修正草皮渲染配置 |
| Task 14 (铲子系统) | ⏭️ 已延后 | 确认延后,用户需明确知晓 |
| 向日葵种植问题 | 🔍 待调查 | 需要代码调试验证根本原因 |

---

## 3. 项目文档冲突分析 (Artifact Conflict Analysis)

### ✅ PRD 冲突检查
- **无冲突**: 原版游戏设计文档 `chapter1.md` 清晰定义了 1-2 关卡的草皮渲染行为

### ✅ 架构文档冲突检查
- **无冲突**: ECS 架构和系统设计正确
- **功能缺失**: SoddingSystem 需要扩展支持"部分行动画"和"预渲染特定行"功能

### ✅ Story 文档冲突检查
- **Story 8.6 文档** (`docs/stories/8.6.story.md`):
  - AC 1 (line 13-22): 描述了 1-2 关卡配置,但**未明确草皮渲染行为**
  - Dev Notes (line 411-477): 未记录 chapter1.md 中的草皮渲染需求
  - **文档不完整**: 缺少 chapter1.md 的关键需求

---

## 4. 推荐解决方案 (Recommended Path Forward)

### 🎯 方案选择: **Option 1 - 直接调整 (Direct Adjustment)**

**理由**:
1. 问题范围明确,不影响核心架构
2. 不需要回滚已完成的工作
3. 改动成本低,风险可控

---

## 5. 具体修改建议 (Proposed Edits)

### 📝 Edit 1: 修正关卡 1-2 配置文件

**文件**: `data/levels/level-1-2.yaml`

**当前配置** (lines 18-23):
```yaml
# 草皮配置(三行)
backgroundImage: "IMAGE_BACKGROUND1UNSODDED"  # 使用标准背景
sodRowImage: "IMAGE_SOD3ROW"          # 3行草地图片

# Story 11.4:铺草皮粒子特效配置
sodRollAnimation: true                        # 启用铺草皮动画
sodRollParticles: true                        # 启用土粒飞溅特效
```

**修改后**:
```yaml
# 草皮配置(三行)
# 关卡 1-2: 延续上一关场景,第3行草皮已铺好,只铺第2/4行
backgroundImage: "IMAGE_BACKGROUND1UNSODDED"  # 使用未铺草皮背景
sodRowImage: "IMAGE_SOD3ROW"                  # 3行草地图片
showSoddingAnim: true                         # 播放铺草皮动画
soddingAnimDelay: 0.0                         # 开场动画完成后立即播放
preSoddedLanes: [3]                           # 预先渲染第3行草皮(初始化时直接显示)

# Story 11.4:铺草皮粒子特效配置
sodRollAnimation: true                        # 启用铺草皮动画
sodRollParticles: true                        # 启用土粒飞溅特效
soddingAnimLanes: [2, 4]                      # 只在第2/4行播放动画(第3行跳过)
```

**修改要点**:
1. ✅ 使用 `IMAGE_BACKGROUND1UNSODDED`(未铺草皮背景)
2. ✅ 新增 `preSoddedLanes: [3]` - 标记第3行需要预渲染
3. ✅ 新增 `soddingAnimLanes: [2, 4]` - 只在第2/4行播放动画

---

### 📝 Edit 2: 扩展 LevelConfig 支持预渲染草皮

**文件**: `pkg/config/level_config.go`

**添加字段** (after line 41):
```go
// Story 11.4:铺草皮粒子特效配置
SodRollAnimation bool   `yaml:"sodRollAnimation"` // 是否启用铺草皮动画,默认 false
SodRollParticles bool   `yaml:"sodRollParticles"` // 是否启用土粒飞溅特效,默认 false
SoddingAnimLanes []int  `yaml:"soddingAnimLanes"` // 指定播放动画的行列表(如 [2,4]),空表示所有启用的行
PreSoddedLanes   []int  `yaml:"preSoddedLanes"`   // 预先渲染草皮的行列表(如 [3]),初始化时直接显示草皮
```

**修改验证逻辑** (`validateLevelConfig` 函数,after line 150):
```go
// 验证 SoddingAnimLanes(如果配置了)
if len(config.SoddingAnimLanes) > 0 {
    for _, lane := range config.SoddingAnimLanes {
        if lane < 1 || lane > 5 {
            return fmt.Errorf("invalid sodding animation lane %d (must be 1-5)", lane)
        }
    }
}

// 验证 PreSoddedLanes(如果配置了)
if len(config.PreSoddedLanes) > 0 {
    for _, lane := range config.PreSoddedLanes {
        if lane < 1 || lane > 5 {
            return fmt.Errorf("invalid pre-sodded lane %d (must be 1-5)", lane)
        }
    }
}
```

---

### 📝 Edit 3: 扩展 SoddingSystem 支持部分行动画

**文件**: `pkg/systems/sodding_system.go`

**修改 `StartAnimation` 方法签名** (line 72):

**当前**:
```go
func (s *SoddingSystem) StartAnimation(onComplete func(), enabledLanes []int, sodOverlayX, sodImageHeight float64, enableParticles bool)
```

**修改后**:
```go
// StartAnimation 开始播放铺草皮动画
// 参数:
//   - onComplete: 动画完成时的回调函数
//   - enabledLanes: 启用的行列表(如 [2,3,4])
//   - animLanes: 播放动画的行列表(如 [2,4],空表示使用 enabledLanes)
//   - sodOverlayX: 草皮叠加图的世界X坐标(左边缘)
//   - sodImageHeight: 草皮图片的实际高度
//   - enableParticles: 是否启用土粒飞溅粒子特效
func (s *SoddingSystem) StartAnimation(onComplete func(), enabledLanes, animLanes []int, sodOverlayX, sodImageHeight float64, enableParticles bool) {
    if s.isAnimationPlaying {
        log.Printf("[SoddingSystem] Animation already playing, ignoring")
        return
    }

    // 如果未指定动画行,使用所有启用的行
    if len(animLanes) == 0 {
        animLanes = enabledLanes
    }

    log.Printf("[SoddingSystem] Starting SodRoll animation for lanes %v (enabled lanes: %v)", animLanes, enabledLanes)
    s.onAnimationComplete = onComplete
    s.isAnimationPlaying = true
    s.animationStarted = true
    s.animationTimer = 0

    // ... 后续代码使用 animLanes 替代 enabledLanes 创建草皮卷实体 ...
}
```

**实现要点**:
- 只为 `animLanes` 中的行创建草皮卷实体
- 其他行不创建动画(预渲染行由 Edit 8 处理)

---

### 📝 Edit 4: 更新 GameScene 调用 SoddingSystem

**文件**: `pkg/scenes/game_scene.go`

**修改位置 1** (line 852):
```go
// 当前代码
enabledLanes := s.gameState.CurrentLevel.EnabledLanes
enableParticles := s.gameState.CurrentLevel != nil && s.gameState.CurrentLevel.SodRollParticles
s.soddingSystem.StartAnimation(func() {
    // ...
}, enabledLanes, s.sodOverlayX, float64(s.sodHeight), enableParticles)
```

**修改后**:
```go
enabledLanes := s.gameState.CurrentLevel.EnabledLanes
animLanes := s.gameState.CurrentLevel.SoddingAnimLanes // 新增:读取动画行配置
enableParticles := s.gameState.CurrentLevel != nil && s.gameState.CurrentLevel.SodRollParticles
s.soddingSystem.StartAnimation(func() {
    log.Printf("[GameScene] 铺草皮动画完成")
    if s.tutorialSystem != nil {
        s.tutorialSystem.OnSoddingComplete()
    }
    // Story 10.2: 铺草皮完成后创建除草车(原版行为)
    s.initLawnmowers()
}, enabledLanes, animLanes, s.sodOverlayX, float64(s.sodHeight), enableParticles)
```

**修改位置 2** (line 888):
```go
// 同样的修改
enabledLanes := s.gameState.CurrentLevel.EnabledLanes
animLanes := s.gameState.CurrentLevel.SoddingAnimLanes
enableParticles := s.gameState.CurrentLevel != nil && s.gameState.CurrentLevel.SodRollParticles
s.soddingSystem.StartAnimation(func() {
    log.Printf("[GameScene] 铺草皮动画完成")
    if s.tutorialSystem != nil {
        s.tutorialSystem.OnSoddingComplete()
    }
    // Story 10.2: 铺草皮完成后创建除草车(原版行为)
    s.initLawnmowers()
}, enabledLanes, animLanes, s.sodOverlayX, float64(s.sodHeight), enableParticles)
```

---

### 📝 Edit 8: 在 GameScene 初始化时预渲染草皮

**文件**: `pkg/scenes/game_scene.go`

**修改位置**: `loadSoddingResources()` 方法末尾 (after line 800)

**添加代码**:
```go
// Story 8.6 QA修正: 预渲染指定行的草皮(用于关卡 1-2 第3行已铺好效果)
if len(s.gameState.CurrentLevel.PreSoddedLanes) > 0 && s.sodRowImage != nil {
    log.Printf("[GameScene] 预渲染草皮行: %v", s.gameState.CurrentLevel.PreSoddedLanes)

    // 创建预渲染草皮的实体(静态,不播放动画)
    for _, lane := range s.gameState.CurrentLevel.PreSoddedLanes {
        if lane < 1 || lane > 5 {
            log.Printf("[GameScene] Warning: 无效的预渲染草皮行 %d,跳过", lane)
            continue
        }

        // 计算该行草皮的Y坐标(使用与 SoddingSystem 相同的计算逻辑)
        laneY := config.GridWorldStartY + float64(lane-1)*config.GridCellHeight
        sodY := laneY - float64(s.sodHeight)/2.0 + config.GridCellHeight/2.0

        // 创建静态草皮实体(无动画)
        preSodEntity := s.entityManager.CreateEntity()
        ecs.AddComponent(s.entityManager, preSodEntity, &components.PositionComponent{
            X: s.sodOverlayX,
            Y: sodY,
        })
        ecs.AddComponent(s.entityManager, preSodEntity, &components.SpriteComponent{
            Image: s.sodRowImage,
        })
        ecs.AddComponent(s.entityManager, preSodEntity, &components.RenderLayerComponent{
            Layer: components.LayerGround, // 地面层,在草坪下方
        })

        log.Printf("[GameScene] 预渲染草皮: 行%d, 位置(%.0f, %.0f)", lane, s.sodOverlayX, sodY)
    }
}
```

**实现原理**:
1. 读取 `PreSoddedLanes` 配置(如 `[3]`)
2. 为每个预渲染行创建**静态草皮实体**(不是动画的草皮卷)
3. 使用 `SpriteComponent` 直接渲染完整草皮图片
4. 渲染层级设置为 `LayerGround`(地面层),确保在背景之上、植物之下

---

### 📝 Edit 9: 更新渲染逻辑处理预渲染草皮

**文件**: `pkg/scenes/game_scene.go`

**修改位置**: `Draw()` 方法的草皮渲染部分 (around line 1161-1174)

**当前逻辑**:
```go
// 根据草皮卷中心位置计算可见宽度(从动画起点到草皮卷中心)
var sodRollCenterX float64
var animStartX float64
if s.soddingSystem != nil {
    sodRollCenterX = s.soddingSystem.GetSodRollCenterX()
    animStartX = s.soddingSystem.GetAnimStartX()
} else {
    sodRollCenterX = sodOverlayX - 10
    animStartX = sodOverlayX
}
```

**修改后**:
```go
// Story 8.6 QA修正: 如果有预渲染草皮,跳过渐进显示逻辑
// 预渲染草皮由静态实体直接绘制,不需要在这里处理
if len(s.gameState.CurrentLevel.PreSoddedLanes) > 0 {
    // 预渲染草皮由实体系统绘制,跳过此处的渐进显示逻辑
    // 铺草皮动画只处理 soddingAnimLanes 中的行
} else {
    // 原有的渐进显示逻辑(用于关卡 1-1)
    var sodRollCenterX float64
    var animStartX float64
    if s.soddingSystem != nil {
        sodRollCenterX = s.soddingSystem.GetSodRollCenterX()
        animStartX = s.soddingSystem.GetAnimStartX()
    } else {
        sodRollCenterX = sodOverlayX - 10
        animStartX = sodOverlayX
    }

    // ... 原有的裁剪渲染逻辑 ...
}
```

**注意**: 这部分代码需要根据实际渲染逻辑调整,确保:
1. 预渲染草皮行(如第3行)由静态实体绘制,完整显示
2. 动画草皮行(如第2/4行)由 SoddingSystem 的草皮卷动画绘制

---

### 📝 Edit 5: 更新 Story 8.6 文档

**文件**: `docs/stories/8.6.story.md`

**添加 AC 1 详细说明** (after line 22):
```markdown
   - 草皮渲染行为(参考 chapter1.md):
     * 背景图: 使用 IMAGE_BACKGROUND1UNSODDED (完全未铺草皮背景)
     * 初始状态: 第3行草皮预渲染完整显示(由静态实体实现)
     * 铺草皮动画: 只在第2行和第4行同时播放动画(第3行跳过)
     * 技术实现: preSoddedLanes + soddingAnimLanes 配置字段
```

**添加 Dev Notes** (在 "Previous Story Insights" 后):
```markdown
### Critical Requirements from chapter1.md

**关卡 1-2 草皮渲染** (chapter1.md:89):
- 延续上一关场景: 第3行草皮初始就铺好
- 铺草皮动画: 只在第2/4行同时播放(与1-1的单行动画不同)
- 资源约束: 只有 IMAGE_BACKGROUND1UNSODDED 和 IMAGE_BACKGROUND1,无中间状态背景

**实现方案**:
1. 新增 LevelConfig 字段: `PreSoddedLanes []int` 和 `SoddingAnimLanes []int`
2. GameScene 初始化时预渲染 PreSoddedLanes 指定的行(静态实体)
3. SoddingSystem 只为 SoddingAnimLanes 指定的行播放动画
4. 渲染系统分离: 预渲染草皮由实体系统绘制,动画草皮由 SoddingSystem 绘制

**关键代码位置**:
- `level_config.go`: PreSoddedLanes/SoddingAnimLanes 字段定义
- `game_scene.go::loadSoddingResources()`: 预渲染草皮实体创建
- `sodding_system.go::StartAnimation()`: 部分行动画支持
```

---

### 📝 Edit 6: 铲子功能状态明确化

**文件**: `docs/stories/8.6.story.md`

**修改 Task 14 状态** (line 374):
```markdown
### Task 14: 实现铲子工具系统 (AC: 8)
- [ ] ⏭️ **已延后至后续 Story** - 原因: 需要完整的UI交互系统和ShovelComponent设计
- [ ] 当前状态: UnlockTools 配置字段已实现,数据会正确保存到存档
- [ ] 游戏内表现: 1-3 完成后存档会记录铲子解锁,但游戏内无铲子功能
- [ ] 后续计划: Epic 9 或 Epic 10 单独 Story 实现完整铲子系统
```

**在 Story 顶部添加警告** (after Story 标题):
```markdown
## ⚠️ 已知限制 (Known Limitations)

1. **铲子工具系统未实现** (Task 14 延后)
   - 关卡 1-3 配置了 `unlockTools: ["shovel"]`
   - 存档会正确记录解锁状态
   - 游戏内暂无铲子UI和功能
   - 计划在后续 Story 实现

2. **向日葵种植问题** (待调查)
   - 关卡 1-2 配置了 `availablePlants: ["sunflower"]`
   - 需要验证植物工厂和选择系统是否正确实现向日葵
   - 调试任务: `.ai/debug-tasks/sunflower-plant-issue.md`
```

---

### 📝 Edit 7: 向日葵问题调试任务

**文件**: 新建 `.ai/debug-tasks/sunflower-plant-issue.md`

```markdown
# Debug Task: 向日葵无法种植问题调查

## 问题描述
关卡 1-2 配置了 `availablePlants: ["peashooter", "sunflower"]`,但用户报告向日葵无法种植。

## 调试步骤

### 1. 验证卡片创建
- [ ] 运行游戏,进入关卡 1-2,启用 `--verbose` 日志
- [ ] 检查日志: `[PlantSelectionModule] Initialized with X plant cards`
- [ ] 预期: X >= 2 (豌豆射手 + 向日葵)

### 2. 验证 plantTypeMap
- [ ] 检查 `pkg/modules/plant_selection_module.go:120-138`
- [ ] 确认 `"sunflower": components.PlantSunflower` 存在

### 3. 验证向日葵工厂函数
- [ ] 检查 `pkg/entities/plant_factory.go` 是否有 `NewSunflowerEntity`
- [ ] 如果缺失,创建向日葵工厂函数

### 4. 验证 PlantCardEntity 创建
- [ ] 在 `plant_selection_module.go:171` 添加日志:
   ```go
   log.Printf("[Debug] Creating card for %s (type: %v)", plantName, plantType)
   ```
- [ ] 检查向日葵卡片是否成功创建

### 5. 验证解锁状态
- [ ] 检查 `PlantUnlockManager.IsUnlocked("sunflower")`
- [ ] 如果返回 false,检查是否有代码过滤未解锁植物

## 可能的解决方案

**方案 A**: 向日葵工厂函数缺失
- 创建 `pkg/entities/plant_factory.go::NewSunflowerEntity`
- 参考 `NewPeashooterEntity` 实现

**方案 B**: 卡片创建逻辑过滤了未解锁植物
- 检查 `plant_selection_module.go` 是否有解锁检查
- 移除检查或确保向日葵默认解锁

**方案 C**: ReanimSystem 缺少向日葵动画
- 检查向日葵 Reanim 资源是否正确加载
- 添加错误处理和日志

## 负责人
- Dev Agent (执行调试)
- User (提供测试反馈)
```

---

## 6. PRD MVP 影响分析 (PRD MVP Impact)

### ✅ MVP 范围无变化
- 核心功能(关卡 1-1 至 1-4)仍在 MVP 范围内
- 铲子功能延后不影响 MVP(1-4 可玩,只是缺少铲子工具)

### ⚠️ 质量风险
- 向日葵问题可能阻塞 1-2 关卡游玩
- 需要**优先**修复向日葵种植问题

---

## 7. 高层级行动计划 (High-Level Action Plan)

### Phase 1: 紧急修复 (1-2天)
1. **向日葵问题调试** (优先级: P0)
   - 执行 `.ai/debug-tasks/sunflower-plant-issue.md`
   - 修复根本原因
   - 验证 1-2 关卡可玩

2. **配置文件修正** (优先级: P1)
   - 修改 `level-1-2.yaml` 配置(Edit 1)
   - 使用 `IMAGE_BACKGROUND1UNSODDED` + 预渲染第3行方案

### Phase 2: 功能扩展 (3-5天)
3. **预渲染草皮系统** (优先级: P1)
   - 实现 Edit 2(LevelConfig 扩展)
   - 实现 Edit 8(GameScene 预渲染逻辑)
   - 实现 Edit 9(渲染逻辑调整)
   - 单元测试验证

4. **SoddingSystem 扩展** (优先级: P1)
   - 实现 Edit 3(SoddingSystem 部分行动画)
   - 实现 Edit 4(GameScene 调用更新)
   - 单元测试验证

5. **文档更新** (优先级: P2)
   - 实现 Edit 5, Edit 6, Edit 7
   - 更新 Story 8.6 文档

### Phase 3: 验收测试 (1天)
6. **集成测试** (优先级: P1)
   - 验证 1-2 关卡第3行草皮初始就完整显示
   - 验证第2/4行同时播放铺草皮动画
   - 验证 1-1 关卡不受影响(回归测试)

---

## 8. Agent 交接计划 (Agent Handoff Plan)

### 🔧 Dev Agent (开发代理)
**任务**:
1. 执行 Edit 1-9 所有代码修改
2. 运行调试任务 `sunflower-plant-issue.md`
3. 创建单元测试验证 SoddingSystem 部分行动画和预渲染功能

**交付物**:
- 修改后的配置文件和代码
- 调试报告(向日葵问题根本原因和修复)
- 测试通过的证明

### 📋 SM (Scrum Master)
**任务**:
1. 审核 Dev Agent 的修改
2. 更新 Story 8.6 文档
3. 组织验收测试

---

## 9. 成功标准 (Success Criteria)

### ✅ 必须满足
1. 关卡 1-2 可以正常游玩
2. 向日葵可以正常选择和种植
3. 铺草皮动画行为符合 chapter1.md 描述(第2/4行同时动画,第3行预渲染完整显示)

### 🎯 可选优化
1. 单元测试覆盖预渲染草皮功能
2. 性能优化(如有必要)

---

## 10. 风险评估 (Risk Assessment)

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 向日葵问题复杂 | 低 | 高 | 详细调试任务 + fallback方案(临时移除向日葵) |
| SoddingSystem改动引入回归 | 低 | 中 | 单元测试 + 1-1关卡回归测试 |
| 预渲染草皮渲染层级冲突 | 中 | 低 | 使用 LayerGround 层级,RenderSystem 测试验证 |

---

## 11. 技术方案总结

### 实现方式

```
关卡 1-1 (教学关):
背景: IMAGE_BACKGROUND1UNSODDED (完全未铺)
启用行: [3]
动画行: [] (空,使用启用行)
预渲染: []
结果: 第3行播放完整铺草皮动画

关卡 1-2 (延续场景):
背景: IMAGE_BACKGROUND1UNSODDED (完全未铺)
启用行: [2, 3, 4]
动画行: [2, 4]  ← 只在第2/4行播放动画
预渲染: [3]     ← 第3行初始就完整显示
结果: 第3行已铺好(静态实体),第2/4行同时播放动画
```

### 核心改动

1. **配置层**: LevelConfig 新增 `PreSoddedLanes` 和 `SoddingAnimLanes` 字段
2. **初始化**: GameScene 在 `loadSoddingResources()` 创建预渲染草皮实体
3. **动画系统**: SoddingSystem 只为 `SoddingAnimLanes` 指定的行创建动画
4. **渲染系统**: 分离预渲染草皮(实体系统)和动画草皮(SoddingSystem)的渲染

---

## 12. 最终审批检查清单 (Final Review Checklist)

- [x] 用户确认资源约束(无 IMAGE_BACKGROUND1_SODROW3)
- [ ] 用户确认向日葵问题优先级
- [ ] 用户确认铲子功能延后可接受
- [ ] 用户批准 Sprint Change Proposal
- [ ] Dev Agent 开始执行修改

---

**提案状态**: 🟡 等待用户审批
**预计完成时间**: 3-7 工作日(取决于向日葵问题复杂度)
**下一步**: 用户审批后,移交 Dev Agent 执行

---

**变更历史**:
- 2025-10-28: 初始版本创建
- 2025-10-28: 更新 Edit 1(确认资源约束),新增 Edit 8/9(预渲染草皮实现)
