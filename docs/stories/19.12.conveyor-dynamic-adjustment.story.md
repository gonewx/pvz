# Story 19.12: 传送带动态调节系统

## Status

Ready for Review

## Story

**As a** 玩家,
**I want** 传送带根据关卡进度动态调整坚果生成频率和爆炸坚果比例,
**so that** 前期熟悉操作、中期紧张刺激、终盘资源爆发，获得更有节奏感的游戏体验。

## Acceptance Criteria

1. **三阶段动态权重调整**
   - 前期（0%-30%）：爆炸坚果权重 10%
   - 中期（30%-70%）：爆炸坚果权重 20%
   - 终盘（70%-100%）：爆炸坚果权重 30%

2. **三阶段刷新间隔调整**
   - 前期（0%-30%）：生成间隔 3.0-3.5 秒
   - 中期（30%-70%）：生成间隔 2.2-2.5 秒
   - 终盘（70%-100%）：生成间隔 1.5-1.8 秒

3. **空带补发保底**
   - 传送带连续 3 秒为空时，立即触发一次额外生成
   - 必出普通坚果，用于补充资源

4. **满带降频调节**
   - 传送带连续 8 秒处于满状态时，刷新间隔提高 50%
   - 直到带上格子低于满容量 2 格时恢复正常频率

5. **危机爆炸坚果保底**
   - 检测到同一行有 2+ 僵尸距离安全线 ≤ `CrisisDistanceThreshold` 时
   - 如果过去 `CrisisExplodeNutCooldown` 秒内未生成爆炸坚果，强制下次生成爆炸坚果
   - 所有阈值通过配置常量定义，不硬编码像素值

6. **参数配置化**
   - 所有间隔、权重、保底规则通过 YAML 配置驱动
   - 支持后续在高难度模式中微调

7. **单元测试**: 覆盖率 ≥ 80%

## Tasks / Subtasks

### Task 1: 扩展传送带组件字段 (AC: 3, 4, 5)

- [x] 修改 `pkg/components/conveyor_belt_component.go`
  - [x] 添加 `EmptyDuration float64` - 传送带为空的持续时间
  - [x] 添加 `FullDuration float64` - 传送带满载的持续时间
  - [x] 添加 `LastExplodeNutTime float64` - 上次生成爆炸坚果的时间
  - [x] 添加 `IsThrottled bool` - 是否处于降频状态
  - [x] 添加 `ForceExplodeNut bool` - 是否强制下次生成爆炸坚果

### Task 2: 实现关卡进度百分比计算 (AC: 1, 2)

- [x] 修改 `pkg/systems/conveyor_belt_system.go`
  - [x] 添加 `gameState *game.GameState` 依赖
  - [x] 实现 `getLevelProgress() float64` 方法
    - [x] 使用 `gameState.GetLevelProgress()` 获取当前波次和总波次
    - [x] 计算进度百分比 `progress = currentWave / totalWaves`（0-based）
    - [x] 边界处理：`totalWaves == 0` 时返回 0.0
  - [x] 实现 `getCurrentPhase(progress float64) int` 方法
    - [x] 0.0 ≤ progress < 0.3 返回 1（前期）
    - [x] 0.3 ≤ progress < 0.7 返回 2（中期）
    - [x] 0.7 ≤ progress ≤ 1.0 返回 3（终盘）
    - [x] 简化波次支持：当 `totalWaves ≤ 2` 时，直接使用阶段 2（中期）配置

### Task 3: 实现动态权重调整 (AC: 1)

- [x] 修改 `pkg/systems/conveyor_belt_system.go`
  - [x] 实现 `getPhaseCardPool(phase int) []CardPoolEntry` 方法
    - [x] 前期：普通 90%、爆炸 10%
    - [x] 中期：普通 80%、爆炸 20%
    - [x] 终盘：普通 70%、爆炸 30%
  - [x] 修改 `generateCard()` 使用当前阶段的卡片池

### Task 4: 实现动态刷新间隔 (AC: 2)

- [x] 修改 `pkg/systems/conveyor_belt_system.go`
  - [x] 实现 `getPhaseGenerationInterval(phase int) float64` 方法
    - [x] 前期：3.0-3.5 秒（随机）
    - [x] 中期：2.2-2.5 秒（随机）
    - [x] 终盘：1.5-1.8 秒（随机）
  - [x] 修改 `updateCardGeneration()` 使用动态间隔

### Task 5: 实现空带补发保底 (AC: 3)

- [x] 修改 `pkg/systems/conveyor_belt_system.go`
  - [x] 在 `Update()` 中追踪 `EmptyDuration`
    - [x] 传送带为空时累加计时
    - [x] 不为空时重置为 0
  - [x] 实现 `checkEmptyBeltEmergency()` 方法
    - [x] `EmptyDuration >= 3.0` 时触发紧急生成
    - [x] 强制生成普通坚果
    - [x] 重置 `EmptyDuration`

### Task 6: 实现满带降频调节 (AC: 4)

- [x] 修改 `pkg/systems/conveyor_belt_system.go`
  - [x] 在 `Update()` 中追踪 `FullDuration`
    - [x] 传送带满载时累加计时
    - [x] 不满载时重置为 0
  - [x] 实现 `checkFullBeltThrottle()` 方法
    - [x] `FullDuration >= 8.0` 时进入降频状态
    - [x] 刷新间隔 × 1.5
    - [x] 当容量 < (Capacity - 2) 时退出降频状态

### Task 7: 实现危机爆炸坚果保底 (AC: 5)

- [x] 修改 `pkg/systems/conveyor_belt_system.go`
  - [x] 实现 `checkCrisisExplodeNut()` 方法
    - [x] 查询所有僵尸实体的位置
    - [x] 使用 `config.CrisisDistanceThreshold` 检测危机距离（不硬编码像素值）
    - [x] 使用 `config.CrisisZombieCount` 定义危机僵尸数量阈值
    - [x] 检查 `LastExplodeNutTime` 是否超过 `CrisisExplodeNutCooldown`
    - [x] 设置 `ForceExplodeNut = true`
  - [x] 修改 `generateCard()` 检查 `ForceExplodeNut`
    - [x] 为 true 时强制返回爆炸坚果
    - [x] 生成后重置 `ForceExplodeNut` 和 `LastExplodeNutTime`

### Task 8: 扩展关卡配置 (AC: 6)

- [x] 修改 `pkg/config/level_config.go`
  - [x] 扩展 `ConveyorBeltConfig` 结构体
    - [x] `PhaseConfigs []PhaseConfig` - 各阶段配置
  - [x] 添加 `PhaseConfig` 结构体
    - [x] `ProgressThreshold float64` - 进度阈值
    - [x] `ExplodeNutWeight int` - 爆炸坚果权重
    - [x] `IntervalMin float64` - 最小生成间隔
    - [x] `IntervalMax float64` - 最大生成间隔
  - [x] 添加 `DynamicAdjustmentConfig` 结构体
    - [x] `EmptyBeltThreshold float64` - 空带保底阈值（秒）
    - [x] `FullBeltThreshold float64` - 满带降频阈值（秒）
    - [x] `FullBeltThrottleMultiplier float64` - 降频倍率
    - [x] `CrisisExplodeNutCooldown float64` - 危机爆炸坚果冷却（秒）
    - [x] `CrisisZombieCount int` - 危机检测僵尸数量
    - [x] `CrisisDistanceThreshold float64` - 危机检测距离阈值

- [x] 更新 `data/levels/level-1-5.yaml`
  - [x] 添加三阶段配置
  - [x] 添加动态调节参数

### Task 9: 单元测试 (AC: 7)

- [x] 创建/更新 `pkg/systems/conveyor_belt_system_test.go`
  - [x] `TestConveyorBeltSystem_PhaseDetection` - 阶段检测测试
  - [x] `TestConveyorBeltSystem_DynamicWeight` - 动态权重测试
  - [x] `TestConveyorBeltSystem_DynamicInterval` - 动态间隔测试
  - [x] `TestConveyorBeltSystem_EmptyBeltEmergency` - 空带补发测试
  - [x] `TestConveyorBeltSystem_FullBeltThrottle` - 满带降频测试
  - [x] `TestConveyorBeltSystem_CrisisExplodeNut` - 危机保底测试
  - [x] 确保覆盖率 ≥ 80%

## Dev Notes

### 架构上下文

本 Story 是 Story 19.5（传送带系统）的增强，实现 `.meta/levels/level1-5.md` 中定义的"坚果数量和出现频率"动态调节逻辑。

**前置依赖**：
- **Story 19.5**: 传送带系统基础实现（已完成）
- **Story 19.9**: 僵尸波次配置与进度系统（已完成）

**后续无依赖**：本 Story 为独立增强功能。

[Source: .meta/levels/level1-5.md#坚果数量和出现频率]

### 关卡进度计算

**进度百分比公式**（0-based）：
```go
func (s *ConveyorBeltSystem) getLevelProgress() float64 {
    currentWave, totalWaves := s.gameState.GetLevelProgress()
    if totalWaves == 0 {
        return 0.0
    }
    return float64(currentWave) / float64(totalWaves)
}

func (s *ConveyorBeltSystem) getCurrentPhase() int {
    _, totalWaves := s.gameState.GetLevelProgress()

    // 简化波次支持：当波次过少时使用中期配置
    if totalWaves <= 2 {
        return 2 // 中期
    }

    progress := s.getLevelProgress()
    switch {
    case progress < 0.3:
        return 1 // 前期
    case progress < 0.7:
        return 2 // 中期
    default:
        return 3 // 终盘
    }
}
```

**阶段划分**：
| 阶段 | 进度范围 | 爆炸坚果权重 | 生成间隔 |
|------|----------|-------------|----------|
| 前期 | 0% - 30% | 10% | 3.0-3.5s |
| 中期 | 30% - 70% | 20% | 2.2-2.5s |
| 终盘 | 70% - 100% | 30% | 1.5-1.8s |

[Source: .meta/levels/level1-5.md#三阶段数量与频率设计]

### 空带补发保底逻辑

```go
func (s *ConveyorBeltSystem) checkEmptyBeltEmergency(dt float64, beltComp *components.ConveyorBeltComponent) {
    if beltComp.IsEmpty() {
        beltComp.EmptyDuration += dt
        if beltComp.EmptyDuration >= 3.0 {
            // 紧急补发普通坚果
            s.addCard(beltComp, components.CardTypeWallnutBowling)
            beltComp.EmptyDuration = 0
            log.Printf("[ConveyorBeltSystem] Emergency: Belt empty for 3s, spawned wallnut")
        }
    } else {
        beltComp.EmptyDuration = 0
    }
}
```

[Source: .meta/levels/level1-5.md#动态调节与极端情况处理]

### 满带降频调节逻辑

```go
func (s *ConveyorBeltSystem) checkFullBeltThrottle(dt float64, beltComp *components.ConveyorBeltComponent) {
    if beltComp.IsFull() {
        beltComp.FullDuration += dt
        if beltComp.FullDuration >= 8.0 && !beltComp.IsThrottled {
            beltComp.IsThrottled = true
            log.Printf("[ConveyorBeltSystem] Throttle: Belt full for 8s, reducing spawn rate")
        }
    } else {
        beltComp.FullDuration = 0
        // 低于满容量 2 格时解除降频
        if beltComp.CardCount() <= beltComp.Capacity-2 {
            beltComp.IsThrottled = false
        }
    }
}
```

[Source: .meta/levels/level1-5.md#动态调节与极端情况处理]

### 危机爆炸坚果保底逻辑

```go
func (s *ConveyorBeltSystem) checkCrisisExplodeNut(levelTime float64, beltComp *components.ConveyorBeltComponent, dynamicCfg *config.DynamicAdjustmentConfig) {
    // 检查是否需要强制生成爆炸坚果
    if beltComp.ForceExplodeNut {
        return // 已经标记，等待生成
    }

    // 检查上次生成爆炸坚果是否超过冷却时间
    if levelTime - beltComp.LastExplodeNutTime < dynamicCfg.CrisisExplodeNutCooldown {
        return
    }

    // 查询所有僵尸，检测危机状态
    // 危机条件：同一行有 N+ 僵尸距离安全线 ≤ 阈值
    zombies := ecs.GetEntitiesWith2[*components.ZombieComponent, *components.PositionComponent](s.entityManager)

    // 安全线位置（家门口）
    safeLineX := config.GridWorldStartX

    // 按行统计接近安全线的僵尸数量
    laneCounts := make(map[int]int)
    for _, zombieEntity := range zombies {
        posComp, _ := ecs.GetComponent[*components.PositionComponent](s.entityManager, zombieEntity)
        // 使用配置常量定义危机距离阈值
        if posComp.X <= safeLineX + dynamicCfg.CrisisDistanceThreshold {
            row := int(posComp.Y / config.CellHeight)
            laneCounts[row]++
        }
    }

    // 检查是否有行存在危机（使用配置常量定义僵尸数量阈值）
    for _, count := range laneCounts {
        if count >= dynamicCfg.CrisisZombieCount {
            beltComp.ForceExplodeNut = true
            log.Printf("[ConveyorBeltSystem] Crisis detected: forcing explode-o-nut spawn")
            break
        }
    }
}
```

[Source: .meta/levels/level1-5.md#动态调节与极端情况处理]

### 配置示例

```yaml
# data/levels/level-1-5.yaml
conveyorBelt:
  enabled: true
  capacity: 10
  phaseConfigs:
    - progressThreshold: 0.0   # 前期 (0%-30%)
      explodeNutWeight: 10
      intervalMin: 3.0
      intervalMax: 3.5
    - progressThreshold: 0.3   # 中期 (30%-70%)
      explodeNutWeight: 20
      intervalMin: 2.2
      intervalMax: 2.5
    - progressThreshold: 0.7   # 终盘 (70%-100%)
      explodeNutWeight: 30
      intervalMin: 1.5
      intervalMax: 1.8
  dynamicAdjustment:
    emptyBeltThreshold: 3.0        # 空带保底阈值（秒）
    fullBeltThreshold: 8.0         # 满带降频阈值（秒）
    fullBeltThrottleMultiplier: 1.5  # 降频倍率
    crisisExplodeNutCooldown: 5.0  # 危机爆炸坚果冷却（秒）
    crisisZombieCount: 2           # 危机检测僵尸数量
    crisisDistanceThreshold: 300   # 危机检测距离阈值（像素）
```

[Source: .meta/levels/level1-5.md#开发实现要点]

### 零耦合原则遵循

**系统间通信方式**：

1. **组件查询**：
   - 查询 `ZombieComponent` + `PositionComponent` 检测危机状态
   - 通过 `ConveyorBeltComponent` 管理所有调节状态

2. **GameState 依赖**：
   - 通过 `gameState.GetLevelProgress()` 获取关卡进度
   - 通过 `gameState.LevelTime` 获取关卡时间

**禁止**：
- 直接调用 `WaveSpawnSystem` 或 `ZombieSystem` 方法
- 使用全局变量共享状态

[Source: docs/architecture/coding-standards.md#零耦合原则]

### 文件位置规范

| 文件 | 位置 |
|------|------|
| ConveyorBeltComponent 扩展 | `pkg/components/conveyor_belt_component.go` |
| ConveyorBeltSystem 扩展 | `pkg/systems/conveyor_belt_system.go` |
| 配置结构扩展 | `pkg/config/level_config.go` |
| 关卡配置 | `data/levels/level-1-5.yaml` |
| 测试文件 | `pkg/systems/conveyor_belt_system_test.go` |

[Source: docs/architecture/source-tree.md]

## Testing

### 测试文件位置

- `pkg/systems/conveyor_belt_system_test.go`

### 关键测试场景

**1. 阶段检测测试**:
```go
func TestConveyorBeltSystem_PhaseDetection(t *testing.T) {
    tests := []struct {
        progress float64
        phase    int
    }{
        {0.0, 1},   // 前期
        {0.15, 1},  // 前期
        {0.3, 2},   // 中期开始
        {0.5, 2},   // 中期
        {0.7, 3},   // 终盘开始
        {1.0, 3},   // 终盘
    }

    for _, tt := range tests {
        phase := system.getCurrentPhase(tt.progress)
        assert.Equal(t, tt.phase, phase)
    }
}
```

**2. 动态权重测试**:
```go
func TestConveyorBeltSystem_DynamicWeight(t *testing.T) {
    // 前期：爆炸坚果约 10%
    setProgress(0.1)
    explodeCount := countExplodeNuts(1000)
    assert.InDelta(t, 0.10, float64(explodeCount)/1000, 0.03)

    // 终盘：爆炸坚果约 30%
    setProgress(0.8)
    explodeCount = countExplodeNuts(1000)
    assert.InDelta(t, 0.30, float64(explodeCount)/1000, 0.05)
}
```

**3. 空带补发测试**:
```go
func TestConveyorBeltSystem_EmptyBeltEmergency(t *testing.T) {
    // 清空传送带
    clearBelt()
    assert.True(t, beltComp.IsEmpty())

    // 模拟 3 秒空带
    for i := 0; i < 300; i++ {
        system.Update(0.01)
    }

    // 应该自动生成一个普通坚果
    assert.Equal(t, 1, beltComp.CardCount())
    assert.Equal(t, components.CardTypeWallnutBowling, beltComp.Cards[0].CardType)
}
```

**4. 满带降频测试**:
```go
func TestConveyorBeltSystem_FullBeltThrottle(t *testing.T) {
    // 填满传送带
    fillBelt(10)
    assert.True(t, beltComp.IsFull())

    // 模拟 8 秒满带
    for i := 0; i < 800; i++ {
        system.Update(0.01)
    }

    // 应该进入降频状态
    assert.True(t, beltComp.IsThrottled)
}
```

**5. 危机保底测试**:
```go
func TestConveyorBeltSystem_CrisisExplodeNut(t *testing.T) {
    // 在同一行放置 2 个接近安全线的僵尸
    createZombie(row: 2, x: 200)
    createZombie(row: 2, x: 250)

    // 设置上次生成爆炸坚果超过 5 秒
    beltComp.LastExplodeNutTime = 0

    // 检测危机
    system.checkCrisisExplodeNut(10.0, beltComp)

    // 应该标记强制生成爆炸坚果
    assert.True(t, beltComp.ForceExplodeNut)
}
```

### 测试命令

```bash
# 运行传送带系统测试
go test ./pkg/systems -v -run TestConveyorBeltSystem

# 查看覆盖率
go test ./pkg/systems -cover -run TestConveyorBeltSystem

# 运行特定测试
go test ./pkg/systems -v -run TestConveyorBeltSystem_DynamicWeight
```

## File List

| 文件 | 操作 | 说明 |
|------|------|------|
| `pkg/components/conveyor_belt_component.go` | 修改 | 添加 5 个动态调节字段 |
| `pkg/systems/conveyor_belt_system.go` | 修改 | 实现动态调节系统方法 |
| `pkg/config/level_config.go` | 修改 | 添加 PhaseConfig 和 DynamicAdjustmentConfig 结构体 |
| `data/levels/level-1-5.yaml` | 修改 | 添加三阶段配置和动态调节参数 |
| `pkg/systems/conveyor_belt_system_test.go` | 修改 | 添加 8 个动态调节测试 |
| `pkg/systems/bowling_integration_test.go` | 修改 | 修复 generateCard() 调用签名 |
| `pkg/scenes/game_scene.go` | 修改 | 在关卡加载时调用 SetDynamicConfig |

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-05 | 0.1 | Initial story creation based on spec gap analysis | Bob (Scrum Master Agent) |
| 2025-12-05 | 0.2 | PO review: 1) AC5 使用配置常量替代硬编码像素值 2) Task2 添加简化波次边界处理 3) Dev Notes 代码示例更新 4) Status: Approved | Sarah (PO Agent) |
| 2025-12-05 | 0.3 | Implementation complete: All 9 tasks done, 8 new tests added, coverage ≥80% for core methods | James (Developer) |

---

## Spec Reference

本故事基于 `.meta/levels/level1-5.md` 中 "坚果数量和出现频率" 章节（第 229-308 行）的规范实现。

关键规范引用：
- 三阶段数量与频率设计（第 254-293 行）
- 动态调节与极端情况处理（第 294-300 行）
- 开发实现要点（第 303-308 行）
