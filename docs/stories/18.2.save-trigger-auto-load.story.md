# Story 18.2: 保存触发与自动加载

## Status

Ready

## Story

**As a** 玩家,
**I want** the game to automatically save my battle progress when I return to main menu,
**so that** I don't lose my progress when exiting the game.

## Acceptance Criteria

1. **暂停菜单"主菜单"按钮触发保存**
   - 修改 `PauseMenuModule` 的 `onMainMenu` 回调
   - 点击"主菜单"按钮时调用 `BattleSerializer.SaveBattle()`
   - 保存成功后才返回主菜单
   - 保存失败时显示错误提示（可选：日志记录）

2. **冒险模式入口检测存档**
   - 修改 `MainMenuScene.onStartAdventureClicked()` 方法
   - 检查 `SaveManager.HasBattleSave(username)`
   - 有存档时：触发继续游戏对话框（Story 18.3 实现）
   - 无存档时：正常进入关卡选择/开始关卡

3. **存档信息读取**
   - 实现快速读取存档元信息（不加载全部数据）
   - 用于对话框显示：关卡名称、保存时间

4. **日志输出**
   - 保存操作记录日志
   - 加载检测记录日志
   - 支持 `--verbose` 模式显示详细信息

5. **单元测试**: 覆盖率 ≥ 80%

## Tasks / Subtasks

### Task 1: 修改 PauseMenuModule 触发保存 (AC: 1)

- [ ] 修改 `pkg/modules/pause_menu_module.go`
- [ ] 在 `NewPauseMenuModule()` 中添加 `battleSerializer` 依赖
- [ ] 修改"主菜单"按钮的 `OnClick` 回调
  ```go
  OnClick: func() {
      log.Printf("[PauseMenuModule] Main menu button clicked, saving battle...")

      // 保存战斗进度
      if err := m.saveBattleProgress(); err != nil {
          log.Printf("[PauseMenuModule] Warning: Failed to save battle: %v", err)
          // 继续返回主菜单（保存失败不阻塞）
      }

      m.Hide()
      if m.onMainMenu != nil {
          m.onMainMenu()
      }
  }
  ```
- [ ] 实现 `saveBattleProgress() error` 方法
  - [ ] 获取当前 EntityManager
  - [ ] 获取当前 GameState
  - [ ] 获取当前用户名
  - [ ] 调用 `BattleSerializer.SaveBattle()`
- [ ] 添加 GoDoc 注释

### Task 2: 扩展 PauseMenuCallbacks (AC: 1)

- [ ] 修改 `PauseMenuCallbacks` 结构体
  ```go
  type PauseMenuCallbacks struct {
      OnContinue       func()
      OnRestart        func()
      OnMainMenu       func()
      OnPauseMusic     func()
      OnResumeMusic    func()
      // 新增
      GetEntityManager func() *ecs.EntityManager
      GetGameState     func() *game.GameState
      GetUsername      func() string
  }
  ```
- [ ] 在 `GameScene` 中提供回调实现

### Task 3: 修改 GameScene 传递回调 (AC: 1)

- [ ] 修改 `pkg/scenes/game_scene.go`
- [ ] 在创建 `PauseMenuModule` 时传递新的回调
  ```go
  callbacks := PauseMenuCallbacks{
      // 现有回调...
      GetEntityManager: func() *ecs.EntityManager {
          return gs.entityManager
      },
      GetGameState: func() *game.GameState {
          return game.GetGameState()
      },
      GetUsername: func() string {
          return game.GetGameState().GetSaveManager().GetCurrentUser()
      },
  }
  ```

### Task 4: 修改 MainMenuScene 检测存档 (AC: 2, 3)

- [ ] 修改 `pkg/scenes/main_menu_scene.go`
- [ ] 修改 `onStartAdventureClicked()` 方法
  ```go
  func (s *MainMenuScene) onStartAdventureClicked() {
      log.Printf("[MainMenuScene] Start adventure clicked")

      // 获取当前用户名
      username := s.saveManager.GetCurrentUser()

      // 检查是否有战斗存档
      if s.saveManager.HasBattleSave(username) {
          log.Printf("[MainMenuScene] Found battle save for user: %s", username)

          // 获取存档信息
          info, err := s.saveManager.GetBattleSaveInfo(username)
          if err != nil {
              log.Printf("[MainMenuScene] Warning: Failed to get save info: %v", err)
              // 存档损坏，删除并正常开始
              s.saveManager.DeleteBattleSave(username)
              s.startNormalAdventure()
              return
          }

          // 显示继续游戏对话框（Story 18.3 实现）
          s.showContinueGameDialog(info)
          return
      }

      // 无存档，正常开始
      s.startNormalAdventure()
  }
  ```
- [ ] 添加 `showContinueGameDialog(info *BattleSaveInfo)` 方法占位
  ```go
  func (s *MainMenuScene) showContinueGameDialog(info *game.BattleSaveInfo) {
      // Story 18.3 实现
      log.Printf("[MainMenuScene] TODO: Show continue game dialog for level %s", info.LevelID)
      // 临时：直接开始游戏
      s.startNormalAdventure()
  }
  ```
- [ ] 添加 `startNormalAdventure()` 方法
  ```go
  func (s *MainMenuScene) startNormalAdventure() {
      // 现有的开始冒险逻辑
  }
  ```

### Task 5: 日志增强 (AC: 4)

- [ ] 在 `BattleSerializer.SaveBattle()` 中添加日志
  ```go
  log.Printf("[BattleSerializer] Saving battle to %s (Level: %s, Sun: %d, Wave: %d)",
      filePath, data.LevelID, data.Sun, data.CurrentWaveIndex)
  log.Printf("[BattleSerializer] Entities: %d plants, %d zombies, %d projectiles, %d suns",
      len(data.Plants), len(data.Zombies), len(data.Projectiles), len(data.Suns))
  ```
- [ ] 在 `SaveManager.HasBattleSave()` 中添加日志
- [ ] 在 `SaveManager.GetBattleSaveInfo()` 中添加日志

### Task 6: 单元测试 (AC: 5)

- [ ] 创建 `pkg/modules/pause_menu_module_save_test.go`
  - [ ] 测试 `saveBattleProgress()` 正常保存
  - [ ] 测试保存失败时不阻塞返回主菜单
- [ ] 扩展 `pkg/scenes/main_menu_scene_test.go`
  - [ ] 测试有存档时的检测逻辑
  - [ ] 测试无存档时的正常流程
  - [ ] 测试存档损坏时的处理
- [ ] 确保覆盖率 ≥ 80%

## Dev Notes

### 架构上下文

本 Story 连接了 Story 18.1（序列化系统）和 Story 18.3（对话框与恢复），负责：
1. 在正确的时机触发保存（暂停菜单 → 主菜单）
2. 在正确的时机检测存档（主菜单 → 冒险模式）

**系统交互流程**:
```
玩家按 ESC
    ↓
PauseMenuModule.Show()
    ↓
玩家点击"主菜单"按钮
    ↓
PauseMenuModule.saveBattleProgress()
    ↓ 调用
BattleSerializer.SaveBattle()
    ↓ 保存到
data/saves/{username}_battle.sav
    ↓
PauseMenuModule.onMainMenu()
    ↓
SceneManager.SwitchTo(MainMenuScene)
```

```
玩家点击"冒险模式"按钮
    ↓
MainMenuScene.onStartAdventureClicked()
    ↓ 检查
SaveManager.HasBattleSave()
    ↓ 有存档
MainMenuScene.showContinueGameDialog()
    ↓
(Story 18.3 继续)
```

### 关键设计决策

**1. 保存失败时的处理策略**:
- 保存失败不应阻塞玩家返回主菜单
- 记录错误日志供调试
- 玩家下次进入时无存档可用（可接受的降级）

**2. 存档检测位置**:
- 在 `onStartAdventureClicked()` 中检测（而非 `onAdventureClicked()`）
- 确保检测发生在玩家明确要开始游戏时

**3. 回调函数设计**:
- 使用回调函数而非直接依赖，保持模块解耦
- `GetEntityManager`, `GetGameState`, `GetUsername` 作为回调

### 现有代码参考

**PauseMenuModule** (`pkg/modules/pause_menu_module.go:217-229`):
```go
// 3. 创建"主菜单"按钮
mainMenuEntity, err := m.createThreeSliceButton(rm, hiddenX, hiddenY, "主菜单", func() {
    log.Printf("[PauseMenuModule] Main menu button clicked!")
    m.Hide()
    if m.onMainMenu != nil {
        m.onMainMenu()
    }
})
```

**MainMenuScene 冒险模式按钮** (`pkg/scenes/main_menu_scene.go`):
- 查找 `onStartAdventureClicked` 或 `onAdventureClicked` 方法

### ECS 架构约束

1. **模块不直接访问 Scene**：通过回调函数获取所需数据
2. **保持单向依赖**：Scene → Module → Serializer

## Testing

### 测试文件位置

- `pkg/modules/pause_menu_module_save_test.go` (新增)
- `pkg/scenes/main_menu_scene_test.go` (扩展)

### 关键测试场景

**1. 保存触发测试**:
```go
func TestPauseMenuModule_SaveOnMainMenuClick(t *testing.T) {
    // 创建模拟环境
    em := ecs.NewEntityManager()
    gs := &game.GameState{Sun: 100}
    tmpDir := t.TempDir()

    // 创建模块
    module := createTestPauseMenuModule(em, gs, tmpDir)

    // 模拟点击主菜单按钮
    module.clickMainMenuButton()

    // 验证存档文件已创建
    savePath := filepath.Join(tmpDir, "testuser_battle.sav")
    assert.FileExists(t, savePath)
}
```

**2. 存档检测测试**:
```go
func TestMainMenuScene_DetectsBattleSave(t *testing.T) {
    tmpDir := t.TempDir()
    sm := createTestSaveManager(tmpDir)

    // 创建测试存档
    createTestBattleSave(sm, "testuser", "1-2")

    // 检测
    hasSave := sm.HasBattleSave("testuser")
    assert.True(t, hasSave)

    // 获取信息
    info, err := sm.GetBattleSaveInfo("testuser")
    assert.NoError(t, err)
    assert.Equal(t, "1-2", info.LevelID)
}
```

**3. 存档损坏处理测试**:
```go
func TestMainMenuScene_HandlesCorruptedSave(t *testing.T) {
    tmpDir := t.TempDir()
    sm := createTestSaveManager(tmpDir)

    // 创建损坏的存档
    savePath := sm.GetBattleSavePath("testuser")
    os.WriteFile(savePath, []byte("corrupted"), 0644)

    // 存档存在
    assert.True(t, sm.HasBattleSave("testuser"))

    // 但信息读取失败
    _, err := sm.GetBattleSaveInfo("testuser")
    assert.Error(t, err)
}
```

### 测试命令

```bash
# 运行 modules 包测试
go test ./pkg/modules -v -run TestPauseMenu

# 运行 scenes 包测试
go test ./pkg/scenes -v -run TestMainMenu

# 查看覆盖率
go test ./pkg/modules ./pkg/scenes -cover
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-29 | 0.1 | Initial story creation | John (PM Agent) |
