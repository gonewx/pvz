# Story 13.5: 配置系统升级 (Configuration System Enhancement)

## Status
Draft

---

## Story

**As a** 游戏开发者（Reanim 动画配置者）,
**I want** 通过 YAML 配置动画组合和轨道绑定,
**so that** 无需修改代码即可定义复杂动画组合，提升开发效率，降低维护成本。

---

## Story Context

### Problem Description

**当前问题**：动画配置硬编码在代码中，难以修改和维护

当前系统的动画组合配置分散在多个地方，主要是实体工厂代码中：

```go
// ❌ 当前实现（pkg/entities/plant_factory.go）
func CreatePeashooter(em *ecs.EntityManager, gridX, gridY int) ecs.EntityID {
    // ... 创建实体 ...

    // 硬编码的动画配置
    reanimComp := &components.ReanimComponent{
        ParentTracks: map[string]string{
            "anim_face": "anim_stem", // 父子关系硬编码
        },
    }

    // 硬编码的动画播放
    reanimSystem.PlayAnimations(entityID, []string{"anim_shooting", "anim_head_idle"})

    // 硬编码的轨道绑定（如果需要手动配置）
    reanimSystem.SetTrackBindings(entityID, map[string]string{
        "anim_face": "anim_head_idle",
        "stalk_bottom": "anim_shooting",
    })

    return entityID
}
```

**问题分析**：

| 问题 | 当前状态 | 影响 |
|------|---------|------|
| 配置分散 | 动画组合、轨道绑定、父子关系分散在代码各处 | 难以统一管理和查找 |
| 修改困难 | 修改动画配置需要改代码、重新编译 | 开发效率低，测试成本高 |
| 缺乏文档 | 没有统一的配置文档，依赖代码注释 | 新手难以理解配置规则 |
| 调试不便 | 无法快速尝试不同的动画组合 | 美术调整困难 |
| 无版本控制 | 配置嵌入代码，难以追踪配置历史 | 难以回滚配置变更 |

**具体痛点**：

1. **美术调整动画需要程序员介入**：
   - 美术想调整豌豆射手攻击时头部的摆动幅度
   - 需要程序员修改代码、重新编译
   - 反馈周期长，效率低

2. **添加新植物配置繁琐**：
   - 每个新植物都需要在代码中配置动画组合
   - 复制粘贴代码，容易出错
   - 配置逻辑重复

3. **配置难以复用**：
   - 类似的动画配置（如多个射手类植物）无法复用
   - 每个植物都需要单独配置

### Reference Implementation

**参考实现**：`cmd/animation_showcase/config.yaml` 提供了完善的配置格式

```yaml
# cmd/animation_showcase/config.yaml (示例)
cells:
  - title: "豌豆射手 - 攻击+摇晃"
    reanim: assets/effect/reanim/PeaShooterSingle.reanim
    animations:
      - anim_shooting
      - anim_head_idle

    # 轨道绑定策略
    binding_strategy: auto  # auto 或 manual

    # 手动绑定（可选）
    manual_bindings:
      anim_face: anim_head_idle
      stalk_bottom: anim_shooting

    # 父子关系
    parent_tracks:
      anim_face: anim_stem

    # 隐藏轨道
    hidden_tracks:
      - anim_blink
```

**配置的优势**：
- ✅ 配置与代码分离，修改无需重新编译
- ✅ YAML 格式易读易写，非程序员也能理解
- ✅ 支持版本控制，可追踪配置历史
- ✅ 支持配置复用和继承（未来扩展）

### Design Goals

**配置系统的设计目标**：

1. **声明式配置**：
   - 通过 YAML 文件声明动画组合、轨道绑定、父子关系
   - 无需编写代码逻辑

2. **灵活性**：
   - 支持自动轨道绑定（auto）和手动绑定（manual）
   - 支持配置父子关系、隐藏轨道
   - 支持多个动画组合定义

3. **易用性**：
   - 清晰的 YAML 结构，有注释说明
   - 提供示例配置文件
   - 加载时验证配置，提供清晰的错误信息

4. **性能**：
   - 配置在启动时加载，运行时无额外开销
   - 支持缓存已加载的配置

---

## Acceptance Criteria

1. **定义 YAML 配置格式**
   - 设计 Reanim 配置文件的 YAML schema
   - 支持配置：reanim 文件路径、动画列表、动画组合、轨道绑定策略、父子关系、隐藏轨道
   - 提供配置格式文档和注释

2. **实现配置加载和验证**
   - 实现 `LoadReanimConfig(path string)` 函数
   - 解析 YAML 文件为 Go 结构体
   - 验证配置的完整性和正确性
   - 提供清晰的错误信息（如缺少必填字段、引用不存在的动画）

3. **实现配置应用逻辑**
   - 实现 `ApplyReanimConfig(entityID, config)` 函数
   - 根据配置设置动画组合
   - 根据配置设置轨道绑定（auto 或 manual）
   - 根据配置设置父子关系
   - 应用隐藏轨道设置

4. **通过配置文件定义豌豆射手攻击组合（无需修改代码）**
   - 创建 `data/reanim_configs/peashooter.yaml` 配置文件
   - 在配置文件中定义豌豆射手的攻击组合（anim_shooting + anim_head_idle）
   - 在代码中调用 `ApplyReanimConfig()` 加载配置
   - 验证豌豆射手攻击动画正常工作
   - 修改配置文件（如调整父子关系），无需重新编译即可生效

---

## Tasks / Subtasks

### Task 1: 定义 YAML 配置格式和数据结构 (AC: 1)
- [ ] 设计 Reanim 配置文件的 YAML schema
  - [ ] 定义顶层字段：`reanim_file`, `animations`, `animation_combos`
  - [ ] 定义 `animation_combos` 的子字段：`name`, `display_name`, `animations`, `binding_strategy`, `manual_bindings`, `parent_tracks`, `hidden_tracks`
  - [ ] 添加注释说明每个字段的用途
- [ ] 在 `pkg/config/reanim_config.go` 中定义 Go 数据结构
  - [ ] `ReanimConfig` 结构体（顶层配置）
  - [ ] `AnimationDef` 结构体（动画定义）
  - [ ] `AnimationComboConfig` 结构体（动画组合配置）
  - [ ] 使用 YAML tag 映射字段名
- [ ] 编写配置格式文档
  - [ ] 在 `docs/reanim/reanim-config-guide.md` 中详细说明配置格式
  - [ ] 提供每个字段的说明、类型、示例

### Task 2: 实现配置加载和验证函数 (AC: 2)
- [ ] 在 `pkg/config/reanim_config.go` 中实现 `LoadReanimConfig(path string)` 函数
  - [ ] 读取 YAML 文件（使用 `os.ReadFile`）
  - [ ] 解析 YAML（使用 `gopkg.in/yaml.v3`）
  - [ ] 返回 `ReanimConfig` 对象或错误
- [ ] 实现配置验证逻辑
  - [ ] 验证必填字段（如 `reanim_file`）
  - [ ] 验证动画名称引用（确保 `animation_combos` 中引用的动画在 `animations` 列表中）
  - [ ] 验证轨道绑定策略（只能是 "auto" 或 "manual"）
  - [ ] 验证父子关系（避免循环依赖）
- [ ] 提供清晰的错误信息
  - [ ] 使用 `fmt.Errorf` 包装错误并提供上下文
  - [ ] 示例：`"配置文件 %s 中引用了不存在的动画 '%s'"`

### Task 3: 实现配置应用函数 (AC: 3)
- [ ] 在 `pkg/systems/reanim_system.go` 中实现 `ApplyReanimConfig(entityID, config)` 方法
  - [ ] 输入：实体 ID、配置对象
  - [ ] 输出：error（如果应用失败）
- [ ] 应用动画组合配置
  - [ ] 遍历 `config.AnimationCombos`
  - [ ] 调用 `PlayAnimations(entityID, combo.Animations)` 设置动画
- [ ] 应用轨道绑定配置
  - [ ] 如果 `binding_strategy == "auto"`：
    - [ ] 调用 Story 13.1 的自动绑定分析算法
  - [ ] 如果 `binding_strategy == "manual"`：
    - [ ] 调用 `SetTrackBindings(entityID, combo.ManualBindings)`
- [ ] 应用父子关系配置
  - [ ] 调用 `SetParentTracks(entityID, combo.ParentTracks)`
- [ ] 应用隐藏轨道配置
  - [ ] 设置 `reanimComp.VisibleTracks`，将隐藏轨道标记为 false

### Task 4: 创建豌豆射手配置文件 (AC: 4)
- [ ] 创建配置文件 `data/reanim_configs/peashooter.yaml`
  - [ ] 设置 `reanim_file: assets/effect/reanim/PeaShooterSingle.reanim`
  - [ ] 定义动画列表：`anim_idle`, `anim_shooting`, `anim_head_idle`
  - [ ] 定义攻击组合：
    - [ ] 名称：`attack_with_sway`
    - [ ] 动画：`["anim_shooting", "anim_head_idle"]`
    - [ ] 绑定策略：`auto`（或 `manual` 并手动指定绑定）
    - [ ] 父子关系：`{"anim_face": "anim_stem"}`
- [ ] 修改 `pkg/entities/plant_factory.go` 的 `CreatePeashooter()` 函数
  - [ ] 加载配置：`config, err := config.LoadReanimConfig("data/reanim_configs/peashooter.yaml")`
  - [ ] 应用配置：`reanimSystem.ApplyReanimConfig(entityID, config)`
  - [ ] 移除硬编码的动画配置代码

### Task 5: 创建示例配置文件 (AC: 1, 4)
- [ ] 创建向日葵配置文件 `data/reanim_configs/sunflower.yaml`
  - [ ] 定义向日葵的动画组合（如待机动画）
- [ ] 创建更复杂的配置文件 `data/reanim_configs/zombie.yaml`
  - [ ] 定义僵尸的多个动画组合（如行走、攻击、死亡）
  - [ ] 展示更多配置选项（如隐藏轨道）
- [ ] 在每个配置文件中添加详细的注释
  - [ ] 解释每个字段的用途
  - [ ] 提供调整建议

### Task 6: 单元测试和集成测试 (AC: 2, 3)
- [ ] 为 `LoadReanimConfig()` 编写单元测试
  - [ ] 测试加载有效的配置文件
  - [ ] 测试加载不存在的文件（返回错误）
  - [ ] 测试加载格式错误的 YAML（返回错误）
  - [ ] 测试配置验证（如缺少必填字段、引用不存在的动画）
- [ ] 为 `ApplyReanimConfig()` 编写单元测试
  - [ ] 测试基本应用场景（auto 绑定）
  - [ ] 测试 manual 绑定场景
  - [ ] 测试父子关系应用
  - [ ] 测试隐藏轨道应用
- [ ] 集成测试：端到端配置加载和应用
  - [ ] 创建豌豆射手实体并加载配置
  - [ ] 验证动画正常播放
  - [ ] 验证轨道绑定正确
  - [ ] 验证父子关系生效

### Task 7: 配置验证和错误处理 (AC: 2)
- [ ] 实现配置验证辅助函数
  - [ ] `validateAnimationReferences(config)` - 验证动画引用
  - [ ] `validateParentTracks(config)` - 验证父子关系（避免循环）
  - [ ] `validateBindingStrategy(config)` - 验证绑定策略
- [ ] 处理边界情况
  - [ ] 配置文件为空
  - [ ] 动画组合为空
  - [ ] 手动绑定缺少必要的轨道

### Task 8: 文档更新 (AC: 1, 4)
- [ ] 创建 `docs/reanim/reanim-config-guide.md` 配置指南
  - [ ] 配置文件格式说明
  - [ ] 字段详细说明
  - [ ] 示例配置文件
  - [ ] 常见问题和最佳实践
- [ ] 更新 `CLAUDE.md` 中的 Reanim 系统使用指南
  - [ ] 添加"使用配置文件"章节
  - [ ] 提供示例代码
- [ ] 添加 API 文档注释
  - [ ] `LoadReanimConfig()` 函数的 GoDoc
  - [ ] `ApplyReanimConfig()` 方法的 GoDoc
  - [ ] 配置结构体的字段注释
- [ ] 更新 Story 13.5 的实施记录

---

## Dev Notes

本 Story 的核心任务是引入**基于 YAML 的配置系统**，使动画组合配置与代码分离，提升开发效率和可维护性。以下是开发者需要的完整技术上下文。

### Architecture Context

**技术栈** [Source: architecture/tech-stack.md]
- **语言**: Go (latest stable)
- **数据格式**: YAML v3（用于配置）
- **Go YAML 库**: `gopkg.in/yaml.v3` (latest stable)
- **测试框架**: Go Testing Pkg (标准库)

**项目结构** [Source: architecture/unified-project-structure.md]
- **配置加载**: `pkg/config/reanim_config.go` (新增)
- **配置文件**: `data/reanim_configs/*.yaml` (新增目录)
- **系统实现**: `pkg/systems/reanim_system.go`
- **实体工厂**: `pkg/entities/plant_factory.go`
- **文档**: `docs/reanim/reanim-config-guide.md` (新增)
- **测试文件**: `pkg/config/reanim_config_test.go` (新增)

### Previous Story Insights

**Story 13.1** (轨道绑定机制) 提供的基础：
- ✅ 自动轨道绑定分析算法可用
- ✅ `SetTrackBindings()` API 用于手动绑定

**Story 13.2** (简化多动画逻辑) 提供的基础：
- ✅ `PlayAnimations()` API 可同时播放多个动画

**Story 13.3** (父子偏移系统) 提供的基础：
- ✅ `SetParentTracks()` API 用于配置父子关系

**Story 13.4** (渲染优化) 提供的基础：
- ✅ 渲染缓存机制已优化性能
- ✅ 配置变更后需触发缓存失效（未来扩展）

**依赖状态**：
- ✅ Story 13.1-13.4 已完成
- ✅ 本 Story 是 Epic 13 的最终完善

### Data Models

**配置文件格式** [Source: Epic 13 PRD, cmd/animation_showcase/config.yaml]

```yaml
# data/reanim_configs/peashooter.yaml

# Reanim 文件路径（相对于项目根目录）
reanim_file: assets/effect/reanim/PeaShooterSingle.reanim

# 动画列表（可选，用于文档和验证）
animations:
  - name: anim_idle
    display_name: 待机
  - name: anim_shooting
    display_name: 攻击
  - name: anim_head_idle
    display_name: 头部摇晃

# 动画组合配置
animation_combos:
  - name: attack_with_sway              # 组合名称（代码中引用）
    display_name: 攻击+摇晃             # 显示名称（用于调试）
    animations:                         # 播放的动画列表
      - anim_shooting
      - anim_head_idle

    # 轨道绑定策略（auto 或 manual）
    binding_strategy: auto              # auto: 自动分析，manual: 手动指定

    # 手动绑定（可选，当 strategy=manual 时使用）
    manual_bindings:
      anim_face: anim_head_idle         # 头部轨道 -> 头部动画
      stalk_bottom: anim_shooting       # 身体轨道 -> 攻击动画

    # 父子关系定义
    parent_tracks:
      anim_face: anim_stem              # anim_face 的父轨道是 anim_stem

    # 隐藏轨道列表（可选）
    hidden_tracks:
      - anim_blink                      # 隐藏眨眼轨道
```

**Go 数据结构** [Source: Epic 13 PRD]

```go
// pkg/config/reanim_config.go

// ReanimConfig Reanim 配置文件的顶层结构
type ReanimConfig struct {
    ReanimFile      string                   `yaml:"reanim_file"`       // Reanim 文件路径
    Animations      []AnimationDef           `yaml:"animations"`        // 动画列表（可选）
    AnimationCombos []AnimationComboConfig   `yaml:"animation_combos"`  // 动画组合配置
}

// AnimationDef 动画定义（用于文档和验证）
type AnimationDef struct {
    Name        string `yaml:"name"`         // 动画名称（如 "anim_idle"）
    DisplayName string `yaml:"display_name"` // 显示名称（如 "待机"）
}

// AnimationComboConfig 动画组合配置
type AnimationComboConfig struct {
    Name             string            `yaml:"name"`              // 组合名称
    DisplayName      string            `yaml:"display_name"`      // 显示名称
    Animations       []string          `yaml:"animations"`        // 动画列表
    BindingStrategy  string            `yaml:"binding_strategy"`  // 绑定策略（"auto" 或 "manual"）
    ManualBindings   map[string]string `yaml:"manual_bindings"`   // 手动绑定（可选）
    ParentTracks     map[string]string `yaml:"parent_tracks"`     // 父子关系（可选）
    HiddenTracks     []string          `yaml:"hidden_tracks"`     // 隐藏轨道（可选）
}
```

### API Specifications

**配置加载 API** [Source: Epic 13 PRD]

```go
// pkg/config/reanim_config.go

// LoadReanimConfig 从 YAML 文件加载 Reanim 配置
// 参数：
//   - path: 配置文件路径（相对于项目根目录）
// 返回：
//   - *ReanimConfig: 解析后的配置对象
//   - error: 加载或解析错误
func LoadReanimConfig(path string) (*ReanimConfig, error)
```

**实现示例**：

```go
func LoadReanimConfig(path string) (*ReanimConfig, error) {
    // 1. 读取文件
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("无法读取配置文件 %s: %w", path, err)
    }

    // 2. 解析 YAML
    var config ReanimConfig
    if err := yaml.Unmarshal(data, &config); err != nil {
        return nil, fmt.Errorf("无法解析配置文件 %s: %w", path, err)
    }

    // 3. 验证配置
    if err := validateConfig(&config); err != nil {
        return nil, fmt.Errorf("配置文件 %s 验证失败: %w", path, err)
    }

    return &config, nil
}

func validateConfig(config *ReanimConfig) error {
    // 验证必填字段
    if config.ReanimFile == "" {
        return fmt.Errorf("缺少必填字段 'reanim_file'")
    }

    // 验证动画引用
    animNames := make(map[string]bool)
    for _, anim := range config.Animations {
        animNames[anim.Name] = true
    }

    for _, combo := range config.AnimationCombos {
        for _, animName := range combo.Animations {
            if len(animNames) > 0 && !animNames[animName] {
                return fmt.Errorf("动画组合 '%s' 引用了不存在的动画 '%s'", combo.Name, animName)
            }
        }

        // 验证绑定策略
        if combo.BindingStrategy != "" && combo.BindingStrategy != "auto" && combo.BindingStrategy != "manual" {
            return fmt.Errorf("无效的绑定策略 '%s'，只能是 'auto' 或 'manual'", combo.BindingStrategy)
        }
    }

    return nil
}
```

**配置应用 API** [Source: Epic 13 PRD]

```go
// pkg/systems/reanim_system.go

// ApplyReanimConfig 将配置应用到指定实体
// 参数：
//   - entityID: 实体 ID
//   - config: Reanim 配置对象
// 返回：
//   - error: 应用失败时的错误
func (rs *ReanimSystem) ApplyReanimConfig(entityID ecs.EntityID, config *ReanimConfig) error
```

**实现示例**：

```go
func (rs *ReanimSystem) ApplyReanimConfig(entityID ecs.EntityID, config *ReanimConfig) error {
    comp, ok := ecs.GetComponent[*components.ReanimComponent](rs.entityManager, entityID)
    if !ok {
        return fmt.Errorf("实体 %d 没有 ReanimComponent", entityID)
    }

    // 应用每个动画组合配置
    for _, combo := range config.AnimationCombos {
        // 1. 播放动画
        rs.PlayAnimations(entityID, combo.Animations)

        // 2. 设置轨道绑定
        if combo.BindingStrategy == "manual" && len(combo.ManualBindings) > 0 {
            if err := rs.SetTrackBindings(entityID, combo.ManualBindings); err != nil {
                return fmt.Errorf("设置轨道绑定失败: %w", err)
            }
        } else if combo.BindingStrategy == "auto" {
            // 自动绑定已在 PlayAnimations() 中处理
        }

        // 3. 设置父子关系
        if len(combo.ParentTracks) > 0 {
            if err := rs.SetParentTracks(entityID, combo.ParentTracks); err != nil {
                return fmt.Errorf("设置父子关系失败: %w", err)
            }
        }

        // 4. 设置隐藏轨道
        if len(combo.HiddenTracks) > 0 {
            if comp.VisibleTracks == nil {
                comp.VisibleTracks = make(map[string]bool)
            }
            for _, trackName := range combo.HiddenTracks {
                comp.VisibleTracks[trackName] = false
            }
        }
    }

    return nil
}
```

### Technical Implementation Details

**使用配置文件创建实体** [Source: Epic 13 PRD]

```go
// pkg/entities/plant_factory.go

func CreatePeashooter(em *ecs.EntityManager, reanimSystem *systems.ReanimSystem, gridX, gridY int) (ecs.EntityID, error) {
    // 1. 创建实体和基础组件
    entityID := em.CreateEntity()
    // ... 添加 PositionComponent, SpriteComponent 等 ...

    // 2. 加载 Reanim 配置
    config, err := config.LoadReanimConfig("data/reanim_configs/peashooter.yaml")
    if err != nil {
        return 0, fmt.Errorf("加载豌豆射手配置失败: %w", err)
    }

    // 3. 创建 ReanimComponent（加载 reanim 文件）
    reanimComp, err := createReanimComponent(config.ReanimFile)
    if err != nil {
        return 0, fmt.Errorf("创建 ReanimComponent 失败: %w", err)
    }
    ecs.AddComponent(em, entityID, reanimComp)

    // 4. 应用配置
    if err := reanimSystem.ApplyReanimConfig(entityID, config); err != nil {
        return 0, fmt.Errorf("应用 Reanim 配置失败: %w", err)
    }

    return entityID, nil
}
```

**配置文件位置规范**：
- 所有 Reanim 配置文件存放在 `data/reanim_configs/` 目录
- 命名规范：`{植物名}.yaml`（如 `peashooter.yaml`, `sunflower.yaml`）
- 使用相对路径引用（相对于项目根目录）

**配置验证逻辑**：

1. **必填字段验证**：
   - `reanim_file` 必须存在且非空
   - 每个 `animation_combo` 必须有 `name` 和 `animations`

2. **引用完整性验证**：
   - `animation_combos.animations` 中的动画名称必须在 `animations` 列表中（如果提供）
   - `manual_bindings` 中的动画名称必须在 `animations` 列表中

3. **循环依赖检测**（可选）：
   - 检测 `parent_tracks` 中是否存在循环（A → B → C → A）

4. **策略验证**：
   - `binding_strategy` 只能是 "auto" 或 "manual"
   - 如果是 "manual"，必须提供 `manual_bindings`

### Project Structure Notes

**新增文件清单**：

1. **pkg/config/reanim_config.go** (新增)
   - `ReanimConfig`, `AnimationDef`, `AnimationComboConfig` 结构体
   - `LoadReanimConfig()` 函数
   - `validateConfig()` 验证函数

2. **pkg/config/reanim_config_test.go** (新增)
   - 配置加载的单元测试
   - 配置验证的单元测试

3. **pkg/systems/reanim_system.go** (扩展)
   - 添加 `ApplyReanimConfig()` 方法

4. **data/reanim_configs/peashooter.yaml** (新增)
   - 豌豆射手的配置文件

5. **data/reanim_configs/sunflower.yaml** (新增)
   - 向日葵的配置文件

6. **docs/reanim/reanim-config-guide.md** (新增)
   - 配置格式详细说明

**目录结构**：

```plaintext
pvz/
├── pkg/
│   ├── config/
│   │   ├── reanim_config.go          # 新增
│   │   └── reanim_config_test.go     # 新增
│   ├── systems/
│   │   └── reanim_system.go          # 扩展（添加 ApplyReanimConfig）
│   └── entities/
│       └── plant_factory.go          # 修改（使用配置文件）
├── data/
│   └── reanim_configs/               # 新增目录
│       ├── peashooter.yaml           # 新增
│       └── sunflower.yaml            # 新增
└── docs/
    └── reanim/
        └── reanim-config-guide.md    # 新增
```

### Testing

**测试标准** [Source: architecture/testing-strategy.md]
- **测试框架**: Go 标准库 `testing` 包
- **测试文件位置**: 与源文件同目录，以 `_test.go` 结尾
- **覆盖率目标**: 核心逻辑包（如 `config`）达到 80%+ 覆盖率

**单元测试要求**：

```go
// pkg/config/reanim_config_test.go

func TestLoadReanimConfig_ValidFile(t *testing.T) {
    // 测试加载有效的配置文件
    config, err := LoadReanimConfig("testdata/valid_config.yaml")
    assert.NoError(t, err)
    assert.NotNil(t, config)
    assert.Equal(t, "assets/effect/reanim/Test.reanim", config.ReanimFile)
}

func TestLoadReanimConfig_FileNotFound(t *testing.T) {
    // 测试加载不存在的文件
    _, err := LoadReanimConfig("nonexistent.yaml")
    assert.Error(t, err)
}

func TestLoadReanimConfig_InvalidYAML(t *testing.T) {
    // 测试加载格式错误的 YAML
    _, err := LoadReanimConfig("testdata/invalid_yaml.yaml")
    assert.Error(t, err)
}

func TestValidateConfig_MissingReanimFile(t *testing.T) {
    // 测试缺少必填字段
    config := &ReanimConfig{}
    err := validateConfig(config)
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "reanim_file")
}

func TestValidateConfig_InvalidAnimationReference(t *testing.T) {
    // 测试引用不存在的动画
    config := &ReanimConfig{
        ReanimFile: "test.reanim",
        Animations: []AnimationDef{
            {Name: "anim_idle"},
        },
        AnimationCombos: []AnimationComboConfig{
            {
                Name:       "combo1",
                Animations: []string{"anim_nonexistent"},
            },
        },
    }
    err := validateConfig(config)
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "anim_nonexistent")
}

func TestApplyReanimConfig_BasicScenario(t *testing.T) {
    // 集成测试：加载配置并应用到实体
    em := ecs.NewEntityManager()
    rs := systems.NewReanimSystem(em)
    entityID := createTestEntity(em)

    config := &ReanimConfig{
        ReanimFile: "test.reanim",
        AnimationCombos: []AnimationComboConfig{
            {
                Name:       "attack",
                Animations: []string{"anim_shooting"},
            },
        },
    }

    err := rs.ApplyReanimConfig(entityID, config)
    assert.NoError(t, err)
}
```

**集成测试**：
- 创建测试配置文件（`testdata/` 目录）
- 加载配置并创建实体
- 验证动画正常播放
- 验证配置正确应用

**测试数据**：
- 创建 `testdata/` 目录存放测试用配置文件
- 提供有效配置、无效配置、边界情况配置

### Coding Standards

**必须遵守的规则** [Source: architecture/coding-standards.md]

1. **命名约定**：
   - 函数/方法：`PascalCase`（公共），`camelCase`（私有）
   - 结构体：`PascalCase`
   - 变量：`camelCase`
   - YAML 字段：`snake_case`

2. **错误处理**：
   - 不允许忽略错误
   - 使用 `fmt.Errorf` 包装错误并提供上下文
   - 示例：`fmt.Errorf("无法读取配置文件 %s: %w", path, err)`

3. **YAML 解析**：
   - 使用 `gopkg.in/yaml.v3` 库
   - 在结构体字段上使用 `yaml` tag
   - 示例：`ReanimFile string \`yaml:"reanim_file"\``

4. **配置验证**：
   - 加载后立即验证配置
   - 提供清晰的错误信息
   - 包含字段名称、期望值、实际值

5. **注释**：
   - 所有公共函数必须有 GoDoc 注释
   - 配置文件中添加注释说明字段用途
   - 示例配置文件中提供详细注释

### Known Constraints and Considerations

**配置热重载**（未来扩展）：
- 当前版本：配置在启动时加载，运行时不支持热重载
- 未来改进：监听配置文件变化，自动重新加载

**配置缓存**：
- 当前版本：每次调用 `LoadReanimConfig()` 都重新读取文件
- 未来优化：缓存已加载的配置，避免重复 IO

**配置继承**（未来扩展）：
- 当前版本：不支持配置继承或复用
- 未来改进：支持 `extends` 字段，继承其他配置文件

**配置版本控制**：
- 建议：将配置文件纳入 Git 版本控制
- 优势：可追踪配置历史，方便回滚

**向后兼容性**：
- 保留现有的硬编码配置方式（向后兼容）
- 优先使用配置文件，如果配置文件不存在，回退到硬编码

### Reference Materials

**内部文档**：
- `docs/stories/13.1.story.md` - 轨道绑定机制
- `docs/stories/13.2.story.md` - 简化多动画逻辑
- `docs/stories/13.3.story.md` - 父子偏移系统
- `docs/stories/13.4.story.md` - 渲染优化

**参考实现**：
- `cmd/animation_showcase/config.yaml` - 完整配置示例
- `cmd/animation_showcase/config_fixed.yaml` - 140 个动画的配置

**Epic 文档**：
- `docs/prd/epic-13-reanim-modernization.md` - Epic 13 完整 PRD

**外部资源**：
- YAML 规范：https://yaml.org/spec/1.2/spec.html
- `gopkg.in/yaml.v3` 文档：https://pkg.go.dev/gopkg.in/yaml.v3

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-07 | 1.0 | 初始 Story 创建 | Bob (SM) |

---

## Dev Agent Record

### Agent Model Used
_待开发代理填写_

### Debug Log References
_待开发代理填写_

### Completion Notes List
_待开发代理填写_

### File List
_待开发代理填写_

---

## QA Results
_待 QA 代理填写_
