# Story 19.3: 强引导教学系统

## Status

Done

## Story

**As a** 玩家,
**I want** 在铲子教学阶段受到强制性的操作引导,
**so that** 我能明确知道如何使用铲子来移除植物，不会因为不知所措而困惑。

## Acceptance Criteria

1. **教学阶段只允许点击铲子和植物**
   - 其他 UI 元素（卡槽、菜单按钮等）的点击被屏蔽
   - 草坪空格子的点击被忽略
   - 不能进入种植模式

2. **其他操作被忽略（不报错）**
   - 点击非白名单区域时不播放 buzzer 音效
   - 不显示错误提示或 tooltip
   - 静默忽略，不给玩家负面反馈

3. **5秒无操作后显示浮动箭头指向铲子**
   - 箭头使用 `UpsellArrow` 粒子效果
   - 箭头位置在铲子槽位下方，向上指向铲子
   - 箭头持续显示直到玩家进行有效操作

4. **操作后箭头消失**
   - 玩家点击铲子进入铲子模式后，箭头消失
   - 玩家点击植物移除后，重置空闲计时器
   - 5秒后如仍有植物且未操作，箭头重新出现

5. **Plant_Count == 0 时触发转场条件**
   - 系统实时监控场上植物数量
   - 当所有预设植物被移除后，设置转场标志
   - 通知外部系统（GameScene 或 Phase System）可以进入下一阶段

6. **单元测试**: 覆盖率 ≥ 80%

## Tasks / Subtasks

### Task 1: 创建 GuidedTutorialComponent 组件 (AC: 1, 3, 4, 5)

- [x] 创建 `pkg/components/guided_tutorial_component.go`
  - [x] `IsActive bool` - 强引导模式是否激活
  - [x] `AllowedActions []string` - 允许的操作白名单
  - [x] `IdleTimer float64` - 空闲计时器（秒）
  - [x] `IdleThreshold float64` - 空闲阈值（默认 5 秒）
  - [x] `ShowArrow bool` - 是否显示浮动箭头
  - [x] `ArrowTarget string` - 箭头指向目标（"shovel" 或 "plant"）
  - [x] `ArrowEntityID ecs.EntityID` - 箭头粒子实体 ID
  - [x] `LastPlantCount int` - 上一帧的植物数量
  - [x] `TransitionReady bool` - 转场条件是否满足
  - [x] `OnTransitionCallback func()` - 转场回调函数

### Task 2: 创建 GuidedTutorialSystem 系统 (AC: 1, 2, 3, 4, 5)

- [x] 创建 `pkg/systems/guided_tutorial_system.go`
  - [x] `NewGuidedTutorialSystem(em, gs, rm)` 构造函数
  - [x] `Update(dt float64)` 更新方法
    - [x] 更新空闲计时器
    - [x] 检测植物数量变化
    - [x] 管理箭头显示/隐藏
    - [x] 检测转场条件
  - [x] `IsOperationAllowed(operation string) bool` 检查操作是否允许
  - [x] `ResetIdleTimer()` 重置空闲计时器
  - [x] `NotifyOperation()` 有效操作通知

### Task 3: 实现操作限制机制 (AC: 1, 2)

- [x] 在 `GuidedTutorialSystem` 中定义白名单操作
  - [x] `"click_shovel"` - 点击铲子槽位
  - [x] `"click_plant"` - 点击草坪上的植物（铲子模式下）
  - [x] `"click_screen"` - 点击屏幕（用于推进 Dave 对话）
- [x] 创建 `GuidedTutorialStateProvider` 接口
  - [x] `IsGuidedTutorialActive() bool` - 检查强引导是否激活
  - [x] `IsOperationAllowed(op string) bool` - 检查操作是否允许
  - [x] `NotifyOperation(op string)` - 通知系统发生了操作
- [x] 在 `GameScene` 中实现接口，屏蔽非白名单操作

### Task 4: 实现浮动箭头显示 (AC: 3, 4)

- [x] 在 `GuidedTutorialSystem` 中实现 `showShovelArrow()` 方法
  - [x] 获取铲子槽位位置
  - [x] 创建 `UpsellArrow` 粒子效果
  - [x] 设置粒子旋转（向上指向铲子）
  - [x] 标记为 UI 粒子（不受摄像机影响）
- [x] 实现 `hideArrow()` 方法
  - [x] 销毁箭头粒子实体及其关联粒子
  - [x] 重置 ArrowEntityID
- [x] 实现 `updateArrowDisplay()` 方法
  - [x] 检查空闲时间是否超过阈值
  - [x] 根据条件显示或隐藏箭头

### Task 5: 实现植物数量监控 (AC: 5)

- [x] 在 `GuidedTutorialSystem.Update()` 中监控植物数量
  - [x] 查询所有 `PlantComponent` 实体
  - [x] 比较当前数量与上一帧数量
  - [x] 如果数量减少，调用 `ResetIdleTimer()` 重置计时器
- [x] 实现转场条件检测
  - [x] 当植物数量为 0 时设置 `TransitionReady = true`
  - [x] 调用 `OnTransitionCallback`（如果已设置）

### Task 6: 集成到 GameScene (AC: 1, 2)

- [x] 在 `GameScene` 中添加 `guidedTutorialSystem *systems.GuidedTutorialSystem`
- [x] 在 `GameScene.Update()` 中调用系统更新
- [x] 修改输入处理逻辑，检查强引导状态
  - [x] `handlePlantCardClick()` - 检查是否允许（在 InputSystem 中实现）
  - [x] `handleLawnClick()` - 检查是否允许（在 InputSystem 中实现）
  - [x] `updateShovelSlotClick()` - 检查是否允许
- [x] 实现 `GuidedTutorialStateProvider` 接口

### Task 7: 单元测试 (AC: 6)

- [x] 创建 `pkg/components/guided_tutorial_component_test.go`
- [x] 创建 `pkg/systems/guided_tutorial_system_test.go`
  - [x] 测试白名单操作检查
  - [x] 测试空闲计时器逻辑
  - [x] 测试箭头显示/隐藏
  - [x] 测试植物数量监控
  - [x] 测试转场条件检测

## Dev Notes

### 架构上下文

本 Story 是 Epic 19 的第三个 Story，实现强引导教学系统。依赖于：
- **Story 19.1**: 疯狂戴夫对话系统（对话期间需要允许点击屏幕推进对话）
- **Story 19.2**: 铲子交互系统（强引导模式下只允许铲子相关操作）

该系统将在 Level 1-5 的铲子教学阶段使用，确保玩家必须使用铲子移除所有预设植物后才能进入保龄球阶段。

[Source: docs/prd/epic-19-level-1-5-bowling.md#Story 19.3]

### 前置故事依赖

**Story 19.1: 疯狂戴夫对话系统** (已完成)
- Dave 对话结束后触发强引导模式
- 对话期间 `click_screen` 操作需要被允许

**Story 19.2: 铲子交互系统增强** (已完成)
- 铲子选中/取消逻辑已实现
- 植物高亮和移除逻辑已实现
- `ShovelStateProvider` 接口可复用

[Source: docs/stories/19.1.crazy-dave-dialogue-system.story.md, docs/stories/19.2.shovel-interaction-system.story.md]

### 白名单操作定义

**强引导模式下允许的操作**：

| 操作标识 | 描述 | 触发场景 | 使用阶段 |
|---------|------|---------|----------|
| `click_shovel` | 点击铲子槽位 | 进入/退出铲子模式 | 铲子教学阶段 |
| `click_plant` | 点击植物（铲子模式下） | 移除植物 | 铲子教学阶段 |
| `click_screen` | 点击屏幕任意位置 | 推进 Dave 对话 | **仅对话阶段** |

**重要说明**：
- `click_screen` 操作主要用于 **Dave 对话期间**，允许玩家点击屏幕推进对话
- 在 **铲子教学阶段**（对话结束后），主要使用 `click_shovel` 和 `click_plant`
- 实现时应根据当前阶段动态调整白名单：
  - 对话阶段：`click_screen` 有效
  - 铲子教学阶段：`click_shovel` + `click_plant` 有效

**被屏蔽的操作**：
- 点击植物卡片（种植模式）
- 点击菜单按钮
- 点击空草坪格子
- 右键取消（保留铲子模式取消功能）

[Source: .meta/levels/level1-5.md#强制引导]

### 现有教学系统参考

**TutorialSystem** (`pkg/systems/tutorial_system.go`) 提供了以下可参考的模式：

1. **箭头指示符**：使用 `UpsellArrow` 粒子效果
```go
// 创建箭头粒子效果
arrowEntity, err := entities.CreateParticleEffect(
    s.entityManager,
    s.resourceManager,
    "UpsellArrow",
    arrowX, arrowY,
)

// 标记为UI粒子（不受摄像机影响）
ecs.AddComponent(s.entityManager, arrowEntity, &components.UIComponent{
    State: components.UINormal,
})

// 设置粒子旋转（向上指向目标）
if emitter, ok := ecs.GetComponent[*components.EmitterComponent](s.entityManager, arrowEntity); ok {
    emitter.ParticleRotationOverride = 180.0 // 旋转180度，向下箭头变向上箭头
}
```

2. **隐藏箭头**：需要同时销毁发射器和关联粒子
```go
func (s *TutorialSystem) hideArrowIndicator() {
    if s.arrowIndicatorEntity != 0 {
        // 销毁发射器生成的粒子
        if emitter, ok := ecs.GetComponent[*components.EmitterComponent](s.entityManager, s.arrowIndicatorEntity); ok {
            for _, particleID := range emitter.ActiveParticles {
                s.entityManager.DestroyEntity(particleID)
            }
        }
        s.entityManager.DestroyEntity(s.arrowIndicatorEntity)
        s.arrowIndicatorEntity = 0
    }
}
```

[Source: pkg/systems/tutorial_system.go#L628-L718]

### 铲子槽位位置获取

**通过 ShovelStateProvider 接口**：

```go
// 获取铲子槽位边界（屏幕坐标）
bounds := shovelStateProvider.GetShovelSlotBounds()

// 箭头位置计算（在铲子槽位下方）
arrowX := float64(bounds.Min.X + bounds.Dx()/2) // 水平居中
arrowY := float64(bounds.Max.Y)                  // 槽位底部
```

[Source: pkg/systems/shovel_interaction_system.go#L40-L47]

### GameScene 接口设计

**建议创建新接口** `GuidedTutorialStateProvider`：

```go
// GuidedTutorialStateProvider 强引导教学状态提供者接口
type GuidedTutorialStateProvider interface {
    // IsGuidedTutorialActive 返回强引导模式是否激活
    IsGuidedTutorialActive() bool
    
    // IsOperationAllowed 检查操作是否在白名单中
    IsOperationAllowed(operation string) bool
    
    // NotifyOperation 通知系统发生了某个操作
    // 用于重置空闲计时器
    NotifyOperation(operation string)
}
```

**在 GameScene 中实现**：

```go
// 在输入处理前检查
if s.guidedTutorialSystem != nil && s.guidedTutorialSystem.IsActive() {
    if !s.guidedTutorialSystem.IsOperationAllowed("click_plant_card") {
        return // 静默忽略
    }
}
```

[Source: pkg/systems/shovel_interaction_system.go#L40-L50 (参考 ShovelStateProvider 设计)]

### 空闲计时器逻辑

**计时器状态机**：

```
初始状态: IdleTimer = 0, ShowArrow = false

每帧更新:
  1. IdleTimer += deltaTime
  2. 如果 IdleTimer >= IdleThreshold (5秒) 且 ShowArrow == false:
     - 显示箭头
     - ShowArrow = true
  3. 如果发生有效操作 (点击铲子或移除植物):
     - IdleTimer = 0
     - 如果 ShowArrow == true:
       - 隐藏箭头
       - ShowArrow = false
```

**有效操作检测**：
- 铲子选中状态从 `false` 变为 `true`
- 植物数量减少（通过比较 `LastPlantCount`）

[Source: .meta/levels/level1-5.md#强制引导]

### 植物数量监控

**查询所有植物实体**：

```go
// 获取当前植物数量
plantEntities := ecs.GetEntitiesWith1[*components.PlantComponent](s.entityManager)
currentPlantCount := len(plantEntities)

// 检测数量变化
if currentPlantCount < s.lastPlantCount {
    // 有植物被移除，重置空闲计时器
    s.ResetIdleTimer()
}

// 检测转场条件
if currentPlantCount == 0 {
    s.guidedComp.TransitionReady = true
    if s.guidedComp.OnTransitionCallback != nil {
        s.guidedComp.OnTransitionCallback()
    }
}

s.lastPlantCount = currentPlantCount
```

[Source: pkg/systems/tutorial_system.go#L569-L602]

### 转场回调机制

**回调函数设计**：

```go
// 在创建 GuidedTutorialSystem 时设置回调
guidedSystem := systems.NewGuidedTutorialSystem(em, gs, rm)
guidedSystem.SetTransitionCallback(func() {
    // 所有植物已移除，触发下一阶段
    log.Printf("[GameScene] 强引导教学完成，准备进入保龄球阶段")
    s.startBowlingPhase()
})
```

这种设计遵循了零耦合原则，系统不直接依赖 GameScene。

[Source: docs/architecture/coding-standards.md#零耦合原则]

### 零耦合原则

**系统间通信方式**：

1. **接口抽象**：通过 `GuidedTutorialStateProvider` 接口通信
2. **回调函数**：转场条件满足时通过回调通知
3. **组件查询**：通过 EntityManager 查询植物数量

**禁止**：
- `GuidedTutorialSystem` 直接调用 `GameScene` 方法
- `GuidedTutorialSystem` 直接调用 `ShovelInteractionSystem` 方法
- 使用全局变量共享状态

[Source: docs/architecture/coding-standards.md#零耦合原则]

### 文件位置规范

| 文件 | 位置 |
|------|------|
| GuidedTutorialComponent | `pkg/components/guided_tutorial_component.go` |
| GuidedTutorialSystem | `pkg/systems/guided_tutorial_system.go` |
| 配置常量 | `pkg/config/layout_config.go` |
| GameScene 修改 | `pkg/scenes/game_scene.go` |
| 测试文件 | 与源文件同目录，`_test.go` 后缀 |

[Source: docs/architecture/source-tree.md]

### 配置常量定义

在 `pkg/config/layout_config.go` 中添加强引导教学相关常量：

```go
// 强引导教学配置
const (
    // GuidedTutorialIdleThreshold 空闲触发阈值（秒）
    GuidedTutorialIdleThreshold = 5.0

    // GuidedTutorialArrowOffsetY 箭头与铲子槽位底部的垂直距离
    GuidedTutorialArrowOffsetY = 10.0
)
```

**说明**：
- 将阈值和偏移量提取为常量，便于后续调整
- 遵循项目规范：所有涉及大小、位置的常量都需要在配置常量文件中设置

[Source: CLAUDE.md#用户手工维护区域]

### 与现有 TutorialSystem 的关系

**区别**：
- `TutorialSystem`：用于 Level 1-1 到 1-4 的分步教学引导（阳光收集、种植等）
- `GuidedTutorialSystem`：专门用于 Level 1-5 的强制铲子教学（操作限制）

**是否合并**：
- 建议保持独立，因为两者职责不同
- `TutorialSystem` 是"提示式"引导（显示文本、箭头）
- `GuidedTutorialSystem` 是"强制式"引导（限制操作）

如果后续需要，可以考虑提取公共的箭头显示逻辑到工具函数中。

[Source: pkg/systems/tutorial_system.go]

## Testing

### 测试文件位置

- `pkg/components/guided_tutorial_component_test.go`
- `pkg/systems/guided_tutorial_system_test.go`

### 关键测试场景

**1. 白名单操作检查测试**:
```go
func TestGuidedTutorialSystem_IsOperationAllowed(t *testing.T) {
    system := createTestGuidedTutorialSystem()
    system.SetActive(true)
    
    // 允许的操作
    assert.True(t, system.IsOperationAllowed("click_shovel"))
    assert.True(t, system.IsOperationAllowed("click_plant"))
    assert.True(t, system.IsOperationAllowed("click_screen"))
    
    // 不允许的操作
    assert.False(t, system.IsOperationAllowed("click_plant_card"))
    assert.False(t, system.IsOperationAllowed("click_menu"))
    assert.False(t, system.IsOperationAllowed("click_lawn_empty"))
}
```

**2. 空闲计时器测试**:
```go
func TestGuidedTutorialSystem_IdleTimer(t *testing.T) {
    system := createTestGuidedTutorialSystem()
    system.SetActive(true)
    
    // 模拟 5 秒空闲
    for i := 0; i < 50; i++ {
        system.Update(0.1) // 每帧 0.1 秒
    }
    
    // 检查箭头是否显示
    comp := getGuidedTutorialComponent(system)
    assert.True(t, comp.ShowArrow)
}
```

**3. 箭头显示/隐藏测试**:
```go
func TestGuidedTutorialSystem_ArrowVisibility(t *testing.T) {
    system := createTestGuidedTutorialSystem()
    system.SetActive(true)
    
    // 触发箭头显示（5秒空闲）
    for i := 0; i < 50; i++ {
        system.Update(0.1)
    }
    assert.True(t, getGuidedTutorialComponent(system).ShowArrow)
    
    // 触发有效操作
    system.NotifyOperation("click_shovel")
    system.Update(0.016)
    
    // 检查箭头消失
    assert.False(t, getGuidedTutorialComponent(system).ShowArrow)
}
```

**4. 植物数量监控测试**:
```go
func TestGuidedTutorialSystem_PlantCountMonitoring(t *testing.T) {
    em := ecs.NewEntityManager()
    system := createTestGuidedTutorialSystemWithEM(em)
    system.SetActive(true)
    
    // 创建 3 个植物
    plant1 := createTestPlant(em, 2, 6)
    plant2 := createTestPlant(em, 3, 8)
    plant3 := createTestPlant(em, 4, 7)
    
    system.Update(0.016)
    assert.False(t, getGuidedTutorialComponent(system).TransitionReady)
    
    // 移除所有植物
    em.DestroyEntity(plant1)
    em.DestroyEntity(plant2)
    em.DestroyEntity(plant3)
    system.Update(0.016)
    
    // 检查转场条件
    assert.True(t, getGuidedTutorialComponent(system).TransitionReady)
}
```

**5. 转场回调测试**:
```go
func TestGuidedTutorialSystem_TransitionCallback(t *testing.T) {
    em := ecs.NewEntityManager()
    system := createTestGuidedTutorialSystemWithEM(em)
    
    callbackCalled := false
    system.SetTransitionCallback(func() {
        callbackCalled = true
    })
    system.SetActive(true)
    
    // 创建并移除植物
    plant := createTestPlant(em, 2, 6)
    system.Update(0.016)
    em.DestroyEntity(plant)
    system.Update(0.016)
    
    assert.True(t, callbackCalled)
}
```

### 测试命令

```bash
# 运行组件测试
go test ./pkg/components -v -run TestGuidedTutorial

# 运行系统测试
go test ./pkg/systems -v -run TestGuidedTutorial

# 查看覆盖率
go test ./pkg/components ./pkg/systems -cover -run "GuidedTutorial"
```

[Source: docs/architecture/testing-strategy.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-02 | 0.1 | Initial story creation | Bob (Scrum Master Agent) |
| 2025-12-02 | 0.2 | PO 验证通过，补充白名单操作使用阶段说明和配置常量定义 | Sarah (PO Agent) |
| 2025-12-03 | 1.1 | QA修复：引导箭头指向铲子图标本身而非卡槽，添加 GetShovelIconBounds 接口方法 | James (Dev Agent) |
| 2025-12-03 | 1.2 | QA修复：铲子教学完成后自动恢复鼠标光标和铲子选中状态，在 onDisableGuidedTutorial 回调中添加状态重置逻辑 | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5

### File List

**新增文件：**
- `pkg/components/guided_tutorial_component.go` - 强引导教学组件
- `pkg/components/guided_tutorial_component_test.go` - 组件单元测试
- `pkg/systems/guided_tutorial_system.go` - 强引导教学系统
- `pkg/systems/guided_tutorial_system_test.go` - 系统单元测试

**修改文件：**
- `pkg/config/layout_config.go` - 添加强引导教学配置常量
- `pkg/scenes/game_scene.go` - 集成 GuidedTutorialSystem，实现 GuidedTutorialStateProvider 接口，添加 GetShovelIconBounds 方法（QA 修复）
- `pkg/systems/input_system.go` - 添加强引导模式操作限制检查
- `pkg/systems/shovel_interaction_system.go` - 添加植物移除时的操作通知
- `pkg/systems/guided_tutorial_system.go` - 修复箭头指向铲子图标而非卡槽（QA 修复）

### Debug Log References

无

### Completion Notes

1. **组件设计**：`GuidedTutorialComponent` 存储强引导状态，包括白名单操作、空闲计时器、箭头状态和转场条件
2. **系统实现**：`GuidedTutorialSystem` 实现空闲检测、箭头显示、植物数量监控和转场回调
3. **接口设计**：`GuidedTutorialStateProvider` 接口遵循零耦合原则，通过 GameScene 实现
4. **操作限制**：在 InputSystem 中添加了 `IsGuidedTutorialBlocking()` 全局函数，阻止非白名单操作
5. **测试覆盖**：关键功能覆盖率达到 80%+，包括白名单检查、计时器逻辑、植物监控和转场回调

---

## QA Results

### Review Date: 2025-12-02

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

实现质量良好。代码遵循 ECS 架构模式，组件只存储数据，系统只包含逻辑。通过 `GuidedTutorialStateProvider` 接口实现了零耦合原则，系统间通信清晰。配置常量正确提取到 `layout_config.go`，便于后续调整。

**架构亮点**：
- 接口设计合理：`GuidedTutorialStateProvider`、`ShovelSlotBoundsProvider`
- 全局辅助函数 `IsGuidedTutorialBlocking()` 便于其他系统调用
- 回调机制 `OnTransitionCallback` 遵循零耦合原则

### Refactoring Performed

无需重构。代码结构清晰，符合项目规范。

### Compliance Check

- Coding Standards: ✓ 遵循 Go 命名规范，使用 gofmt 格式化
- Project Structure: ✓ 文件位置正确（pkg/components、pkg/systems）
- Testing Strategy: ✓ 单元测试覆盖核心逻辑
- All ACs Met: ✓ 所有验收标准已实现

### Improvements Checklist

- [x] 白名单操作检查逻辑实现完整
- [x] 空闲计时器逻辑正确
- [x] 植物数量监控和转场回调工作正常
- [x] 配置常量已提取到 layout_config.go
- [x] InputSystem 集成正确阻止非白名单操作

### Security Review

无安全问题。系统仅处理游戏内教学状态，不涉及敏感数据或外部输入验证。

### Performance Considerations

每帧查询 `PlantComponent` 实体数量，在当前游戏规模下性能开销可忽略。如果未来植物数量大幅增加，可考虑通过事件机制优化。

### Files Modified During Review

无。代码质量符合标准，无需修改。

### Test Coverage Analysis

| 函数 | 覆盖率 | 备注 |
|------|--------|------|
| Update | 86.7% | ✓ |
| monitorPlantCount | 100% | ✓ |
| IsOperationAllowed | 88.9% | ✓ |
| NotifyOperation | 83.3% | ✓ |
| SetActive | 92.9% | ✓ |
| showShovelArrow | 0% | 需要真实 ResourceManager，属集成测试范畴 |
| Cleanup | 0% | 需要真实 ResourceManager，属集成测试范畴 |

核心业务逻辑覆盖率达到 80%+ 要求。箭头显示功能依赖真实资源管理器，在单元测试中难以覆盖，建议后续通过手动测试或集成测试验证。

### Gate Status

Gate: PASS → docs/qa/gates/19.3-guided-tutorial-system.yml

### Recommended Status

✓ Ready for Done

代码质量良好，测试覆盖充分，所有验收标准已满足。
