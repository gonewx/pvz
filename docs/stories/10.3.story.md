# Story 10.3: 植物攻击动画系统

## Status
Draft

## Story
**As a** 玩家,
**I want** plants to play attack animations when shooting projectiles,
**so that** the game visually communicates plant actions and feels more alive.

## Acceptance Criteria
1. 豌豆射手发射子弹时，自动切换到攻击动画（anim_shooting）。
2. 攻击动画播放完毕后，自动切换回空闲动画（anim_idle）。
3. 攻击动画播放期间，植物不应再次触发攻击动画（避免动画打断）。
4. 所有射手类植物（豌豆射手、未来的寒冰射手、双发射手等）都支持攻击动画。
5. 攻击动画使用原版 Reanim 动画资源，忠实还原原版表现。
6. 动画切换自然流畅，无明显跳帧或闪烁。
7. 攻击动画不影响子弹发射逻辑（子弹仍然按原计时器发射）。
8. 向日葵等非射手植物不受此功能影响，保持原有行为。

## Tasks / Subtasks

- [ ] Task 1: 设计攻击动画状态机 (AC: 1, 2, 3)
  - [ ] 在 `PlantComponent` 添加 `AttackAnimState` 字段（Idle/Attacking）
  - [ ] 在 `PlantComponent` 添加 `AttackAnimTimer` 字段（跟踪攻击动画持续时间）
  - [ ] 定义状态转换规则：Idle → Attacking（发射子弹时）→ Idle（动画播放完毕）

- [ ] Task 2: 修改豌豆射手发射逻辑 (AC: 1, 7)
  - [ ] 在 `BehaviorSystem.handlePeashooterBehavior()` 中发射子弹时触发攻击动画
  - [ ] 调用 `ReanimSystem.PlayAnimation(entityID, "anim_shooting", false)` 播放攻击动画（不循环）
  - [ ] 更新 `PlantComponent.AttackAnimState = Attacking`
  - [ ] 保持现有子弹发射逻辑不变（不影响计时器逻辑）

- [ ] Task 3: 实现攻击动画状态管理 (AC: 2, 3)
  - [ ] 在 `BehaviorSystem` 添加 `updatePlantAttackAnimation()` 方法
  - [ ] 每帧检查植物的攻击动画状态
  - [ ] 使用 `ReanimSystem.IsAnimationFinished(entityID)` 检测动画是否播放完毕
  - [ ] 动画播放完毕后切换回空闲动画：`PlayAnimation(entityID, "anim_idle", true)`
  - [ ] 更新 `PlantComponent.AttackAnimState = Idle`

- [ ] Task 4: 防止动画打断 (AC: 3)
  - [ ] 在 `handlePeashooterBehavior()` 中检查 `PlantComponent.AttackAnimState`
  - [ ] 如果状态为 `Attacking`，跳过发射子弹逻辑（即使计时器就绪）
  - [ ] 确保动画播放完毕后才允许下一次发射

- [ ] Task 5: 扩展到所有射手植物 (AC: 4)
  - [ ] 将攻击动画逻辑抽象为通用方法：`triggerPlantAttackAnimation(entityID, animName)`
  - [ ] 支持未来的寒冰射手、双发射手等植物
  - [ ] 在工厂函数中确保所有射手植物加载攻击动画资源

- [ ] Task 6: 验证原版动画资源 (AC: 5)
  - [ ] 检查 `assets/effect/reanim/peashooter.reanim` 是否包含 `anim_shooting` 轨道
  - [ ] 检查动画帧率和持续时间是否符合原版（约 0.3-0.5 秒）
  - [ ] 如果缺少动画，使用 `anim_idle` 作为降级方案并记录警告日志

- [ ] Task 7: 动画流畅性优化 (AC: 6)
  - [ ] 确保 ReanimSystem 的帧插值正确工作
  - [ ] 测试动画切换时的过渡效果
  - [ ] 如有闪烁或跳帧，调整动画切换时机（延迟1帧切换）

- [ ] Task 8: 非射手植物兼容性 (AC: 8)
  - [ ] 确保向日葵、坚果墙、樱桃炸弹等植物不受影响
  - [ ] 只在射手类植物的行为处理函数中添加动画逻辑
  - [ ] 添加植物类型检查：`if plantType == "peashooter" || plantType == "snowpea" { ... }`

- [ ] Task 9: 集成到 BehaviorSystem (所有 AC)
  - [ ] 在 `BehaviorSystem.Update()` 中调用 `updatePlantAttackAnimation()`
  - [ ] 确保在所有植物行为处理之后更新动画状态
  - [ ] 避免与现有行为逻辑冲突

- [ ] Task 10: 测试和验证 (所有 AC)
  - [ ] 测试豌豆射手发射子弹时攻击动画播放
  - [ ] 测试动画播放完毕后自动切换回空闲动画
  - [ ] 测试攻击动画期间不会再次触发
  - [ ] 测试向日葵等非射手植物行为不变
  - [ ] 测试动画切换流畅性

## Dev Notes

### Previous Story Insights
[Source: docs/stories/6.3.story.md#Dev Agent Record]

从 Story 6.3 的实施中学到的关键经验：
1. **ReanimSystem 已完整实现**: 支持多部件骨骼动画、帧插值、循环/非循环播放
2. **ReanimComponent**: 所有游戏世界实体使用 ReanimComponent 渲染（植物、僵尸、子弹）
3. **动画 API**: `PlayAnimation(entityID, animName, loop)` 播放动画
4. **动画完成检测**: `IsAnimationFinished(entityID)` 检测非循环动画是否播放完毕
5. **Reanim 配置**: 动画资源在 `assets/effect/reanim/*.reanim` 中定义

**本 Story 重点**:
- AC 1-3: 设计攻击动画状态机，管理 Idle ↔ Attacking 状态转换
- AC 4: 抽象通用攻击动画逻辑，支持多种射手植物
- AC 5: 使用原版 Reanim 动画资源
- AC 6: 确保动画切换流畅，无跳帧
- AC 7: 不影响子弹发射计时器逻辑
- AC 8: 不影响非射手植物行为

### Relevant Architecture

#### PlantComponent 修改
[Location: pkg/components/plant_component.go]

```go
// AttackAnimState 攻击动画状态
type AttackAnimState int

const (
    AttackAnimIdle AttackAnimState = iota  // 空闲状态
    AttackAnimAttacking                     // 攻击中（播放攻击动画）
)

// PlantComponent 植物组件
type PlantComponent struct {
    PlantType       string  // 植物类型（peashooter, sunflower, wallnut, etc.）
    Health          int     // 当前生命值
    MaxHealth       int     // 最大生命值
    
    // Story 10.3: 攻击动画状态管理
    AttackAnimState AttackAnimState  // 攻击动画状态
}
```

#### BehaviorSystem 修改
[Location: pkg/systems/behavior_system.go]

```go
// handlePeashooterBehavior 修改
func (s *BehaviorSystem) handlePeashooterBehavior(entityID ecs.EntityID, deltaTime float64, zombieEntityList []ecs.EntityID) {
    // 获取植物组件
    plant, ok := ecs.GetComponent[*components.PlantComponent](s.entityManager, entityID)
    if !ok {
        return
    }
    
    // Story 10.3: 如果正在播放攻击动画，跳过发射逻辑
    if plant.AttackAnimState == components.AttackAnimAttacking {
        return
    }
    
    // 获取计时器组件
    timer, ok := ecs.GetComponent[*components.TimerComponent](s.entityManager, entityID)
    if !ok {
        return
    }
    
    // 更新计时器
    timer.CurrentTime += deltaTime
    
    // 检查计时器是否就绪
    if timer.CurrentTime >= timer.TargetTime {
        // ... 现有的僵尸检测逻辑 ...
        
        // 如果有僵尸在同一行，发射子弹
        if hasZombieInLine {
            // Story 10.3: 触发攻击动画
            s.triggerPlantAttackAnimation(entityID, "anim_shooting")
            
            // 播放发射音效
            s.playShootSound()
            
            // 创建豌豆子弹实体
            bulletID, err := entities.NewPeaProjectile(s.entityManager, s.resourceManager, bulletStartX, bulletStartY)
            if err != nil {
                log.Printf("[BehaviorSystem] 创建豌豆子弹失败: %v", err)
            }
            
            // 重置计时器
            timer.CurrentTime = 0
        }
    }
}

// triggerPlantAttackAnimation 触发植物攻击动画
// Story 10.3: 播放攻击动画并更新状态
func (s *BehaviorSystem) triggerPlantAttackAnimation(entityID ecs.EntityID, animName string) {
    // 获取植物组件
    plant, ok := ecs.GetComponent[*components.PlantComponent](s.entityManager, entityID)
    if !ok {
        return
    }
    
    // 播放攻击动画（非循环）
    err := s.reanimSystem.PlayAnimationNoLoop(entityID, animName)
    if err != nil {
        log.Printf("[BehaviorSystem] 播放植物攻击动画失败: %v", err)
        return
    }
    
    // 更新攻击动画状态
    plant.AttackAnimState = components.AttackAnimAttacking
    log.Printf("[BehaviorSystem] 植物 %d 触发攻击动画 '%s'", entityID, animName)
}

// updatePlantAttackAnimation 更新植物攻击动画状态
// Story 10.3: 检测攻击动画是否播放完毕，自动切换回空闲动画
func (s *BehaviorSystem) updatePlantAttackAnimation(deltaTime float64) {
    // 查询所有植物实体
    plantEntities := ecs.GetEntitiesWith2[
        *components.PlantComponent,
        *components.ReanimComponent,
    ](s.entityManager)
    
    for _, entityID := range plantEntities {
        plant, _ := ecs.GetComponent[*components.PlantComponent](s.entityManager, entityID)
        
        // 只处理正在播放攻击动画的植物
        if plant.AttackAnimState != components.AttackAnimAttacking {
            continue
        }
        
        // 检测攻击动画是否播放完毕
        if s.reanimSystem.IsAnimationFinished(entityID) {
            // 切换回空闲动画
            err := s.reanimSystem.PlayAnimation(entityID, "anim_idle", true)
            if err != nil {
                log.Printf("[BehaviorSystem] 切换植物空闲动画失败: %v", err)
            }
            
            // 更新状态
            plant.AttackAnimState = components.AttackAnimIdle
            log.Printf("[BehaviorSystem] 植物 %d 攻击动画播放完毕，切换回空闲动画", entityID)
        }
    }
}
```

#### BehaviorSystem.Update() 集成
[Location: pkg/systems/behavior_system.go]

```go
func (s *BehaviorSystem) Update(deltaTime float64) {
    // ... 现有的行为处理逻辑 ...
    
    // Story 10.3: 更新植物攻击动画状态（在所有行为处理之后）
    s.updatePlantAttackAnimation(deltaTime)
}
```

#### ReanimSystem API 使用
[Source: pkg/systems/reanim_system.go]

```go
// PlayAnimationNoLoop 播放非循环动画
func (rs *ReanimSystem) PlayAnimationNoLoop(entityID ecs.EntityID, animName string) error {
    return rs.PlayAnimation(entityID, animName, false)
}

// IsAnimationFinished 检测非循环动画是否播放完毕
func (rs *ReanimSystem) IsAnimationFinished(entityID ecs.EntityID) bool {
    reanim, ok := ecs.GetComponent[*components.ReanimComponent](rs.entityManager, entityID)
    if !ok {
        return false
    }
    return reanim.IsFinished
}

// PlayAnimation 播放动画
func (rs *ReanimSystem) PlayAnimation(entityID ecs.EntityID, animName string, loop bool) error {
    // 实现逻辑...
}
```

### Reanim 动画资源
[Source: assets/effect/reanim/]

**豌豆射手动画**:
- 文件：`peashooter.reanim`
- 空闲动画：`anim_idle`（循环播放）
- 攻击动画：`anim_shooting`（非循环，约 0.3-0.5 秒）

**未来扩展**:
- 寒冰射手：`snowpea.reanim` → `anim_shooting`
- 双发射手：`repeater.reanim` → `anim_shooting`
- 卷心菜投手：`cabbagepult.reanim` → `anim_shooting`

### 植物类型识别
[Source: pkg/components/plant_component.go]

```go
// 射手类植物列表（用于判断是否需要攻击动画）
var shooterPlants = map[string]bool{
    "peashooter": true,
    "snowpea":    true,
    "repeater":   true,
    "cabbagepult": true,
    // ... 其他射手植物 ...
}

// IsShooterPlant 判断植物是否是射手类
func IsShooterPlant(plantType string) bool {
    return shooterPlants[plantType]
}
```

### ECS 泛型 API 使用
[Source: pkg/ecs/generics.go]

```go
// 查询所有植物实体
plantEntities := ecs.GetEntitiesWith2[
    *components.PlantComponent,
    *components.ReanimComponent,
](em)

// 获取植物组件
plant, ok := ecs.GetComponent[*components.PlantComponent](em, entity)

// 更新植物攻击动画状态
plant.AttackAnimState = components.AttackAnimAttacking
```

### Coding Standards
[Source: docs/architecture/coding-standards.md]

1. **ECS 零耦合原则**: BehaviorSystem 通过 ReanimSystem 接口操作动画，不直接访问 ReanimComponent
2. **泛型 API 优先**: 使用 Epic 9 的泛型 ECS API
3. **组件只包含数据**: PlantComponent 不包含任何方法
4. **错误处理**: 动画播放失败时记录日志但不中断游戏
5. **配置驱动**: 攻击动画名称可配置（如果需要）

### Testing

#### 测试标准
[Source: docs/architecture/testing-strategy.md]

**单元测试**:
- 测试文件位置: `pkg/systems/behavior_system_test.go`
- 测试 `triggerPlantAttackAnimation()` 方法
- 测试 `updatePlantAttackAnimation()` 方法
- 测试攻击动画状态转换逻辑
- Mock ReanimSystem 接口

**集成测试**:
- 创建豌豆射手实体
- 生成僵尸触发发射
- 验证攻击动画自动播放
- 验证动画播放完毕后切换回空闲
- 验证攻击动画期间不会再次触发

**手动测试**:
- 运行游戏，种植豌豆射手
- 生成僵尸，观察豌豆射手发射时的动画
- 验证动画播放自然流畅
- 验证向日葵等非射手植物行为不变

#### 测试框架
- 使用 Go 标准库 `testing` 包
- 使用 `go test ./...` 运行所有测试
- 目标覆盖率: 80%+

### Performance Considerations

- **状态检查优化**: 只在攻击动画状态为 `Attacking` 时检测动画完成
- **避免频繁查询**: 缓存 ReanimSystem 引用，避免每次都通过 EntityManager 查询
- **动画切换开销**: Reanim 动画切换是轻量级操作，性能影响可忽略
- **批量处理**: `updatePlantAttackAnimation()` 批量处理所有植物，提高效率

### Design Decisions

**为什么不使用事件系统？**
- 当前项目未实现 EventBus，使用状态机更简单直接
- 攻击动画状态与植物行为紧密耦合，不需要跨系统通信

**为什么在 PlantComponent 中添加状态字段？**
- 符合 ECS 架构，组件存储数据，系统处理逻辑
- 便于查询和调试，状态一目了然

**为什么不影响子弹发射计时器？**
- 攻击动画是视觉表现，不应改变游戏机制
- 保持原版游戏的攻击节奏和平衡性

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used

*(To be filled by dev agent)*

### Debug Log References

*(To be filled by dev agent)*

### Completion Notes

*(To be filled by dev agent)*

### File List

*(To be filled by dev agent)*

## QA Results

*(This section will be populated by the QA agent after implementation)*

