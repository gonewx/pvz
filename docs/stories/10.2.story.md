# Story 10.2: 除草车最后防线系统

## Status
Draft

## Story
**As a** 玩家,
**I want** lawnmowers as a last line of defense on each lane,
**so that** I have one final chance to stop zombies from reaching my house.

## Acceptance Criteria
1. 游戏开始时，每个有效行的左侧台阶上放置一辆除草车。
2. 除草车正确显示在对应行的左侧，使用原版除草车图像和动画。
3. 当僵尸到达屏幕左侧边界（X < 100）时，该行的除草车自动触发。
4. 除草车触发后从左向右快速移动（速度约 300 像素/秒），播放行驶动画。
5. 除草车移动过程中，消灭路径上所在行的所有僵尸，僵尸播放死亡动画。
6. 除草车移动到屏幕右侧后消失（X > 背景宽度），该行除草车标记为已使用。
7. 除草车触发时播放对应的音效（lawnmower.ogg）。
8. 除草车使用后，该行再有僵尸到达左侧边界（X < 100）则游戏失败。
9. 所有行的除草车都用完后，任意僵尸到达左侧边界直接失败（无最后防线）。
10. 除草车状态在游戏重启时正确重置（所有除草车恢复未使用状态）。

## Tasks / Subtasks

- [ ] Task 1: 创建除草车组件 (AC: 1, 2, 6)
  - [ ] 在 `pkg/components/` 创建 `LawnmowerComponent` 组件
  - [ ] 字段包括：Lane (int), IsTriggered (bool), IsMoving (bool), Speed (float64), IsUsed (bool)
  - [ ] 在 `pkg/components/` 创建 `LawnmowerStateComponent` 跟踪全局除草车状态
  - [ ] 字段包括：UsedLanes (map[int]bool) 记录每行除草车是否已使用

- [ ] Task 2: 创建除草车实体工厂 (AC: 1, 2)
  - [ ] 在 `pkg/entities/` 创建 `lawnmower_factory.go`
  - [ ] 实现 `NewLawnmowerEntity(em, rm, rs, lane)` 工厂函数
  - [ ] 加载原版除草车资源（Reanim 动画：`lawnmower.reanim`）
  - [ ] 计算除草车位置：X = config.LawnmowerStartX，Y = 对应行的中心Y坐标
  - [ ] 添加必要组件：PositionComponent, ReanimComponent, LawnmowerComponent, VelocityComponent

- [ ] Task 3: 初始化除草车实体 (AC: 1)
  - [ ] 在 `GameScene.initLawnmowers()` 方法中为每个有效行创建除草车
  - [ ] 从 `levelConfig.EnabledLanes` 读取有效行列表
  - [ ] 为每个有效行调用 `entities.NewLawnmowerEntity()`
  - [ ] 将除草车实体ID存储在 GameScene 或全局状态中

- [ ] Task 4: 创建除草车系统 (AC: 3, 4, 5, 6, 7)
  - [ ] 在 `pkg/systems/` 创建 `lawnmower_system.go`
  - [ ] 实现 `LawnmowerSystem` 结构体和 `NewLawnmowerSystem()` 构造函数
  - [ ] 实现 `Update(deltaTime)` 方法：
    - 检测触发条件（僵尸 X < 100）
    - 触发除草车（设置 IsMoving = true，播放音效）
    - 更新除草车位置（X += Speed * deltaTime）
    - 检测并消灭路径上的僵尸
    - 检测除草车离开屏幕（X > 背景宽度），标记为已使用

- [ ] Task 5: 实现除草车触发逻辑 (AC: 3, 7)
  - [ ] 在 `LawnmowerSystem.checkTriggerConditions()` 中检测每行是否有僵尸到达左侧
  - [ ] 查询所有僵尸实体（BehaviorComponent + PositionComponent）
  - [ ] 筛选 X < DefeatBoundaryX (100.0) 的僵尸
  - [ ] 根据僵尸所在行触发对应除草车
  - [ ] 播放音效：`rm.PlayAudio("SOUND_LAWNMOWER")`
  - [ ] 切换除草车动画为行驶状态

- [ ] Task 6: 实现僵尸消灭逻辑 (AC: 5)
  - [ ] 在 `LawnmowerSystem.checkZombieCollisions()` 中检测除草车与僵尸碰撞
  - [ ] 对于每个移动中的除草车，查询同行的所有僵尸
  - [ ] 碰撞检测：僵尸 X 坐标在除草车 X ± 50 范围内
  - [ ] 触发僵尸死亡：将僵尸生命值设为 0，触发 BehaviorSystem 的死亡逻辑
  - [ ] 增加已消灭僵尸计数（GameState.IncrementZombiesKilled()）

- [ ] Task 7: 增强失败条件检测 (AC: 8, 9)
  - [ ] 修改 `LevelSystem.checkDefeatCondition()` 方法
  - [ ] 检测僵尸到达左侧时，先检查该行除草车是否已使用
  - [ ] 如果除草车未使用，不触发失败（让除草车触发）
  - [ ] 如果除草车已使用，触发游戏失败
  - [ ] 逻辑：`if zombieX < DefeatBoundaryX && lawnmowerUsed[lane] { gameLose() }`

- [ ] Task 8: 实现除草车状态重置 (AC: 10)
  - [ ] 在 `GameScene.Reset()` 或关卡重新加载时重置除草车状态
  - [ ] 删除所有旧除草车实体
  - [ ] 重新调用 `initLawnmowers()` 创建新除草车
  - [ ] 重置 LawnmowerStateComponent 的 UsedLanes 映射

- [ ] Task 9: 配置常量管理 (AC: 2, 4)
  - [ ] 在 `pkg/config/` 添加除草车相关配置常量
  - [ ] `LawnmowerStartX float64 = 50.0` - 除草车初始X位置
  - [ ] `LawnmowerSpeed float64 = 300.0` - 除草车移动速度（像素/秒）
  - [ ] `LawnmowerTriggerBoundary float64 = 100.0` - 触发边界（与 DefeatBoundaryX 一致）
  - [ ] `LawnmowerDeletionBoundary float64` - 删除边界（背景宽度）

- [ ] Task 10: 资源加载和音效集成 (AC: 2, 7)
  - [ ] 在 `assets/config/resources.yaml` 添加除草车资源配置
  - [ ] 图片资源：`IMAGE_LAWNMOWER` → `assets/reanim/lawnmower/...`
  - [ ] Reanim 动画：`assets/effect/reanim/lawnmower.reanim`
  - [ ] 音效资源：`SOUND_LAWNMOWER` → `assets/sounds/lawnmower.ogg`
  - [ ] 在 `ResourceManager` 中加载除草车资源

- [ ] Task 11: 集成到 GameScene (所有 AC)
  - [ ] 在 `GameScene.initSystems()` 中创建 LawnmowerSystem
  - [ ] 在 `GameScene.Update()` 中更新 LawnmowerSystem
  - [ ] 在 `GameScene.Draw()` 中渲染除草车（通过 RenderSystem）
  - [ ] 确保除草车在正确的渲染层级（背景之上，植物之下）

- [ ] Task 12: 测试和验证 (所有 AC)
  - [ ] 测试除草车正确显示在每行左侧
  - [ ] 测试僵尸到达左侧时除草车自动触发
  - [ ] 测试除草车移动和僵尸消灭逻辑
  - [ ] 测试除草车用完后游戏失败逻辑
  - [ ] 测试关卡重启时除草车状态重置

## Dev Notes

### Previous Story Insights
[Source: docs/stories/5.5.story.md#Dev Agent Record]

从 Story 5.5 的实施中学到的关键经验：
1. **LevelSystem 架构**: LevelSystem 负责检测胜利/失败条件，通过 `checkDefeatCondition()` 方法
2. **失败边界**: 使用常量 `DefeatBoundaryX = 100.0` 作为僵尸到达左侧的判定边界
3. **GameState 管理**: 游戏状态通过 `GameState.SetGameResult("lose")` 设置失败
4. **僵尸查询**: 使用泛型 ECS API 查询所有僵尸实体：`ecs.GetEntitiesWith2[*BehaviorComponent, *PositionComponent]`
5. **音效播放**: 通过 `ResourceManager.PlayAudio()` 播放音效

**本 Story 重点**:
- AC 1-2: 创建除草车组件和工厂，初始化除草车实体
- AC 3: 实现除草车触发条件检测（僵尸 X < 100）
- AC 4-6: 实现除草车移动和僵尸消灭逻辑
- AC 7: 播放除草车音效
- AC 8-9: 增强失败条件检测，考虑除草车状态
- AC 10: 实现除草车状态重置

### Relevant Architecture

#### 新增组件
[Location: pkg/components/lawnmower_component.go]

```go
// LawnmowerComponent - 除草车组件
type LawnmowerComponent struct {
    Lane        int      // 所在行（1-5，与EnabledLanes一致）
    IsTriggered bool     // 是否已触发（僵尸到达左侧）
    IsMoving    bool     // 是否正在移动
    Speed       float64  // 移动速度（像素/秒），默认 300.0
}

// LawnmowerStateComponent - 全局除草车状态组件
// 挂载在一个全局实体上，跟踪所有行的除草车使用状态
type LawnmowerStateComponent struct {
    UsedLanes map[int]bool  // 键：行号（1-5），值：是否已使用
}
```

#### 新增系统
[Location: pkg/systems/lawnmower_system.go]

```go
// LawnmowerSystem - 除草车系统
// 职责：
// - 检测触发条件（僵尸到达左侧边界）
// - 触发除草车移动
// - 更新除草车位置
// - 检测并消灭路径上的僵尸
// - 管理除草车状态（未触发/移动中/已使用）
type LawnmowerSystem struct {
    entityManager   *ecs.EntityManager
    resourceManager *game.ResourceManager  // 用于播放音效
    stateEntityID   ecs.EntityID           // 全局状态实体ID
}

func NewLawnmowerSystem(em *ecs.EntityManager, rm *game.ResourceManager) *LawnmowerSystem {
    // 创建全局状态实体
    stateEntity := em.CreateEntity()
    em.AddComponent(stateEntity, &components.LawnmowerStateComponent{
        UsedLanes: make(map[int]bool),
    })
    
    return &LawnmowerSystem{
        entityManager:   em,
        resourceManager: rm,
        stateEntityID:   stateEntity,
    }
}

func (s *LawnmowerSystem) Update(deltaTime float64) {
    // 1. 检测触发条件
    s.checkTriggerConditions()
    
    // 2. 更新移动中的除草车位置
    s.updateLawnmowerPositions(deltaTime)
    
    // 3. 检测并消灭僵尸
    s.checkZombieCollisions()
    
    // 4. 检测除草车离开屏幕
    s.checkLawnmowerCompletion()
}

// checkTriggerConditions 检测是否有僵尸到达左侧，触发除草车
func (s *LawnmowerSystem) checkTriggerConditions() {
    // 查询所有僵尸实体
    zombieEntities := ecs.GetEntitiesWith2[
        *components.BehaviorComponent,
        *components.PositionComponent,
    ](s.entityManager)
    
    for _, zombieID := range zombieEntities {
        behavior, _ := ecs.GetComponent[*components.BehaviorComponent](s.entityManager, zombieID)
        pos, _ := ecs.GetComponent[*components.PositionComponent](s.entityManager, zombieID)
        
        // 只检查僵尸类型
        if !isZombieType(behavior.Type) {
            continue
        }
        
        // 僵尸到达左侧边界
        if pos.X < config.LawnmowerTriggerBoundary {
            // 计算僵尸所在行
            lane := s.getZombieLane(pos.Y)
            
            // 触发该行的除草车
            s.triggerLawnmower(lane)
        }
    }
}

// triggerLawnmower 触发指定行的除草车
func (s *LawnmowerSystem) triggerLawnmower(lane int) {
    // 查询该行的除草车
    lawnmowers := ecs.GetEntitiesWith2[
        *components.LawnmowerComponent,
        *components.PositionComponent,
    ](s.entityManager)
    
    for _, lawnmowerID := range lawnmowers {
        lawnmower, _ := ecs.GetComponent[*components.LawnmowerComponent](s.entityManager, lawnmowerID)
        
        if lawnmower.Lane == lane && !lawnmower.IsTriggered {
            // 触发除草车
            lawnmower.IsTriggered = true
            lawnmower.IsMoving = true
            
            // 播放音效
            s.resourceManager.PlayAudio("SOUND_LAWNMOWER")
            
            // 切换动画为移动状态
            if reanim, ok := ecs.GetComponent[*components.ReanimComponent](s.entityManager, lawnmowerID); ok {
                reanim.ChangeAnimation("anim_moving")
            }
            
            log.Printf("[LawnmowerSystem] Lawnmower triggered on lane %d", lane)
            break
        }
    }
}

// updateLawnmowerPositions 更新移动中的除草车位置
func (s *LawnmowerSystem) updateLawnmowerPositions(deltaTime float64) {
    lawnmowers := ecs.GetEntitiesWith2[
        *components.LawnmowerComponent,
        *components.PositionComponent,
    ](s.entityManager)
    
    for _, lawnmowerID := range lawnmowers {
        lawnmower, _ := ecs.GetComponent[*components.LawnmowerComponent](s.entityManager, lawnmowerID)
        pos, _ := ecs.GetComponent[*components.PositionComponent](s.entityManager, lawnmowerID)
        
        if lawnmower.IsMoving {
            // 向右移动
            pos.X += lawnmower.Speed * deltaTime
        }
    }
}

// checkZombieCollisions 检测除草车与僵尸的碰撞，消灭僵尸
func (s *LawnmowerSystem) checkZombieCollisions() {
    // 实现碰撞检测和僵尸消灭逻辑
}

// checkLawnmowerCompletion 检测除草车是否离开屏幕
func (s *LawnmowerSystem) checkLawnmowerCompletion() {
    // 检测 X > 背景宽度，标记为已使用并删除实体
}
```

#### LevelSystem 修改
[Location: pkg/systems/level_system.go]

```go
// checkDefeatCondition 修改失败条件检测
func (s *LevelSystem) checkDefeatCondition() {
    // 获取除草车状态
    lawnmowerState, ok := ecs.GetComponent[*components.LawnmowerStateComponent](s.entityManager, s.lawnmowerStateEntityID)
    if !ok {
        // 如果没有除草车状态组件，使用原逻辑
        s.checkDefeatConditionOriginal()
        return
    }
    
    // 查询所有僵尸实体
    zombieEntities := ecs.GetEntitiesWith2[
        *components.BehaviorComponent,
        *components.PositionComponent,
    ](s.entityManager)
    
    for _, entityID := range zombieEntities {
        behavior, _ := ecs.GetComponent[*components.BehaviorComponent](s.entityManager, entityID)
        pos, _ := ecs.GetComponent[*components.PositionComponent](s.entityManager, entityID)
        
        if !isZombieType(behavior.Type) {
            continue
        }
        
        // 僵尸到达左边界
        if pos.X < DefeatBoundaryX {
            // 计算僵尸所在行
            lane := s.getZombieLane(pos.Y)
            
            // 检查该行除草车是否已使用
            if lawnmowerState.UsedLanes[lane] {
                // 除草车已使用，游戏失败
                s.gameState.SetGameResult("lose")
                log.Printf("[LevelSystem] Defeat! Zombie reached left boundary on lane %d (lawnmower used)", lane)
                return
            } else {
                // 除草车未使用，不触发失败（让除草车触发）
                log.Printf("[LevelSystem] Zombie reached left boundary on lane %d, waiting for lawnmower", lane)
            }
        }
    }
}
```

#### 配置常量
[Location: pkg/config/layout_config.go]

```go
const (
    // 除草车配置
    LawnmowerStartX          = 50.0   // 除草车初始X位置（左侧台阶）
    LawnmowerSpeed           = 300.0  // 除草车移动速度（像素/秒）
    LawnmowerTriggerBoundary = 100.0  // 触发边界（与DefeatBoundaryX一致）
    LawnmowerWidth           = 80.0   // 除草车宽度（用于碰撞检测）
    LawnmowerHeight          = 60.0   // 除草车高度
    LawnmowerCollisionRange  = 50.0   // 碰撞检测范围（像素）
)
```

#### 实体工厂
[Location: pkg/entities/lawnmower_factory.go]

```go
// NewLawnmowerEntity 创建除草车实体
// 参数:
//   - em: EntityManager 实例
//   - rm: ResourceManager 实例
//   - rs: ReanimSystem 实例
//   - lane: 所在行（1-5）
// 返回:
//   - ecs.EntityID: 除草车实体ID
//   - error: 创建错误
func NewLawnmowerEntity(
    em *ecs.EntityManager,
    rm *game.ResourceManager,
    rs *ReanimSystem,
    lane int,
) (ecs.EntityID, error) {
    // 创建实体
    entityID := em.CreateEntity()
    
    // 计算位置
    posX := config.LawnmowerStartX
    posY := config.GridWorldStartY + float64(lane-1)*config.CellHeight + config.CellHeight/2
    
    // 添加位置组件
    ecs.AddComponent(em, entityID, &components.PositionComponent{
        X: posX,
        Y: posY,
    })
    
    // 加载 Reanim 动画
    reanimDef, err := rm.LoadReanimByID("REANIM_LAWNMOWER")
    if err != nil {
        return 0, fmt.Errorf("failed to load lawnmower reanim: %w", err)
    }
    
    // 添加 Reanim 组件
    reanimComp := rs.CreateReanimComponent(reanimDef, "anim_idle")
    ecs.AddComponent(em, entityID, reanimComp)
    
    // 添加除草车组件
    ecs.AddComponent(em, entityID, &components.LawnmowerComponent{
        Lane:        lane,
        IsTriggered: false,
        IsMoving:    false,
        Speed:       config.LawnmowerSpeed,
    })
    
    log.Printf("[LawnmowerFactory] Created lawnmower entity %d on lane %d at (%.1f, %.1f)",
        entityID, lane, posX, posY)
    
    return entityID, nil
}
```

### Resource Configuration
[Location: assets/config/resources.yaml]

**建议添加以下资源配置**:
```yaml
groups:
  game:
    images:
      - id: IMAGE_REANIM_LAWNMOWER
        path: reanim/lawnmower/lawnmower.png
    
    reanim:
      - id: REANIM_LAWNMOWER
        path: effect/reanim/lawnmower.reanim
    
    sounds:
      - id: SOUND_LAWNMOWER
        path: sounds/lawnmower.ogg
```

### ECS 泛型 API 使用
[Source: pkg/ecs/generics.go]

```go
// 查询所有除草车实体
lawnmowers := ecs.GetEntitiesWith2[
    *components.LawnmowerComponent,
    *components.PositionComponent,
](em)

// 获取除草车组件
lawnmower, ok := ecs.GetComponent[*components.LawnmowerComponent](em, entity)

// 添加除草车组件
ecs.AddComponent(em, entity, &components.LawnmowerComponent{
    Lane:        lane,
    IsTriggered: false,
    IsMoving:    false,
    Speed:       300.0,
})

// 获取全局除草车状态
state, ok := ecs.GetComponent[*components.LawnmowerStateComponent](em, stateEntity)
```

### Coding Standards
[Source: docs/architecture/coding-standards.md]

1. **ECS 零耦合原则**: LawnmowerSystem 不直接调用 BehaviorSystem，通过修改僵尸生命值触发死亡
2. **泛型 API 优先**: 使用 Epic 9 的泛型 ECS API
3. **组件只包含数据**: LawnmowerComponent 不包含任何方法
4. **错误处理**: 工厂函数必须返回 error 并检查
5. **配置常量**: 所有魔法数字（速度、位置等）放在 config 包中

### Testing

#### 测试标准
[Source: docs/architecture/testing-strategy.md]

**单元测试**:
- 测试文件位置: `pkg/systems/lawnmower_system_test.go`
- 测试除草车触发条件检测
- 测试除草车移动逻辑
- 测试僵尸碰撞检测
- 测试除草车状态管理

**集成测试**:
- 创建完整的 GameScene 实例
- 生成僵尸并移动到左侧边界
- 验证除草车自动触发
- 验证僵尸被消灭
- 验证除草车用完后游戏失败

**手动测试**:
- 运行游戏，观察每行左侧的除草车
- 等待或强制僵尸到达左侧
- 验证除草车触发、移动和僵尸消灭
- 验证除草车用完后失败逻辑
- 重启关卡，验证除草车状态重置

#### 测试框架
- 使用 Go 标准库 `testing` 包
- 使用 `go test ./...` 运行所有测试
- 目标覆盖率: 80%+

### Performance Considerations

- **碰撞检测优化**: 只检测移动中的除草车与同行僵尸的碰撞
- **状态查询缓存**: 缓存 LawnmowerStateComponent 引用，避免每帧查询
- **音效限流**: 同一除草车只触发一次音效
- **实体清理**: 除草车离开屏幕后及时删除实体，释放资源

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used

*(To be filled by dev agent)*

### Debug Log References

*(To be filled by dev agent)*

### Completion Notes

*(To be filled by dev agent)*

### File List

*(To be filled by dev agent)*

## QA Results

*(This section will be populated by the QA agent after implementation)*

