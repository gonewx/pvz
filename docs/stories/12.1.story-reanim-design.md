# Story 12.1 - 方式B实现：基于 SelectorScreen.reanim 的石碑菜单系统

> **技术设计文档**
>
> 创建日期：2025-11-01
> 设计方法：使用 Reanim 动画系统而非独立图片

---

## 一、设计概述

### 1.1 核心思路

**不使用独立按钮图片**，而是：
1. 加载完整的 `SelectorScreen.reanim` 动画到主菜单场景
2. 播放 `anim_idle` 动画（显示所有菜单元素）
3. 根据游戏进度动态控制按钮轨道的可见性（`VisibleTracks`）
4. 手动实现按钮点击检测（基于 Reanim 中的按钮位置）
5. 在 Reanim 动画之上叠加关卡进度数字（使用精灵图）

### 1.2 优势

✅ **完全还原原版效果**：
- 自动获得原版的布局和动画
- 云朵飘动、花朵摆动等装饰动画自动播放
- 按钮升起动画（`anim_open`）免费获得

✅ **减少维护成本**：
- 无需手动计算按钮位置
- 按钮布局由 Reanim 定义，修改配置即可调整
- 所有装饰元素（云朵、花朵、木牌）都已定义

✅ **符合项目架构**：
- 复用已有的 ReanimSystem（Epic 6）
- 遵循 ECS 架构原则
- 与其他 Reanim 实体（植物、僵尸）一致

---

## 二、按钮位置和尺寸数据

### 2.1 按钮在 Reanim 中的位置

从 `SelectorScreen.reanim` 提取的按钮最终位置（动画播放完后）：

| 按钮轨道名 | X坐标 | Y坐标（最终） | 对应模式 | 实际使用图片 |
|-----------|------|-------------|---------|-------------|
| `SelectorScreen_Adventure_button` | 405 | 79.7 | 冒险模式 | Adventure_button |
| `SelectorScreen_Survival_button` | 406 | 173.1 | 玩玩小游戏 | Survival_button |
| `SelectorScreen_Challenges_button` | 410 | 257.5 | 解谜模式 | Challenges_button |
| `SelectorScreen_ZenGarden_button` | 413 | 328.0 | 生存模式 | Vasebreaker_button |

**注意**：
- Y坐标是按钮动画结束后的静止位置
- X坐标基本一致（左右居中）
- 按钮间距约 93 像素
- **重要**：Reanim 轨道名称与实际模式不对应！需要在代码中正确映射图片资源

### 2.1.5 轨道与模式的映射关系

**关键发现**：`SelectorScreen.reanim` 中的轨道名称与实际游戏模式**不一致**！

| Reanim 轨道名称 | 实际游戏模式 | 使用的图片资源 |
|---------------|------------|--------------|
| `SelectorScreen_Adventure_button` | 冒险模式 | `IMAGE_REANIM_SELECTORSCREEN_ADVENTURE_*` ✅ |
| `SelectorScreen_Survival_button` | 玩玩小游戏 | `IMAGE_REANIM_SELECTORSCREEN_SURVIVAL_*` ⚠️ |
| `SelectorScreen_Challenges_button` | 解谜模式 | `IMAGE_REANIM_SELECTORSCREEN_CHALLENGES_*` ⚠️ |
| `SelectorScreen_ZenGarden_button` | 生存模式 | `IMAGE_REANIM_SELECTORSCREEN_VASEBREAKER_*` ⚠️ |

**实现策略**：
- Reanim 系统按轨道名称渲染（位置正确）
- 图片资源通过 `PartImages` 映射（已在 `resources.yaml` 中正确配置）
- 点击检测使用 `MenuButtonType` 枚举（与游戏模式对应）
- 轨道到模式的映射关系硬编码在 `MenuButtonHitboxes` 配置中

### 2.2 按钮点击区域（Hitbox）

```go
// 按钮点击区域定义
type MenuButtonHitbox struct {
    TrackName  string          // Reanim 轨道名称
    ButtonType MenuButtonType  // 对应的游戏模式
    X          float64         // 左上角 X 坐标
    Y          float64         // 左上角 Y 坐标
    Width      float64         // 宽度
    Height     float64         // 高度
}

var MenuButtonHitboxes = []MenuButtonHitbox{
    {
        TrackName:  "SelectorScreen_Adventure_button",
        ButtonType: MenuButtonAdventure,  // 冒险模式
        X:          405,
        Y:          79.7,
        Width:      330,
        Height:     120,
    },
    {
        TrackName:  "SelectorScreen_Survival_button",
        ButtonType: MenuButtonChallenges,  // 玩玩小游戏（注意：轨道名称错位）
        X:          406,
        Y:          173.1,
        Width:      330,
        Height:     120,
    },
    {
        TrackName:  "SelectorScreen_Challenges_button",
        ButtonType: MenuButtonVasebreaker,  // 解谜模式（注意：轨道名称错位）
        X:          410,
        Y:          257.5,
        Width:      330,
        Height:     120,
    },
    {
        TrackName:  "SelectorScreen_ZenGarden_button",
        ButtonType: MenuButtonSurvival,  // 生存模式（注意：轨道名称错位）
        X:          413,
        Y:          328.0,
        Width:      330,
        Height:     120,
    },
}
```

---

## 三、技术实现方案

### 3.1 MainMenuScene 结构体修改

```go
// MainMenuScene 主菜单场景
type MainMenuScene struct {
    // ... 现有字段

    // Story 12.1: SelectorScreen Reanim 实体
    selectorScreenEntity ecs.EntityID      // SelectorScreen.reanim 实体
    reanimSystem        *ReanimSystem      // Reanim 系统引用

    // Story 12.1: 按钮状态管理
    buttonHitboxes      []MenuButtonHitbox // 按钮点击区域
    hoveredButton       string             // 当前悬停的按钮轨道名（空字符串表示无）
    currentLevel        string             // 当前最高关卡（从存档读取）

    // Story 12.2: 底部按钮
    bottomButtons       []ecs.EntityID

    // Story 12.3: 对话框
    currentDialog       ecs.EntityID
}
```

### 3.2 初始化流程

```go
// NewMainMenuScene 创建主菜单场景
func NewMainMenuScene(rm, sm) *MainMenuScene {
    scene := &MainMenuScene{
        // ... 初始化字段
    }

    // 1. 加载 SelectorScreen.reanim 实体
    scene.selectorScreenEntity = scene.createSelectorScreenEntity()

    // 2. 初始化按钮点击区域
    scene.buttonHitboxes = MenuButtonHitboxes

    // 3. 从存档读取当前关卡
    saveManager := game.GetGameState().GetSaveManager()
    if err := saveManager.Load(); err == nil {
        scene.currentLevel = saveManager.GetHighestLevel()
    } else {
        scene.currentLevel = "1-1"
    }

    // 4. 根据解锁状态设置按钮可见性
    scene.updateButtonVisibility()

    // 5. 播放动画
    scene.reanimSystem.PlayAnimation(scene.selectorScreenEntity, "anim_idle")

    return scene
}
```

### 3.3 创建 SelectorScreen 实体

```go
// createSelectorScreenEntity 创建 SelectorScreen Reanim 实体
func (m *MainMenuScene) createSelectorScreenEntity() ecs.EntityID {
    entity := m.entityManager.CreateEntity()

    // 1. 加载 Reanim 数据
    reanimData, err := reanim.LoadReanimFromFile("assets/effect/reanim/SelectorScreen.reanim")
    if err != nil {
        log.Fatalf("Failed to load SelectorScreen.reanim: %v", err)
    }

    // 2. 加载部件图片（Reanim 使用的所有图片）
    partImages := make(map[string]*ebiten.Image)

    // 加载按钮图片
    partImages["IMAGE_REANIM_SELECTORSCREEN_ADVENTURE_BUTTON"], _ =
        m.resourceManager.LoadImageByID("IMAGE_REANIM_SELECTORSCREEN_ADVENTURE_BUTTON")
    partImages["IMAGE_REANIM_SELECTORSCREEN_SURVIVAL_BUTTON"], _ =
        m.resourceManager.LoadImageByID("IMAGE_REANIM_SELECTORSCREEN_SURVIVAL_BUTTON")
    partImages["IMAGE_REANIM_SELECTORSCREEN_CHALLENGES_BUTTON"], _ =
        m.resourceManager.LoadImageByID("IMAGE_REANIM_SELECTORSCREEN_CHALLENGES_BUTTON")
    partImages["IMAGE_REANIM_SELECTORSCREEN_VASEBREAKER_BUTTON"], _ =
        m.resourceManager.LoadImageByID("IMAGE_REANIM_SELECTORSCREEN_VASEBREAKER_BUTTON")

    // 加载背景、云朵、花朵等其他图片
    // ... (根据 SelectorScreen.reanim 中引用的图片加载)

    // 3. 创建 ReanimComponent
    reanimComp := &components.ReanimComponent{
        Reanim:      reanimData,
        PartImages:  partImages,
        CurrentAnim: "",
        IsLooping:   true,
        IsPaused:    false,
    }
    ecs.AddComponent(m.entityManager, entity, reanimComp)

    // 4. 添加位置组件（SelectorScreen 在屏幕左侧）
    ecs.AddComponent(m.entityManager, entity, &components.PositionComponent{
        X: 0,  // SelectorScreen 的基准位置
        Y: 0,
    })

    return entity
}
```

### 3.4 动态控制按钮可见性

```go
// updateButtonVisibility 根据解锁状态更新按钮可见性
func (m *MainMenuScene) updateButtonVisibility() {
    reanimComp, ok := ecs.GetComponent[*components.ReanimComponent](
        m.entityManager, m.selectorScreenEntity)
    if !ok {
        return
    }

    // 构建 VisibleTracks 白名单
    visibleTracks := make(map[string]bool)

    // 1. 冒险模式按钮（始终显示）
    visibleTracks["SelectorScreen_Adventure_button"] = true
    visibleTracks["SelectorScreen_Adventure_shadow"] = true

    // 2. 玩玩小游戏按钮（3-2 后解锁）
    if m.isMenuModeUnlocked(MenuButtonChallenges) {
        visibleTracks["SelectorScreen_Challenges_button"] = true
        visibleTracks["SelectorScreen_Challenges_shadow"] = true
    }

    // 3. 生存模式按钮（5-10 后解锁）
    if m.isMenuModeUnlocked(MenuButtonSurvival) {
        visibleTracks["SelectorScreen_Survival_button"] = true
        visibleTracks["SelectorScreen_Survival_shadow"] = true
    }

    // 4. 解谜模式按钮（5-10 后解锁）
    if m.isMenuModeUnlocked(MenuButtonVasebreaker) {
        visibleTracks["SelectorScreen_ZenGarden_button"] = true
        visibleTracks["SelectorScreen_ZenGarden_shadow"] = true
    }

    // 5. 始终显示的装饰元素
    visibleTracks["SelectorScreen_BG"] = true
    visibleTracks["SelectorScreen_BG_Center"] = true
    visibleTracks["Cloud1"] = true
    visibleTracks["Cloud2"] = true
    // ... 其他装饰元素

    // 应用到 ReanimComponent
    reanimComp.VisibleTracks = visibleTracks
}

// isMenuModeUnlocked 判断菜单模式是否解锁
func (m *MainMenuScene) isMenuModeUnlocked(modeType MenuButtonType) bool {
    switch modeType {
    case MenuButtonAdventure:
        return true  // 始终解锁
    case MenuButtonChallenges:
        return m.compareLevels(m.currentLevel, "3-2") >= 0
    case MenuButtonSurvival, MenuButtonVasebreaker:
        return m.compareLevels(m.currentLevel, "5-10") >= 0
    default:
        return false
    }
}
```

### 3.5 按钮点击检测

```go
// Update 更新主菜单场景
func (m *MainMenuScene) Update(deltaTime float64) {
    // ... 背景音乐等逻辑

    // 获取鼠标状态
    mouseX, mouseY := ebiten.CursorPosition()
    isMousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)
    isMouseClicked := isMousePressed && !m.wasMousePressed

    // 检测按钮悬停和点击
    m.hoveredButton = ""
    for _, hitbox := range m.buttonHitboxes {
        if m.isPointInHitbox(float64(mouseX), float64(mouseY), hitbox) {
            m.hoveredButton = hitbox.TrackName

            if isMouseClicked {
                m.onMenuButtonClicked(hitbox.TrackName)
            }
            break
        }
    }

    // 更新 Reanim 动画（切换高亮状态）
    m.updateButtonHighlight()

    m.wasMousePressed = isMousePressed
}

// isPointInHitbox 检测点是否在按钮区域内
func (m *MainMenuScene) isPointInHitbox(x, y float64, hitbox MenuButtonHitbox) bool {
    return x >= hitbox.X && x < hitbox.X+hitbox.Width &&
           y >= hitbox.Y && y < hitbox.Y+hitbox.Height
}

// updateButtonHighlight 更新按钮高亮状态
func (m *MainMenuScene) updateButtonHighlight() {
    reanimComp, ok := ecs.GetComponent[*components.ReanimComponent](
        m.entityManager, m.selectorScreenEntity)
    if !ok {
        return
    }

    // 方案A：切换图片资源（使用 highlight 图片）
    if m.hoveredButton != "" {
        // 将悬停的按钮图片替换为 highlight 版本
        baseTrack := m.hoveredButton
        highlightImageID := getHighlightImageID(baseTrack)

        if highlightImg, ok := m.resourceManager.LoadImageByID(highlightImageID); ok == nil {
            reanimComp.PartImages[getImageRefName(baseTrack)] = highlightImg
        }
    } else {
        // 恢复所有按钮为正常图片
        m.restoreNormalButtonImages(reanimComp)
    }

    // 方案B：使用颜色叠加（更简单，但效果可能不如原版）
    // 在 RenderSystem 中实现颜色叠加逻辑
}

// onMenuButtonClicked 按钮点击回调
func (m *MainMenuScene) onMenuButtonClicked(trackName string) {
    buttonType := m.getButtonTypeFromTrack(trackName)
    isUnlocked := m.isMenuModeUnlocked(buttonType)

    // 播放点击音效
    m.playButtonClickSound()

    if !isUnlocked {
        // 显示未解锁对话框（依赖 Story 12.3）
        m.showUnlockedDialog(buttonType)
        return
    }

    // 已解锁，执行跳转逻辑
    switch buttonType {
    case MenuButtonAdventure:
        m.sceneManager.SwitchToScene("game")
    case MenuButtonChallenges:
        // TODO: 跳转到小游戏列表
        log.Println("[MainMenu] Challenges mode - Not yet implemented")
    case MenuButtonVasebreaker:
        // TODO: 跳转到解谜模式
        log.Println("[MainMenu] Vasebreaker mode - Not yet implemented")
    case MenuButtonSurvival:
        // TODO: 跳转到生存模式
        log.Println("[MainMenu] Survival mode - Not yet implemented")
    }
}
```

### 3.6 关卡进度数字渲染

关卡进度数字**不在 Reanim 中**，需要在 `Draw()` 方法中叠加渲染：

```go
// Draw 绘制主菜单场景
func (m *MainMenuScene) Draw(screen *ebiten.Image) {
    // 1. ReanimSystem 会自动绘制 SelectorScreen.reanim
    //    （包括背景、云朵、花朵、按钮等）

    // 2. 叠加关卡进度数字（在冒险模式按钮下方）
    m.drawLevelProgress(screen)

    // 3. 绘制底部按钮（Story 12.2）
    m.drawBottomButtons(screen)

    // 4. 绘制对话框（Story 12.3）
    if m.currentDialog != 0 {
        // DialogRenderSystem 会绘制对话框
    }
}

// drawLevelProgress 绘制关卡进度数字
func (m *MainMenuScene) drawLevelProgress(screen *ebiten.Image) {
    if m.currentLevel == "" {
        return
    }

    // 冒险模式按钮的位置
    adventureButtonX := 405.0
    adventureButtonY := 79.7
    adventureButtonHeight := 120.0

    // 关卡进度显示在按钮下方中央
    progressX := adventureButtonX + 165  // 按钮宽度330的一半
    progressY := adventureButtonY + adventureButtonHeight + 10

    // 使用精灵图渲染 "LEVEL 1-4"
    m.renderLevelNumbers(screen, m.currentLevel, progressX, progressY)
}
```

---

## 四、关键技术点

### 4.1 按钮高亮的两种实现方式

**方式A：切换图片资源（推荐）**
- 悬停时：将 `PartImages` 中的按钮图片替换为 `*_highlight` 版本
- 优点：效果完全还原原版
- 缺点：需要动态修改 `PartImages`

**方式B：颜色叠加**
- 悬停时：在 `RenderSystem` 中对按钮图片应用颜色滤镜
- 优点：实现简单
- 缺点：效果可能不如原版

### 4.2 与 ReanimSystem 的集成

SelectorScreen 实体完全由 ReanimSystem 管理：
- `ReanimSystem.Update()` 更新动画帧
- `ReanimSystem.Draw()` 渲染所有轨道
- `MainMenuScene` 只负责：
  - 控制 `VisibleTracks`
  - 检测按钮点击
  - 叠加关卡进度数字

### 4.3 动画序列

1. **打开动画**（可选）：
   - 播放 `anim_open`：按钮从下往上升起
   - 持续时间：约0.5-1秒
   - 完成后切换到 `anim_idle`

2. **待机动画**：
   - 播放 `anim_idle`：显示所有元素，云朵飘动
   - 循环播放

3. **悬停效果**：
   - 不播放新动画，只切换图片资源

---

## 五、与 Story 12.2 和 12.3 的协同

### Story 12.2（底部功能栏）
- 独立于 SelectorScreen.reanim
- 使用独立图片 + ECS 实体
- 无冲突

### Story 12.3（对话框系统）
- 对话框覆盖在 SelectorScreen 之上
- 对话框打开时拦截所有输入
- 无冲突

---

## 六、实施优先级

**阶段1：基础功能**（必须）
1. 加载 SelectorScreen.reanim 实体
2. 播放 `anim_idle` 动画
3. 根据解锁状态控制按钮可见性
4. 实现按钮点击检测

**阶段2：交互完善**（重要）
5. 实现按钮高亮效果
6. 渲染关卡进度数字
7. 集成 Story 12.3 的对话框

**阶段3：视觉优化**（可选）
8. 播放 `anim_open` 打开动画
9. 优化云朵飘动效果
10. 调试按钮位置偏差

---

## 七、资源需求

### 必需资源（已存在）

| 资源 | 路径 | 用途 |
|------|------|------|
| `SelectorScreen.reanim` | `assets/effect/reanim/` | 主菜单动画 |
| 所有按钮图片（8张） | `assets/reanim/SelectorScreen_*_button/highlight.png` | 按钮显示 |
| 背景、云朵等图片 | `assets/reanim/` | 装饰元素 |
| 关卡数字精灵图 | `assets/images/SelectorScreen_LevelNumbers.png` | 进度显示 |

### 资源配置（已配置）

所有 `IMAGE_REANIM_SELECTORSCREEN_*` 资源ID 已在 `resources.yaml` 中配置。

---

## 八、测试策略

### 集成测试场景

1. **场景1：新玩家（1-1）**
   - 只显示冒险模式按钮
   - 其他按钮隐藏
   - 显示 "LEVEL 1-1"

2. **场景2：中期玩家（3-5）**
   - 显示冒险模式 + 玩玩小游戏按钮
   - 生存和解谜模式隐藏
   - 显示 "LEVEL 3-5"

3. **场景3：通关玩家（5-10）**
   - 显示所有4个按钮
   - 显示 "LEVEL 5-10"

4. **场景4：按钮交互**
   - 悬停高亮
   - 点击已解锁跳转
   - 点击未解锁弹对话框

### 性能测试

- 主菜单加载时间 < 500ms
- Reanim 动画帧率 = 20 FPS（稳定）
- 按钮悬停响应延迟 < 50ms

---

## 九、风险与缓解

| 风险 | 等级 | 缓解措施 |
|------|------|---------|
| Reanim 图片资源缺失 | 低 | 已验证全部存在 |
| 按钮位置偏差 | 中 | 提供配置常量，方便调整 |
| 高亮效果不理想 | 低 | 支持两种实现方式 |
| 性能问题（云朵动画） | 极低 | Reanim 已优化 |

---

## 十、总结

**方式B的核心优势**：
- ✅ 完全还原原版效果（布局、动画）
- ✅ 减少手动计算和维护成本
- ✅ 自动获得装饰动画（云朵、花朵）
- ✅ 符合项目"忠实原版"目标

**实现复杂度**：
- 略高于方式A（独立图片）
- 但长期维护成本更低
- 与现有 ReanimSystem 完美集成

**建议**：
- 优先实现阶段1和阶段2
- 阶段3可以在后续 Epic 中优化
