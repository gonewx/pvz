# Story 10.4: 植物种植粒子特效

## Status
Draft

## Story
**As a** 玩家,
**I want** to see soil particles splash when planting plants,
**so that** the planting action feels more impactful and visually satisfying.

## Acceptance Criteria
1. 玩家成功种植植物时，在种植位置生成土粒飞溅粒子效果。
2. 粒子效果使用原版配置文件（PlantingPool.xml 或类似文件）。
3. 土粒粒子从地面向上飞溅，然后落下，形成自然的抛物线运动。
4. 粒子效果持续 0.5-1.0 秒后自动消失，不影响游戏性能。
5. 粒子颜色和大小符合原版表现（棕色土粒，大小适中）。
6. 所有植物种植时都触发粒子效果（向日葵、豌豆射手、坚果墙等）。
7. 粒子效果在正确的渲染层级显示（植物下方，背景上方）。
8. 粒子系统性能良好，同时种植多个植物不影响帧率。

## Tasks / Subtasks

- [ ] Task 1: 寻找原版粒子配置文件 (AC: 2)
  - [ ] 在 `assets/effect/particles/` 目录搜索植物种植相关粒子配置
  - [ ] 候选文件：`PlantingPool.xml`, `Planting.xml`, `SoilSplash.xml`
  - [ ] 如果找不到，使用 `DirtPile.xml` 或类似土粒效果配置
  - [ ] 验证粒子配置包含正确的运动轨迹和颜色

- [ ] Task 2: 创建种植粒子效果工厂函数 (AC: 2, 3, 4, 5)
  - [ ] 在 `pkg/entities/effect_factory.go` 添加 `NewPlantingParticleEffect()` 函数
  - [ ] 参数：`em`, `rm`, `worldX`, `worldY`（种植位置的世界坐标）
  - [ ] 调用 `CreateParticleEffect(em, rm, "PlantingPool", worldX, worldY)` 创建粒子效果
  - [ ] 确保粒子配置支持抛物线运动（初速度向上，受重力影响）

- [ ] Task 3: 集成到植物种植逻辑 (AC: 1, 6)
  - [ ] 在 `InputSystem.handleLawnClick()` 中植物创建成功后触发粒子效果
  - [ ] 位置计算：使用 `utils.GridToWorldCoords(col, row)` 获取世界坐标
  - [ ] 调用 `entities.NewPlantingParticleEffect(em, rm, worldX, worldY)`
  - [ ] 记录日志：`log.Printf("[InputSystem] 触发种植粒子效果，位置: (%.1f, %.1f)", worldX, worldY)`

- [ ] Task 4: 验证粒子渲染层级 (AC: 7)
  - [ ] 确认粒子效果标记为 UIComponent（如果需要在植物上层）或不标记（在植物下层）
  - [ ] 根据 Story 8.5 的渲染层级管理，粒子应在 Layer 6（游戏世界粒子）渲染
  - [ ] 使用 `RenderSystem.DrawGameWorldParticles()` 渲染（不包含 UIComponent 的粒子）
  - [ ] 测试渲染顺序：背景 → 土粒粒子 → 植物

- [ ] Task 5: 粒子配置调优 (AC: 3, 4, 5)
  - [ ] 如果原版配置不符合预期，创建自定义配置文件
  - [ ] 位置：`assets/effect/particles/PlantingSplash.xml`
  - [ ] 参数调整：
    - 粒子生命周期：0.5-1.0 秒
    - 初速度：VX ∈ [-50, 50]，VY ∈ [-100, -200]（向上）
    - 重力加速度：约 300 像素/秒²
    - 粒子颜色：棕色（RGB 约 139, 90, 43）
    - 粒子大小：2-5 像素
    - 粒子数量：10-20 个

- [ ] Task 6: 性能优化 (AC: 8)
  - [ ] 使用对象池复用粒子实体（如果 ParticleSystem 尚未实现）
  - [ ] 限制同屏粒子数量上限（如 100 个）
  - [ ] 粒子生命周期结束后及时删除实体
  - [ ] 批量渲染粒子（已在 Story 7.3 实现）

- [ ] Task 7: 添加配置常量 (AC: 4, 5)
  - [ ] 在 `pkg/config/particle_config.go` 添加配置常量
  - [ ] `PlantingParticleEffect string = "PlantingPool"` - 粒子效果名称
  - [ ] `PlantingParticleLifetime float64 = 0.8` - 粒子生命周期（秒）
  - [ ] `PlantingParticleCount int = 15` - 粒子数量

- [ ] Task 8: 资源配置更新 (AC: 2)
  - [ ] 在 `assets/config/resources.yaml` 添加粒子资源配置（如果需要）
  - [ ] 粒子图片：`IMAGE_PARTICLE_DIRT` → `assets/particles/dirt.png`
  - [ ] 粒子配置：`PARTICLE_PLANTING` → `assets/effect/particles/PlantingPool.xml`

- [ ] Task 9: 错误处理和降级 (AC: 8)
  - [ ] 如果粒子效果创建失败，记录警告日志但不中断游戏
  - [ ] 降级方案：不显示粒子效果，植物种植逻辑正常进行
  - [ ] `if err != nil { log.Printf("警告：创建种植粒子效果失败: %v", err); }`

- [ ] Task 10: 测试和验证 (所有 AC)
  - [ ] 测试种植各种植物时粒子效果正确显示
  - [ ] 测试粒子运动轨迹（向上飞溅，抛物线落下）
  - [ ] 测试粒子颜色和大小符合原版
  - [ ] 测试粒子自动消失
  - [ ] 测试同时种植多个植物的性能
  - [ ] 测试粒子渲染层级正确

## Dev Notes

### Previous Story Insights
[Source: docs/stories/7.2.story.md, 7.3.story.md#Dev Agent Record]

从 Story 7.2 和 7.3 的实施中学到的关键经验：
1. **ParticleSystem 已完整实现**: 支持 XML 配置、发射器、力场、动画插值
2. **ParticleComponent**: 单个粒子的数据（位置、速度、颜色、生命周期）
3. **EmitterComponent**: 粒子发射器配置（生成规则、限制）
4. **粒子配置加载**: `ResourceManager.LoadParticleConfig(name)` 加载 XML 配置
5. **粒子创建API**: `entities.CreateParticleEffect(em, rm, effectName, x, y)` 创建粒子效果
6. **高性能渲染**: `RenderSystem.DrawParticles()` 批量渲染粒子

**本 Story 重点**:
- AC 1-2: 使用原版粒子配置创建种植粒子效果
- AC 3: 粒子抛物线运动（初速度向上，受重力影响）
- AC 4-5: 粒子生命周期和外观符合原版
- AC 6: 所有植物种植时触发
- AC 7: 正确的渲染层级（游戏世界粒子）
- AC 8: 性能优化

### Relevant Architecture

#### InputSystem 修改
[Location: pkg/systems/input_system.go]

```go
// handleLawnClick 修改（在植物创建成功后添加粒子效果）
func (s *InputSystem) handleLawnClick(mouseX, mouseY int) bool {
    // ... 现有的种植逻辑 ...
    
    // 创建植物实体
    plantID, err := s.createPlantEntity(plantType, col, row)
    if err != nil {
        log.Printf("[InputSystem] 创建植物实体失败: %v", err)
        s.gameState.AddSun(sunCost)
        return true
    }
    
    log.Printf("[InputSystem] 成功创建植物实体 (ID: %d, Type: %v) 在 (%d, %d)", plantID, plantType, col, row)
    
    // Story 10.4: 触发种植粒子效果
    worldX, worldY := utils.GridToWorldCoords(col, row, config.GridWorldStartX, config.GridWorldStartY, config.CellWidth, config.CellHeight)
    _, err = entities.NewPlantingParticleEffect(s.entityManager, s.resourceManager, worldX, worldY)
    if err != nil {
        log.Printf("[InputSystem] 警告：创建种植粒子效果失败: %v", err)
        // 不阻塞游戏逻辑，继续进行
    } else {
        log.Printf("[InputSystem] 触发种植粒子效果，位置: (%.1f, %.1f)", worldX, worldY)
    }
    
    // ... 后续逻辑（标记格子、播放音效、冷却等）...
}
```

#### 粒子效果工厂
[Location: pkg/entities/effect_factory.go]

```go
// NewPlantingParticleEffect 创建植物种植粒子效果
// Story 10.4: 土粒飞溅效果，抛物线运动
//
// 参数:
//   - em: 实体管理器
//   - rm: 资源管理器
//   - worldX: 世界坐标X（种植位置）
//   - worldY: 世界坐标Y（种植位置）
//
// 返回:
//   - ecs.EntityID: 粒子效果实体ID（0 表示失败）
//   - error: 创建错误
func NewPlantingParticleEffect(
    em *ecs.EntityManager,
    rm ResourceLoader,
    worldX, worldY float64,
) (ecs.EntityID, error) {
    // 加载粒子配置
    // 尝试使用原版配置文件，如果不存在则降级到自定义配置
    effectName := "PlantingPool"  // 原版配置名称
    
    // 调用通用粒子效果创建函数
    entityID, err := CreateParticleEffect(em, rm, effectName, worldX, worldY)
    if err != nil {
        // 如果原版配置加载失败，尝试备用配置
        log.Printf("[EffectFactory] 警告：加载 '%s' 失败，尝试备用配置: %v", effectName, err)
        
        // 备用配置：DirtPile 或 PlantingSplash
        effectName = "DirtPile"
        entityID, err = CreateParticleEffect(em, rm, effectName, worldX, worldY)
        if err != nil {
            return 0, fmt.Errorf("创建种植粒子效果失败（所有备用配置都失败）: %w", err)
        }
    }
    
    log.Printf("[EffectFactory] 创建种植粒子效果 '%s'，位置: (%.1f, %.1f), 实体ID: %d",
        effectName, worldX, worldY, entityID)
    
    return entityID, nil
}
```

#### 自定义粒子配置（如果需要）
[Location: assets/effect/particles/PlantingSplash.xml]

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- 植物种植土粒飞溅效果 -->
<ParticleEffect>
    <Name>PlantingSplash</Name>
    <Duration>0.8</Duration>
    
    <Emitter>
        <ParticleCount>15</ParticleCount>
        <EmitRate>50</EmitRate>  <!-- 每秒发射50个，总共发射0.3秒 -->
        <EmitDuration>0.3</EmitDuration>
        
        <!-- 粒子初速度：向上和两侧飞溅 -->
        <VelocityX>
            <Min>-50</Min>
            <Max>50</Max>
        </VelocityX>
        <VelocityY>
            <Min>-150</Min>  <!-- 向上飞 -->
            <Max>-100</Max>
        </VelocityY>
        
        <!-- 重力加速度：模拟抛物线落下 -->
        <Gravity>300</Gravity>  <!-- 像素/秒² -->
        
        <!-- 粒子外观 -->
        <Color>
            <R>139</R>
            <G>90</G>
            <B>43</B>
            <A>255</A>
        </Color>
        
        <Size>
            <Min>2</Min>
            <Max>5</Max>
        </Size>
        
        <!-- 粒子生命周期 -->
        <Lifetime>
            <Min>0.5</Min>
            <Max>0.8</Max>
        </Lifetime>
        
        <!-- 淡出效果 -->
        <FadeOut>true</FadeOut>
    </Emitter>
</ParticleEffect>
```

#### 配置常量
[Location: pkg/config/particle_config.go]

```go
package config

const (
    // 种植粒子效果配置
    PlantingParticleEffect  = "PlantingPool"  // 粒子效果名称（原版配置）
    PlantingParticleBackup  = "DirtPile"      // 备用粒子效果名称
    PlantingParticleLifetime = 0.8            // 粒子效果持续时间（秒）
    PlantingParticleCount   = 15              // 粒子数量
)
```

#### 渲染层级管理
[Source: docs/stories/8.5.story.md]

**渲染顺序**:
```
GameScene.Draw():
  → Layer 1: 背景
  → Layer 2-5: 植物、僵尸、子弹等
  → Layer 6: 种植粒子效果（RenderSystem.DrawGameWorldParticles()）
  → Layer 6: 植物卡片渲染
  → Layer 7+: UI 层
```

**关键点**:
- 种植粒子不应添加 `UIComponent`（UI粒子会在最上层渲染）
- `RenderSystem.DrawGameWorldParticles()` 只渲染不含 `UIComponent` 的粒子
- 粒子会在植物上方显示（符合视觉效果）

#### ECS 泛型 API 使用
[Source: pkg/ecs/generics.go]

```go
// 创建粒子效果实体
entityID, err := entities.NewPlantingParticleEffect(em, rm, worldX, worldY)

// 查询所有粒子实体
particles := ecs.GetEntitiesWith1[*components.ParticleComponent](em)

// 获取粒子组件
particle, ok := ecs.GetComponent[*components.ParticleComponent](em, entity)
```

### Grid Utility Functions
[Source: pkg/utils/grid_utils.go]

```go
// GridToWorldCoords 网格坐标转世界坐标
// 返回格子中心点的世界坐标
func GridToWorldCoords(
    col, row int,
    gridWorldStartX, gridWorldStartY float64,
    cellWidth, cellHeight float64,
) (worldX, worldY float64) {
    worldX = gridWorldStartX + float64(col)*cellWidth + cellWidth/2
    worldY = gridWorldStartY + float64(row)*cellHeight + cellHeight/2
    return
}
```

### Particle System Architecture
[Source: pkg/systems/particle_system.go]

**粒子生命周期管理**:
- 创建：`entities.CreateParticleEffect()` → 创建发射器和粒子实体
- 更新：`ParticleSystem.Update()` → 更新粒子位置、速度、生命周期
- 渲染：`RenderSystem.DrawParticles()` → 批量渲染所有粒子
- 删除：粒子生命周期结束后自动标记删除

**性能优化**:
- 批量渲染：所有粒子使用一次 DrawTriangles 调用
- 对象池：复用粒子实体（如果实现）
- 限制上限：同屏最多 100 个粒子（配置可调）

### Coding Standards
[Source: docs/architecture/coding-standards.md]

1. **ECS 零耦合原则**: InputSystem 通过工厂函数创建粒子，不直接操作 ParticleSystem
2. **泛型 API 优先**: 使用 Epic 9 的泛型 ECS API
3. **错误处理**: 粒子效果创建失败不中断游戏，记录警告日志
4. **配置驱动**: 粒子配置文件驱动外观和行为
5. **性能考虑**: 粒子数量和生命周期控制在合理范围

### Testing

#### 测试标准
[Source: docs/architecture/testing-strategy.md]

**单元测试**:
- 测试文件位置: `pkg/entities/effect_factory_test.go`
- 测试 `NewPlantingParticleEffect()` 函数
- 测试粒子配置加载
- 测试错误处理和降级

**集成测试**:
- 创建完整的 GameScene 实例
- 模拟种植植物
- 验证粒子效果自动触发
- 验证粒子运动轨迹
- 验证粒子自动消失

**手动测试**:
- 运行游戏，种植各种植物
- 观察土粒飞溅效果
- 验证粒子颜色和运动轨迹
- 验证粒子渲染层级
- 同时种植多个植物，检查性能

#### 测试框架
- 使用 Go 标准库 `testing` 包
- 使用 `go test ./...` 运行所有测试
- 目标覆盖率: 80%+

### Performance Considerations

- **粒子数量控制**: 每次种植只生成 10-20 个粒子
- **生命周期短**: 粒子存在 0.5-1.0 秒即消失，避免积累
- **批量渲染**: 所有粒子一次渲染调用（已在 Story 7.3 实现）
- **对象池**: 复用粒子实体，减少内存分配
- **错误降级**: 粒子效果失败不影响游戏核心逻辑

### Design Decisions

**为什么粒子在植物上方显示？**
- 符合原版游戏表现，土粒飞溅在植物上方更真实
- 通过渲染层级管理（Layer 6）实现

**为什么使用 XML 配置？**
- 原版游戏使用 XML 定义粒子效果
- 配置文件易于调整和扩展，不需要修改代码

**为什么不影响种植逻辑？**
- 粒子效果是纯视觉表现，不应影响游戏机制
- 失败时降级，保证游戏可玩性

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-21 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used

*(To be filled by dev agent)*

### Debug Log References

*(To be filled by dev agent)*

### Completion Notes

*(To be filled by dev agent)*

### File List

*(To be filled by dev agent)*

## QA Results

*(This section will be populated by the QA agent after implementation)*

