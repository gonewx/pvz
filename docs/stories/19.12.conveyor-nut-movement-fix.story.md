# Story 19.12: 传送带坚果移动逻辑修正

## Status

Done

## Story

**As a** 玩家,
**I want** 传送带上的坚果以固定间隔摆放并随传送带移动到左侧后停止,
**so that** 我能体验正确的保龄球关卡节奏，从传送带拾取坚果再放置到草坪。

## Background

当前实现存在逻辑错误：
- ❌ 坚果创建后立即开始向右滚动
- ❌ 所有坚果同时移动

正确行为应为：
- ✅ 坚果以固定间隔摆放在传送带上，本身不主动移动
- ✅ 坚果随传送带一起向左移动（被动移动）
- ✅ 移动到左侧边缘后停止，等待玩家拾取
- ✅ 拾取并放置到草坪后才变成滚动的保龄球
- ✅ 间隔可配置，后期偶尔出现大间隔

## Acceptance Criteria

1. **传送带启动时生成第一个坚果**
   - 传送带启动时，第一个坚果在右侧生成
   - 随传送带一起向左移动

2. **坚果以固定间隔生成**
   - 当最右侧坚果移动了 >= spacing 距离后，在右侧生成新坚果
   - 基础间隔可配置（默认 80 像素）
   - 不使用时间计时器，由传送带速度自然驱动生成节奏

3. **坚果随传送带移动**
   - 所有坚果以相同速度向左移动
   - 传送带速度可配置（默认 30 像素/秒）

4. **坚果到达左侧后停止**
   - 到达左侧边缘后停止移动
   - 标记为 `IsAtLeftEdge = true`
   - 等待玩家拾取

5. **后期偶尔出现大间隔**
   - 大间隔出现概率可配置（默认 15%）
   - 大间隔倍数可配置（默认 2.0 倍）
   - 增加游戏紧张感

6. **拾取与放置逻辑**
   - 点击卡片实时位置即可拾取（保持现有点击检测逻辑不变）
   - 放置到草坪后创建 BowlingNut 实体，此时才开始滚动

7. **单元测试**: 覆盖率 ≥ 80%

## Tasks / Subtasks

### Task 1: 扩展 ConveyorCard 结构体 (AC: 1, 2, 4)

- [x] 修改 `pkg/components/conveyor_belt_component.go`
  - [x] 在现有 `ConveyorCard` 结构体中添加字段：
    - [x] `PositionX float64` - 在传送带上的 X 位置（局部坐标）
    - [x] `IsAtLeftEdge bool` - 是否已到达左侧边缘
  - [x] 在 `ConveyorBeltComponent` 中添加：
    - [x] `NextSpacing float64` - 下一个坚果的间隔距离
  - [x] **移除**：`SlideProgress` 和 `SlotIndex` 字段（由 `PositionX` 替代）

### Task 2: 添加配置常量 (AC: 2, 3, 5)

- [x] 修改 `pkg/config/layout_config.go`
  - [x] `ConveyorNutSpacing = 80.0` - 坚果基础间隔（像素）
  - [x] `ConveyorBeltMoveSpeed = 30.0` - 传送带移动速度（像素/秒）
  - [x] `ConveyorNutStopX = 10.0` - 坚果停止的左边缘 X 位置（局部坐标）
  - [x] `ConveyorLargeSpacingChance = 0.15` - 大间隔出现概率
  - [x] `ConveyorLargeSpacingMultiplier = 2.0` - 大间隔倍数

### Task 3: 修改 ConveyorBeltSystem (AC: 1, 2, 3, 4, 5)

- [x] 修改 `pkg/systems/conveyor_belt_system.go`
  - [x] 修改 `Activate()` 方法：
    - [x] 传送带启动时在**右侧**生成第一个坚果
    - [x] `PositionX = ConveyorBeltWidth`（传送带右边缘）
    - [x] `IsAtLeftEdge = false`
  - [x] 重写 `updateCardGeneration()` → `updateNutMovementAndSpawning()`：
    - [x] 更新所有卡片的 `PositionX`（向左移动）
    - [x] 到达左边缘时设置 `IsAtLeftEdge = true` 并停止移动
    - [x] 检查最右侧坚果位置，决定是否生成新坚果
    - [x] 随机决定是否使用大间隔
  - [x] **移除**：`updateCardSlideIn()` 方法（不再需要滑入动画）
  - [x] 修改 `Update()` 方法调用新逻辑

### Task 4: 修改渲染逻辑 (AC: 1, 3, 4)

- [x] 修改 `pkg/scenes/game_scene_conveyor.go` 的 `drawConveyorCards()` 方法：
  - [x] 使用 `card.PositionX` 计算卡片屏幕位置
  - [x] 公式：`screenX = conveyorX + card.PositionX`
  - [x] **移除**：`SlideProgress` 相关的滑入动画计算
  - [x] **移除**：`SlotIndex` 相关的槽位计算

### Task 5: 修改点击检测逻辑 (AC: 6)

- [x] 修改 `pkg/systems/conveyor_belt_system.go` 的点击检测方法：
  - [x] `GetCardAtPosition()` 和 `GetCardAtPositionIncludingSliding()` 合并为一个方法
  - [x] 使用 `card.PositionX` 计算卡片实时位置
  - [x] 点击卡片实时位置即可选中（无论是否到达左边缘）
- [x] 修改 `pkg/scenes/game_scene_conveyor.go`：
  - [x] 更新 `handleConveyorBeltClick()` 中的参数传递
  - [x] 更新 `isHoveringConveyorCard()` 中的参数传递

### Task 6: 单元测试 (AC: 7)

- [x] 修改 `pkg/systems/conveyor_belt_system_test.go`
  - [x] 测试传送带启动时第一个坚果在右侧生成
  - [x] 测试坚果位置随时间向左移动
  - [x] 测试坚果到达左边缘后停止
  - [x] 测试间隔生成逻辑
  - [x] 测试大间隔随机生成
  - [x] 测试点击检测基于实时位置

## Dev Notes

### 架构上下文

本 Story 是对 Story 19.5 的**逻辑修正**，修改现有 `ConveyorCard` 结构体，不创建新的并行结构。

**修正原因**：
- 当前实现使用 `SlideProgress` 控制滑入动画，但实际需要的是持续的传送带移动
- 应使用 `PositionX` 表示卡片在传送带上的实时位置

**依赖关系**：
- **修正**: Story 19.5 传送带系统
- **不影响**: Story 19.6 保龄球坚果实体与滚动（放置逻辑不变）
- **不影响**: Story 19.7 碰撞与弹射系统（仅处理已放置的滚动坚果）

### 关键设计决策

1. **修改现有结构而非创建新结构**
   - 在 `ConveyorCard` 中添加 `PositionX` 和 `IsAtLeftEdge` 字段
   - 移除 `SlideProgress` 和 `SlotIndex`（由 `PositionX` 替代）

2. **第一个坚果从右侧开始**
   - 传送带启动时，第一个坚果在右侧生成
   - 随传送带一起向左移动
   - 玩家可以看到完整的传送带运动过程

3. **点击检测保持不变**
   - 基于卡片实时位置检测点击
   - 不限制"只有到达左边缘才能拾取"
   - 玩家可以点击任何可见的卡片

4. **间隔驱动生成**
   - 使用距离驱动而非时间驱动
   - 生成节奏与传送带速度自然同步

### 字段变更对照表

| 现有字段 | 变更 | 新用途 |
|----------|------|--------|
| `SlideProgress` | **移除** | 由 `PositionX` 替代 |
| `SlotIndex` | **移除** | 由 `PositionX` 计算 |
| - | **新增** `PositionX` | 卡片在传送带上的局部 X 坐标 |
| - | **新增** `IsAtLeftEdge` | 是否已到达左边缘并停止 |

### 位置计算公式

```go
// 卡片局部坐标 → 屏幕坐标
screenX := conveyorX + card.PositionX

// 卡片移动（每帧更新）
if !card.IsAtLeftEdge {
    card.PositionX -= config.ConveyorBeltMoveSpeed * dt
    if card.PositionX <= config.ConveyorNutStopX {
        card.PositionX = config.ConveyorNutStopX
        card.IsAtLeftEdge = true
    }
}
```

### 生成逻辑伪代码

```go
func (s *ConveyorBeltSystem) updateNutMovementAndSpawning(dt float64, beltComp *ConveyorBeltComponent) {
    // 1. 更新所有卡片位置
    for i := range beltComp.Cards {
        card := &beltComp.Cards[i]
        if !card.IsAtLeftEdge {
            card.PositionX -= config.ConveyorBeltMoveSpeed * dt
            if card.PositionX <= config.ConveyorNutStopX {
                card.PositionX = config.ConveyorNutStopX
                card.IsAtLeftEdge = true
            }
        }
    }

    // 2. 检查是否需要生成新坚果
    if len(beltComp.Cards) == 0 {
        return // 第一个坚果在 Activate() 中生成
    }

    // 找到最右侧坚果
    rightmostCard := beltComp.Cards[len(beltComp.Cards)-1]

    // 当最右侧坚果移动了足够距离时，生成新坚果
    spawnThreshold := beltWidth - beltComp.NextSpacing
    if rightmostCard.PositionX <= spawnThreshold {
        s.spawnCardAtRight(beltComp)

        // 计算下一个间隔
        beltComp.NextSpacing = config.ConveyorNutSpacing
        if rand.Float64() < config.ConveyorLargeSpacingChance {
            beltComp.NextSpacing *= config.ConveyorLargeSpacingMultiplier
        }
    }
}
```

### 坐标系统

传送带坚果使用**相对于传送带的局部坐标**：
- `PositionX = 0`：传送带最左侧
- `PositionX = ConveyorBeltWidth`：传送带最右侧
- 渲染时：`screenX = conveyorX + card.PositionX`

### 文件修改清单

| 文件 | 修改内容 |
|------|----------|
| `pkg/components/conveyor_belt_component.go` | 扩展 `ConveyorCard`，移除 `SlideProgress`/`SlotIndex` |
| `pkg/config/layout_config.go` | 添加 5 个新配置常量 |
| `pkg/systems/conveyor_belt_system.go` | 重写生成和移动逻辑，修改点击检测 |
| `pkg/scenes/game_scene_conveyor.go` | 修改渲染逻辑使用 `PositionX` |
| `pkg/systems/conveyor_belt_system_test.go` | 更新测试用例 |

## Testing

### 测试文件位置

- `pkg/systems/conveyor_belt_system_test.go`

### 关键测试场景

**1. 传送带启动测试**:
```go
func TestConveyorBeltSystem_ActivateSpawnsFirstCardAtRight(t *testing.T) {
    system.Activate()

    beltComp := getBeltComponent()
    assert.Equal(t, 1, len(beltComp.Cards))

    // 验证第一个坚果在右侧
    assert.Equal(t, config.ConveyorBeltWidth, beltComp.Cards[0].PositionX)
    assert.False(t, beltComp.Cards[0].IsAtLeftEdge)
}
```

**2. 坚果移动测试**:
```go
func TestConveyorBeltSystem_CardsMove(t *testing.T) {
    system.Activate()
    initialX := getBeltComponent().Cards[0].PositionX

    system.Update(1.0) // 1秒

    newX := getBeltComponent().Cards[0].PositionX
    expectedMove := config.ConveyorBeltMoveSpeed * 1.0
    assert.InDelta(t, initialX - expectedMove, newX, 0.1)
}
```

**3. 停止测试**:
```go
func TestConveyorBeltSystem_CardStopsAtLeftEdge(t *testing.T) {
    system.Activate()

    // 移动足够长时间让卡片到达左边缘
    for i := 0; i < 200; i++ {
        system.Update(0.1) // 20秒
    }

    beltComp := getBeltComponent()
    assert.Equal(t, config.ConveyorNutStopX, beltComp.Cards[0].PositionX)
    assert.True(t, beltComp.Cards[0].IsAtLeftEdge)
}
```

**4. 间隔生成测试**:
```go
func TestConveyorBeltSystem_SpawnsBySpacing(t *testing.T) {
    system.Activate()

    // 模拟传送带移动足够距离
    for i := 0; i < 100; i++ {
        system.Update(0.1) // 10秒
    }

    beltComp := getBeltComponent()
    assert.Greater(t, len(beltComp.Cards), 1)
}
```

### 测试命令

```bash
# 运行系统测试
go test ./pkg/systems -v -run TestConveyorBeltSystem

# 查看覆盖率
go test ./pkg/systems -cover -run "ConveyorBelt"
```

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5

### Debug Log References

无

### Completion Notes List

- 重构了传送带卡片的位置追踪机制，从基于 SlotIndex + SlideProgress 改为基于 PositionX
- 实现了距离驱动的生成逻辑，替代原来的时间驱动生成
- 添加了大间隔随机生成功能（15% 概率，2 倍间隔）
- 合并了两个点击检测方法为一个统一的 GetCardAtPosition()
- 更新了存档序列化逻辑以支持新的数据结构
- 所有单元测试通过，覆盖率 > 80%

### File List

| 文件 | 状态 | 描述 |
|------|------|------|
| `pkg/components/conveyor_belt_component.go` | 修改 | 添加 PositionX/IsAtLeftEdge/NextSpacing，移除 SlideProgress/SlotIndex/GenerationTimer/GenerationInterval |
| `pkg/config/layout_config.go` | 修改 | 添加 5 个传送带配置常量 |
| `pkg/systems/conveyor_belt_system.go` | 修改 | 重写生成和移动逻辑，合并点击检测方法 |
| `pkg/scenes/game_scene_conveyor.go` | 修改 | 使用 PositionX 渲染和检测点击 |
| `pkg/scenes/game_scene.go` | 修改 | 移除 SetGenerationInterval 调用 |
| `pkg/scenes/game_scene_init.go` | 修改 | 更新存档恢复逻辑 |
| `pkg/game/battle_save_data.go` | 修改 | 更新数据结构定义 |
| `pkg/game/battle_serializer.go` | 修改 | 更新序列化逻辑 |
| `pkg/game/battle_serializer_test.go` | 修改 | 更新测试用例 |
| `pkg/systems/conveyor_belt_system_test.go` | 修改 | 重写测试用例以匹配新逻辑 |

## QA Results

### Review Date: 2025-12-04

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

实现质量优秀。代码结构清晰，遵循 ECS 架构原则。Story 19.12 成功重构了传送带卡片移动逻辑，从基于 `SlotIndex` + `SlideProgress` 改为基于 `PositionX` 的距离驱动机制。

**架构亮点**:
- 使用 `PositionX` 统一管理卡片位置，简化了代码逻辑
- 距离驱动生成替代时间驱动，更符合传送带的物理特性
- 序列化系统正确更新以支持新数据结构

**代码质量**:
- 组件定义清晰，注释完善
- 配置常量集中管理于 `layout_config.go`
- 测试覆盖全面，各方法覆盖率 75%-100%

### Refactoring Performed

无需重构。代码已符合项目规范。

### Compliance Check

- Coding Standards: ✓ 代码格式规范，命名遵循 Go 约定
- Project Structure: ✓ 文件组织正确，遵循 ECS 架构
- Testing Strategy: ✓ 单元测试覆盖率 > 80%，测试场景完整
- All ACs Met: ✓ 全部 7 项验收标准已实现

### Improvements Checklist

- [x] ConveyorCard 结构体添加 PositionX/IsAtLeftEdge 字段
- [x] 移除废弃的 SlideProgress/SlotIndex 字段
- [x] 实现距离驱动生成逻辑
- [x] 实现大间隔随机生成（15% 概率，2 倍间隔）
- [x] 合并点击检测方法为统一的 GetCardAtPosition()
- [x] 更新序列化逻辑支持新数据结构
- [x] 单元测试覆盖率 > 80%

### Security Review

无安全相关代码变更。

### Performance Considerations

- 卡片位置更新使用简单的浮点运算，性能开销极小
- 渲染逻辑使用裁剪优化，避免绘制传送带外的卡片

### Files Modified During Review

无文件修改。

### Gate Status

Gate: PASS → docs/qa/gates/19.12-conveyor-nut-movement-fix.yml

### Recommended Status

✓ Ready for Done

实现完整，测试通过，代码质量良好。所有验收标准已满足。

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 0.1 | 初始创建 | Bob (Scrum Master Agent) |
| 2025-12-04 | 0.2 | 根据 PO 反馈修正：修改现有 ConveyorCard，第一个坚果从右侧开始，保持点击检测逻辑不变 | Sarah (PO Agent) |
| 2025-12-04 | 1.0 | 实现完成，所有任务通过 | James (Dev Agent) |

---
