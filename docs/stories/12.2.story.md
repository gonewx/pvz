# Story 12.2: 底部功能栏重构 (Bottom Function Bar Refactor)

## Status
Ready

---

## Story

**As a** 玩家（游戏玩家）,
**I want** 在主菜单底部看到 3 个花瓶样式的功能按钮（选项/帮助/退出），并能通过点击触发对应的面板或功能,
**so that** 我能方便地查看帮助信息、调整游戏设置和退出游戏。

---

## Story Context

### Existing System Integration
- **Integrates with**: 主菜单场景系统（`pkg/scenes/main_menu_scene.go`）
- **Technology**: Go, Ebitengine, ECS 架构
- **Follows pattern**: 按钮交互模式（现有的 `components.Button`）
- **Touch points**:
  - `MainMenuScene.initButtons()` - 当前按钮初始化（**需要重构**）
  - `MainMenuScene.onExitClicked()` - 退出按钮回调（**需要保留**）
  - `entities.NewHelpPanelEntity()` - 帮助面板工厂（**Story 12.3 提供**）
  - `entities.NewOptionsPanelEntity()` - 选项面板工厂（**Story 12.3 提供**）
  - `ResourceManager.LoadImageByID()` - 加载按钮资源
  - 按钮渲染逻辑（`MainMenuScene.Draw()`）

### Problem Description

**当前底部功能栏状态：**
- ✅ 有退出按钮（但位置和样式不符合原版）
- ❌ **缺少选项按钮**（调用选项面板）
- ❌ **缺少帮助按钮**（调用帮助面板）
- ❌ **按钮样式不是花瓶形状**（当前使用通用按钮）
- ❌ **按钮位置不符合原版**（应在右下角横排）

**原版底部功能栏规格：**
根据 `docs/main-menu-spec.md` 和 `.meta/levels/index.md`：

1. **3 个花瓶样式按钮（从左到右）：**
   - 选项 (Options) - **打开选项面板**（Story 12.3 提供）
   - 帮助 (Help) - **打开帮助面板**（Story 12.3 提供）
   - 退出 (Quit) - 退出游戏

2. **按钮位置：**
   - 位置：屏幕右下角
   - 排列：水平横排
   - 间距：紧密排列

3. **按钮交互：**
   - 正常态：黑色文字图片（如 `SelectorScreen_Options1.png`）
   - 悬停态：切换到高亮图片（如 `SelectorScreen_Options2.png`）
   - 点击音效：`SOUND_BUTTONCLICK`

4. **功能实现：**
   - **选项按钮**: 调用 `entities.NewOptionsPanelEntity()` 创建选项面板
   - **帮助按钮**: 调用 `entities.NewHelpPanelEntity()` 创建帮助面板
   - **退出按钮**: 退出游戏（已实现，需保留）

**技术挑战：**
1. 需要替换现有的退出按钮实现
2. 需要处理 2 个新按钮（选项、帮助）
3. 需要集成 Story 12.3 提供的面板工厂
4. 需要精确定位按钮在右下角

---

## Acceptance Criteria

### Functional Requirements:

**AC1: 3 个花瓶按钮正确显示**
- Given: 进入主菜单
- When: 主菜单加载完成
- Then:
  - 应显示 3 个花瓶按钮（选项/帮助/退出）
  - 按钮水平横排，从左到右
  - 按钮位置在屏幕右下角
  - 按钮间距紧密

**AC2: 按钮交互正确响应**
- Given: 鼠标悬停在按钮上
- When: 移动鼠标
- Then:
  - 按钮应切换到高亮图片（state 2）
  - 鼠标移开后恢复正常图片（state 1）

- Given: 点击退出按钮
- When: 点击事件触发
- Then:
  - 应播放点击音效
  - 应退出游戏（调用 `os.Exit(0)`）

**AC3: 选项和帮助按钮功能正确**
- Given: Story 12.3（对话框系统）已完成
- When: 点击选项按钮
- Then:
  - 应播放点击音效
  - 应创建选项面板实体（调用 `NewOptionsPanelEntity()`）
  - 选项面板应正确显示

- Given: Story 12.3 已完成
- When: 点击帮助按钮
- Then:
  - 应播放点击音效
  - 应创建帮助面板实体（调用 `NewHelpPanelEntity()`）
  - 帮助面板应正确显示

### Integration Requirements:

**AC4: 资源加载正确**
- 所有 6 张按钮图片正确加载（3 个按钮 × 2 个状态）
- 资源加载失败时有 fallback（使用纯色矩形 + 文字）

**AC5: 与现有系统兼容**
- 不破坏主菜单的其他功能（石碑菜单、背景音乐等）
- 使用统一的按钮状态管理（`UIState`）
- 按钮点击音效统一使用 `SOUND_BUTTONCLICK`

**AC6: 与其他 Story 协同**
- **与 Story 12.1 协同**: 不与石碑菜单按钮冲突，两组按钮可以同时存在和交互
- **依赖 Story 12.3**: 使用 Story 12.3 提供的面板工厂（`NewHelpPanelEntity`, `NewOptionsPanelEntity`）
- 渲染顺序正确（底部按钮在最上层）

### Quality Requirements:

**AC7: 性能要求**
- 按钮悬停响应延迟 < 50ms
- 无内存泄漏（按钮实体正确管理）

**AC8: 代码质量**
- 遵循 ECS 架构原则（组件-系统分离）
- 使用泛型 ECS API（Epic 9）
- 代码注释完整，遵循项目编码规范
- 通过 `gofmt` 和 `golangci-lint` 检查

**AC9: 测试覆盖**
- 单元测试覆盖按钮布局计算逻辑
- 集成测试覆盖按钮交互流程
- 手工测试验证 UI 位置和交互

---

## Tasks / Subtasks

### Task 1: 设计和实现组件结构 (AC: 1, 5, 8)

- [ ] **1.1: 设计 BottomButtonComponent 组件**
  - [ ] 定义组件字段（ButtonType, NormalImage, HoverImage 等）
  - [ ] 添加 GoDoc 注释
  - [ ] 创建文件：`pkg/components/bottom_button_component.go`

- [ ] **1.2: 定义底部按钮类型枚举**
  - [ ] 创建 `BottomButtonType` 枚举（Options, Help, Quit）
  - [ ] 定义资源 ID 映射关系

- [ ] **1.3: 设计组件结构**
  ```go
  // BottomButtonComponent 底部功能按钮组件
  // 用于主菜单右下角的 3 个花瓶按钮（选项/帮助/退出）
  type BottomButtonComponent struct {
      ButtonType      BottomButtonType  // 按钮类型
      NormalImage     *ebiten.Image     // 正常状态图片
      HoverImage      *ebiten.Image     // 悬停状态图片
      State           UIState           // UI 状态（正常/悬停/点击）
      Width           float64           // 按钮宽度
      Height          float64           // 按钮高度
  }
  ```

### Task 2: 创建底部按钮实体工厂 (AC: 1, 4, 8)

- [ ] **2.1: 创建 BottomButton 实体工厂**
  - [ ] 创建文件：`pkg/entities/bottom_button_factory.go`
  - [ ] 实现函数：`NewBottomButtonEntity(em, rm, buttonType, x, y)`
  - [ ] 添加组件：
    - `BottomButtonComponent` - 按钮数据
    - `PositionComponent` - 按钮位置
    - `UIComponent` - UI 标记

- [ ] **2.2: 加载按钮资源**
  - [ ] 资源 ID 映射：
    ```go
    var bottomButtonResources = map[BottomButtonType]struct{ Normal, Hover string }{
        BottomButtonOptions: {
            Normal: "IMAGE_SELECTORSCREEN_OPTIONS1",
            Hover:  "IMAGE_SELECTORSCREEN_OPTIONS2",
        },
        BottomButtonHelp: {
            Normal: "IMAGE_SELECTORSCREEN_HELP1",
            Hover:  "IMAGE_SELECTORSCREEN_HELP2",
        },
        BottomButtonQuit: {
            Normal: "IMAGE_SELECTORSCREEN_QUIT1",
            Hover:  "IMAGE_SELECTORSCREEN_QUIT2",
        },
    }
    ```
  - [ ] 处理资源加载失败（使用 fallback）

### Task 3: 计算按钮布局位置 (AC: 1, 8)

- [ ] **3.1: 定义按钮位置常量**
  - [ ] 在 `pkg/config/ui_config.go` 中定义常量：
    ```go
    const (
        // 底部按钮布局
        BottomButtonStartX  = 550.0   // 第一个按钮 X 坐标（选项）
        BottomButtonY       = 520.0   // 所有按钮 Y 坐标（右下角）
        BottomButtonSpacingX = 80.0   // 按钮水平间距
        BottomButtonWidth   = 70.0    // 按钮宽度（估计）
        BottomButtonHeight  = 70.0    // 按钮高度（估计）
    )
    ```

- [ ] **3.2: 实现按钮位置计算函数**
  - [ ] 创建函数：`func calculateBottomButtonPosition(buttonIndex int) (x, y float64)`
  - [ ] 返回第 N 个按钮的正确位置

- [ ] **3.3: 对照原版截图调整位置**
  - [ ] 参考 `.meta/screenshot/menu/` 中的截图
  - [ ] 微调常量值，确保布局一致

### Task 4: 重构 MainMenuScene 底部按钮逻辑 (AC: 1, 2, 3, 5, 6)

- [ ] **4.1: 修改 MainMenuScene 结构体**
  - [ ] 删除旧字段：`buttons []components.Button`（如果还在使用）
  - [ ] 添加新字段：
    ```go
    bottomButtons   []ecs.EntityID  // 3 个底部功能按钮实体
    ```

- [ ] **4.2: 创建 initBottomButtons 方法**
  - [ ] 删除旧的 `initButtons()` 方法中的退出按钮逻辑
  - [ ] 创建新方法：`initBottomButtons()`
  - [ ] 创建 3 个底部按钮实体：
    ```go
    func (m *MainMenuScene) initBottomButtons() {
        for i, btnType := range []BottomButtonType{BottomButtonOptions, BottomButtonHelp, BottomButtonQuit} {
            x, y := calculateBottomButtonPosition(i)
            btnEntity := entities.NewBottomButtonEntity(m.entityManager, m.resourceManager, btnType, x, y)
            m.bottomButtons = append(m.bottomButtons, btnEntity)
        }
    }
    ```

- [ ] **4.3: 实现按钮交互逻辑**
  - [ ] 在 `Update()` 方法中添加底部按钮悬停检测
  - [ ] 在 `Update()` 方法中添加底部按钮点击处理
  - [ ] 实现点击回调函数：
    ```go
    func (m *MainMenuScene) onBottomButtonClicked(btnType BottomButtonType) {
        // 播放点击音效
        if player, err := m.resourceManager.LoadSoundEffect("assets/sounds/buttonclick.ogg"); err == nil {
            player.Play()
        }

        switch btnType {
        case BottomButtonOptions:
            // 调用 Story 12.3 提供的选项面板工厂
            optionsPanel := entities.NewOptionsPanelEntity(m.entityManager, m.resourceManager)
            m.currentDialog = optionsPanel
            log.Println("[MainMenu] Options panel opened")

        case BottomButtonHelp:
            // 调用 Story 12.3 提供的帮助面板工厂
            helpPanel := entities.NewHelpPanelEntity(m.entityManager, m.resourceManager)
            m.currentDialog = helpPanel
            log.Println("[MainMenu] Help panel opened")

        case BottomButtonQuit:
            // 退出游戏（保留现有逻辑）
            log.Println("[MainMenu] Quit button clicked")
            os.Exit(0)
        }
    }
    ```

- [ ] **4.4: 更新 Update 方法**
  - [ ] 在现有菜单按钮逻辑后添加底部按钮逻辑
  - [ ] 确保两组按钮不冲突

- [ ] **4.5: 更新 Draw 方法**
  - [ ] 在绘制菜单按钮后绘制底部按钮
  - [ ] 确保渲染顺序正确（底部按钮在最上层）
  - [ ] 实现悬停态切换：
    ```go
    // 绘制底部按钮
    for _, btnEntityID := range m.bottomButtons {
        btnComp, _ := ecs.GetComponent[*components.BottomButtonComponent](m.entityManager, btnEntityID)
        posComp, _ := ecs.GetComponent[*components.PositionComponent](m.entityManager, btnEntityID)

        // 选择图片（根据状态）
        img := btnComp.NormalImage
        if btnComp.State == components.UIHovered && btnComp.HoverImage != nil {
            img = btnComp.HoverImage
        }

        // 绘制按钮
        op := &ebiten.DrawImageOptions{}
        op.GeoM.Translate(posComp.X, posComp.Y)
        screen.DrawImage(img, op)
    }
    ```

### Task 5: 配置资源 ID (AC: 4)

- [ ] **5.1: 检查 resources.yaml 配置**
  - [ ] 确认以下资源 ID 已配置：
    - `IMAGE_SELECTORSCREEN_OPTIONS1`
    - `IMAGE_SELECTORSCREEN_OPTIONS2`
    - `IMAGE_SELECTORSCREEN_HELP1`
    - `IMAGE_SELECTORSCREEN_HELP2`
    - `IMAGE_SELECTORSCREEN_QUIT1`
    - `IMAGE_SELECTORSCREEN_QUIT2`

- [ ] **5.2: 添加缺失的资源配置**
  - [ ] 如果资源未配置，添加到 `assets/config/resources.yaml`
  - [ ] 验证资源文件存在于 `assets/images/` 目录

### Task 6: 测试和验证 (AC: 7, 9)

- [ ] **6.1: 编写单元测试**
  - [ ] 测试文件：`pkg/components/bottom_button_component_test.go`
  - [ ] 测试用例：
    - `TestCalculateBottomButtonPosition` - 验证位置计算
    - `TestBottomButtonLayout` - 验证布局间距
  - [ ] 运行测试：`go test ./pkg/components -v`

- [ ] **6.2: 集成测试**
  - [ ] 启动游戏，进入主菜单
  - [ ] 验证 3 个底部按钮正确显示
  - [ ] 测试按钮交互：
    - 悬停效果（图片切换）
    - 点击选项按钮（打印日志）
    - 点击帮助按钮（打印日志）
    - 点击退出按钮（退出游戏）
  - [ ] 验证按钮点击音效

- [ ] **6.3: 视觉对比测试**
  - [ ] 截图当前实现的底部按钮
  - [ ] 与原版截图对比（`.meta/screenshot/menu/`）
  - [ ] 调整位置和间距直到一致

### Task 7: 代码质量检查 (AC: 8)

- [ ] **7.1: 代码格式化**
  - [ ] 运行 `gofmt -w pkg/components/bottom_button_component.go`
  - [ ] 运行 `gofmt -w pkg/entities/bottom_button_factory.go`
  - [ ] 运行 `gofmt -w pkg/scenes/main_menu_scene.go`

- [ ] **7.2: Linter 检查**
  - [ ] 运行 `golangci-lint run ./pkg/components`
  - [ ] 运行 `golangci-lint run ./pkg/entities`
  - [ ] 运行 `golangci-lint run ./pkg/scenes`
  - [ ] 修复所有 warnings 和 errors

- [ ] **7.3: 代码审查**
  - [ ] 检查所有新增代码的注释完整性
  - [ ] 检查错误处理是否规范
  - [ ] 检查是否遵循 ECS 架构原则

---

## Dev Notes

### Relevant Unified Project Structure

**新增文件：**
- `pkg/components/bottom_button_component.go` - 底部按钮组件定义
- `pkg/components/bottom_button_component_test.go` - 单元测试
- `pkg/entities/bottom_button_factory.go` - 底部按钮实体工厂

**修改文件：**
- `pkg/scenes/main_menu_scene.go` - 主菜单场景逻辑（添加底部按钮）
- `pkg/config/ui_config.go` - UI 布局常量（如果不存在则创建）
- `assets/config/resources.yaml` - 资源配置（如果需要）

**依赖文件（Story 12.3 提供）：**
- `pkg/entities/help_panel_factory.go` - 帮助面板工厂（**必须先实现**）
- `pkg/entities/options_panel_factory.go` - 选项面板工厂（**必须先实现**）

**依赖文件（已存在）：**
- `pkg/game/resource_manager.go` - 加载资源
- `pkg/components/ui_component.go` - UI 组件基类
- `pkg/components/position_component.go` - 位置组件

---

### Technical Design Details

#### 1. BottomButtonComponent 设计

```go
// pkg/components/bottom_button_component.go

package components

import "github.com/hajimehoshi/ebiten/v2"

// BottomButtonType 定义底部功能按钮类型
type BottomButtonType int

const (
    BottomButtonOptions BottomButtonType = iota  // 选项（设置）
    BottomButtonHelp                             // 帮助
    BottomButtonQuit                             // 退出
)

// BottomButtonComponent 底部功能按钮组件
// 用于主菜单右下角的 3 个花瓶样式按钮（选项/帮助/退出）
type BottomButtonComponent struct {
    ButtonType      BottomButtonType  // 按钮类型
    NormalImage     *ebiten.Image     // 正常状态图片
    HoverImage      *ebiten.Image     // 悬停状态图片
    State           UIState           // UI 状态（正常/悬停/点击）
    Width           float64           // 按钮宽度
    Height          float64           // 按钮高度
}
```

#### 2. 按钮位置计算

```go
// calculateBottomButtonPosition 计算底部按钮位置
// buttonIndex: 按钮索引（0=选项, 1=帮助, 2=退出）
func calculateBottomButtonPosition(buttonIndex int) (x, y float64) {
    x = config.BottomButtonStartX + float64(buttonIndex)*config.BottomButtonSpacingX
    y = config.BottomButtonY
    return x, y
}
```

#### 3. MainMenuScene 改动要点

**关键改动：**

1. **添加底部按钮字段**
   ```go
   type MainMenuScene struct {
       // ... 现有字段
       menuButtons     []ecs.EntityID  // Story 12.1 添加
       bottomButtons   []ecs.EntityID  // Story 12.2 添加 ← 新增
   }
   ```

2. **在 NewMainMenuScene 中初始化**
   ```go
   func NewMainMenuScene(rm, sm) *MainMenuScene {
       scene := &MainMenuScene{ /* ... */ }

       // ... 加载背景、音乐等

       // Story 12.1: 初始化菜单按钮
       scene.initMenuButtons()

       // Story 12.2: 初始化底部按钮
       scene.initBottomButtons()

       return scene
   }
   ```

3. **Update 方法整合**
   ```go
   func (m *MainMenuScene) Update(deltaTime float64) {
       // ... 背景音乐等逻辑

       mouseX, mouseY := ebiten.CursorPosition()
       isMousePressed := ebiten.IsMouseButtonPressed(ebiten.MouseButtonLeft)
       isMouseClicked := isMousePressed && !m.wasMousePressed

       // 1. 更新菜单按钮（Story 12.1）
       m.updateMenuButtons(mouseX, mouseY, isMouseClicked)

       // 2. 更新底部按钮（Story 12.2）
       m.updateBottomButtons(mouseX, mouseY, isMouseClicked)

       m.wasMousePressed = isMousePressed
   }

   // 提取的辅助方法
   func (m *MainMenuScene) updateBottomButtons(mouseX, mouseY int, isClicked bool) {
       for _, btnEntityID := range m.bottomButtons {
           btnComp, _ := ecs.GetComponent[*components.BottomButtonComponent](m.entityManager, btnEntityID)
           posComp, _ := ecs.GetComponent[*components.PositionComponent](m.entityManager, btnEntityID)

           if isPointInRect(float64(mouseX), float64(mouseY), posComp.X, posComp.Y, btnComp.Width, btnComp.Height) {
               if isClicked {
                   btnComp.State = components.UIClicked
                   m.onBottomButtonClicked(btnComp.ButtonType)
               } else {
                   btnComp.State = components.UIHovered
               }
           } else {
               btnComp.State = components.UINormal
           }
       }
   }
   ```

4. **Draw 方法整合**
   ```go
   func (m *MainMenuScene) Draw(screen *ebiten.Image) {
       // 1. 绘制背景
       // ...

       // 2. 绘制菜单按钮（Story 12.1）
       m.drawMenuButtons(screen)

       // 3. 绘制底部按钮（Story 12.2）
       m.drawBottomButtons(screen)
   }

   func (m *MainMenuScene) drawBottomButtons(screen *ebiten.Image) {
       for _, btnEntityID := range m.bottomButtons {
           btnComp, _ := ecs.GetComponent[*components.BottomButtonComponent](m.entityManager, btnEntityID)
           posComp, _ := ecs.GetComponent[*components.PositionComponent](m.entityManager, btnEntityID)

           img := btnComp.NormalImage
           if btnComp.State == components.UIHovered && btnComp.HoverImage != nil {
               img = btnComp.HoverImage
           }

           op := &ebiten.DrawImageOptions{}
           op.GeoM.Translate(posComp.X, posComp.Y)
           screen.DrawImage(img, op)
       }
   }
   ```

---

### Resource Requirements

**必需的图片资源：**

| 资源 ID | 文件路径 | 用途 |
|---------|---------|------|
| `IMAGE_SELECTORSCREEN_OPTIONS1` | `assets/images/SelectorScreen_Options1.png` | 选项按钮（正常态） |
| `IMAGE_SELECTORSCREEN_OPTIONS2` | `assets/images/SelectorScreen_Options2.png` | 选项按钮（悬停态） |
| `IMAGE_SELECTORSCREEN_HELP1` | `assets/images/SelectorScreen_Help1.png` | 帮助按钮（正常态） |
| `IMAGE_SELECTORSCREEN_HELP2` | `assets/images/SelectorScreen_Help2.png` | 帮助按钮（悬停态） |
| `IMAGE_SELECTORSCREEN_QUIT1` | `assets/images/SelectorScreen_Quit1.png` | 退出按钮（正常态） |
| `IMAGE_SELECTORSCREEN_QUIT2` | `assets/images/SelectorScreen_Quit2.png` | 退出按钮（悬停态） |

**音效资源：**
- `SOUND_BUTTONCLICK` - 按钮点击音效（已存在）

---

### Testing Strategy

#### 单元测试

**测试文件：** `pkg/components/bottom_button_component_test.go`

**测试用例：**

```go
func TestCalculateBottomButtonPosition(t *testing.T) {
    // 测试第一个按钮（选项）
    x, y := calculateBottomButtonPosition(0)
    assert.Equal(t, config.BottomButtonStartX, x)
    assert.Equal(t, config.BottomButtonY, y)

    // 测试第二个按钮（帮助）
    x, y = calculateBottomButtonPosition(1)
    assert.Equal(t, config.BottomButtonStartX+config.BottomButtonSpacingX, x)
    assert.Equal(t, config.BottomButtonY, y)

    // 测试第三个按钮（退出）
    x, y = calculateBottomButtonPosition(2)
    assert.Equal(t, config.BottomButtonStartX+config.BottomButtonSpacingX*2, x)
    assert.Equal(t, config.BottomButtonY, y)
}

func TestBottomButtonLayout(t *testing.T) {
    // 验证按钮布局在屏幕范围内
    for i := 0; i < 3; i++ {
        x, y := calculateBottomButtonPosition(i)
        assert.True(t, x >= 0 && x < 800, "X 坐标应在屏幕范围内")
        assert.True(t, y >= 0 && y < 600, "Y 坐标应在屏幕范围内")
    }
}
```

#### 集成测试

**测试场景：**

1. **场景 1：按钮显示**
   - Given: 启动游戏进入主菜单
   - When: 主菜单加载完成
   - Then:
     - 右下角显示 3 个花瓶按钮
     - 按钮横排，间距均匀

2. **场景 2：悬停效果**
   - Given: 主菜单已加载
   - When: 鼠标悬停在选项按钮上
   - Then: 按钮图片切换到 `SelectorScreen_Options2.png`
   - When: 鼠标移开
   - Then: 按钮图片恢复到 `SelectorScreen_Options1.png`

3. **场景 3：点击退出**
   - Given: 主菜单已加载
   - When: 点击退出按钮
   - Then:
     - 播放点击音效
     - 游戏退出

4. **场景 4：点击选项/帮助（临时）**
   - Given: 主菜单已加载
   - When: 点击选项按钮
   - Then:
     - 播放点击音效
     - 控制台打印日志提示
     - 游戏不崩溃

---

## Risk and Compatibility Check

### Primary Risks

**Risk 1: 资源文件缺失**
- **风险等级**: 低
- **影响**: 按钮无法显示
- **缓解措施**:
  - 启动时校验资源存在性
  - 资源加载失败时使用 fallback
  - 详细日志记录缺失资源

**Risk 2: 与 Story 12.1 冲突**
- **风险等级**: 低
- **影响**: 两组按钮可能互相干扰
- **缓解措施**:
  - 分离更新和绘制逻辑
  - 测试两组按钮同时交互

**Risk 3: UI 布局偏差**
- **风险等级**: 低
- **影响**: 按钮位置不符合原版
- **缓解措施**:
  - 使用配置常量
  - 对比原版截图调整

### Rollback Plan

- **简单回滚**: `git revert` 本 Story 的所有提交
- **部分回滚**: 删除底部按钮相关代码，恢复旧退出按钮
- **影响范围**: 仅主菜单场景底部区域
- **数据兼容性**: 无数据变更

### Compatibility Verification

- [x] **无 API 破坏性变更** - 只修改 MainMenuScene 内部
- [x] **无数据库变更** - 只有 UI 渲染
- [x] **遵循现有设计模式** - 使用 ECS 架构
- [x] **向后兼容** - 不影响其他场景
- [x] **性能无回归** - 只增加 3 个按钮实体

---

## Validation Checklist

### Scope Validation

- [x] **Story 可在一个开发会话内完成** - 估计 4-6 小时
- [x] **集成方法简单明确** - 添加 3 个按钮实体
- [x] **遵循现有模式** - 复用 Story 12.1 的按钮模式
- [x] **无需架构工作** - 复用现有 ECS 框架

### Clarity Check

- [x] **Story 需求明确无歧义** - AC 详细描述功能
- [x] **集成点清晰指定** - MainMenuScene
- [x] **成功标准可测试** - 有单元测试和集成测试
- [x] **回滚方法简单可行** - git revert

### Dependencies Check

- [ ] **Story 12.1 已完成** - 菜单按钮系统（并行开发，需协调）
- [ ] **Story 12.3 未完成** - 对话框系统（选项和帮助功能暂时无法完整实现）
  - **影响**: AC3 的选项和帮助按钮只能打印日志
  - **临时方案**: 点击按钮时播放音效 + 打印日志提示

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-01 | 0.1 | 初始 Story 创建，基于 Epic 12 和规格文档分析 | Sarah (PO) |

---

## Estimated Effort

**开发时间**: 2-4 小时（原 4-6 小时）

**分解：**
- 组件设计和实现: 1-1.5 小时
- 实体工厂和资源加载: 0.5-1 小时
- MainMenuScene 集成: 0.5-1 小时（**简化** - 只调用面板工厂）
- 测试和调试: 0.5-1 小时
- 代码审查和优化: 0.5 小时

**优先级**: ⭐⭐⭐⭐⭐ 高（阶段 1 核心功能）

**依赖关系**:
- **前置**: Story 12.3（**必须先完成** - 提供帮助和选项面板工厂）
- **后置**: 无

---

## Notes

- **关键变更**: 本 Story 从 4-6 小时简化为 2-4 小时（移除对话框实现，只做按钮集成）
- **依赖关系**: **必须先完成 Story 12.3**，才能实现本 Story
- 本 Story 实现简单，主要是添加 3 个按钮并集成 Story 12.3 的面板工厂
- UI 布局调整可能需要与 Story 12.1 一起微调
