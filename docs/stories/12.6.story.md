# Story 12.6: Reanim 动画集成 (Reanim Animation Integration)

## Status
InProgress

---

## Story

**As a** 玩家（游戏玩家）,
**I want** 在主菜单中看到流畅的 Reanim 动画（包括僵尸手掌升起和石碑升起）,
**so that** 我能获得与原版游戏一致的视觉体验，增强沉浸感。

---

## Acceptance Criteria

1. ✅ **AC1: 加载 SelectorScreen.reanim 文件**
   - 主菜单场景启动时加载 `SelectorScreen.reanim` 文件
   - 通过 ReanimSystem 管理动画播放
   - 确保资源正确加载，无错误日志

2. ⏸️ **AC2: 播放僵尸手掌升起动画**
   - 播放 `anim_rise` 动画（僵尸手掌从地面升起）
   - 动画播放时机：**点击"冒险模式"按钮后，进入游戏前**
   - 动画播放完成后切换到关卡选择场景（或直接进入关卡）
   - 阻塞式播放：动画播放期间不可中断，播放完成后才进入游戏
   - **状态：未实现**

3. ✅ **AC3: 播放石碑升起动画**
   - 播放 `anim_open` 动画（石碑从地面升起）
   - 动画在主菜单初始化时立即播放
   - 动画播放完成后切换到循环动画状态

4. ✅ **AC4: 与现有 ReanimSystem 集成**
   - 使用项目现有的 `ReanimSystem` 播放动画
   - 遵循 ECS 零耦合原则（通过组件通信）
   - 确保动画播放不影响其他系统性能

5. ✅ **AC5: 动画配置化管理**
   - 动画配置存储在 `data/reanim_config/selectorscreen.yaml` 中
   - 使用 `ReanimConfigManager` 加载配置
   - 支持热修改配置无需重新编译代码

---

## Tasks / Subtasks

### Task 1: 加载 SelectorScreen.reanim 文件（AC: 1）
- [x] 1.1. 在 `data/reanim_config/selectorscreen.yaml` 中配置动画元数据
  - 设置 `id: "selectorscreen"`
  - 设置 `reanim_file: "data/reanim/SelectorScreen.reanim"`
  - 配置图片映射（IMAGE_REANIM_SELECTORSCREEN_*）
- [x] 1.2. 在 `MainMenuScene.Enter()` 中加载 Reanim 实体
  - 调用 `entities.NewReanimEntity()` 创建动画实体
  - 添加 `ReanimComponent` 和 `PositionComponent`
  - 设置合适的渲染位置
- [x] 1.3. 验证资源加载
  - 检查日志中是否有加载错误
  - 确保所有轨道图片正确映射

### Task 2: 播放僵尸手掌升起动画（AC: 2）
- [x] 2.1. 创建僵尸手掌 Reanim 配置文件
  - 创建 `data/reanim_config/zombie_hand.yaml`
  - 设置 `reanim_file: "data/reanim/Zombie_hand.reanim"`
  - 配置图片映射（所有手指和石头碎片图片）
  - **注意**: Zombie_hand.reanim 是单一动画文件（无命名动画），使用单动画模式
- [x] 2.2. 在主菜单中创建僵尸手掌实体（初始暂停）
  - 在 `NewMainMenuScene()` 中创建僵尸手掌实体
  - 调用 `entities.NewZombieHandEntity()` 创建动画实体
  - 设置渲染位置：`(WindowWidth/2, WindowHeight-100)`
  - 初始状态：`IsPaused=true`，等待点击触发
- [x] 2.3. 实现点击"冒险模式"按钮后的动画触发逻辑
  - 修改 `onMenuButtonClicked()` 中 Adventure 按钮的处理
  - 点击后调用 `triggerZombieHandAnimation()`
  - 解除暂停状态：`IsPaused=false`，重置帧索引
  - 设置主菜单状态为 `MainMenuStateZombieHandPlaying`
  - 调用 `disableAllButtons()` 阻塞其他交互
- [x] 2.4. 实现动画播放完成检测
  - 在 `MainMenuScene.Update()` 中调用 `checkZombieHandAnimationFinished()`
  - 使用方法 1：检查 `ReanimComponent.IsFinished`
  - 当 `IsFinished=true` 时触发场景切换
- [x] 2.5. 动画完成后切换场景
  - 在 `checkZombieHandAnimationFinished()` 中实现场景切换
  - 调用 `NewGameScene()` 并 `sceneManager.SwitchTo()`
  - 加载关卡：从存档读取 `highestLevel` 或默认 "1-1"
- [x] 2.6. 测试僵尸手掌过渡动画
  - 验证点击"冒险模式"后僵尸手掌动画播放
  - 验证动画播放期间其他按钮不可点击
  - 验证动画播放完成后正确切换到下一场景
  - 验证手掌位置和动画效果符合原版游戏

### Task 3: 播放石碑升起动画（AC: 3）
- [x] 3.1. 配置石碑升起动画组合
  - 在 `selectorscreen.yaml` 中添加 `open` 组合
  - 设置动画名称：`anim_open`
  - 配置默认动画为 `anim_open`
- [x] 3.2. 在主菜单初始化时播放动画
  - 在 `MainMenuScene.Enter()` 中添加动画播放命令
  - 使用 `AnimationCommandComponent` 触发播放
  - 确保动画在场景加载完成后立即播放
- [x] 3.3. 测试动画效果
  - 验证石碑升起动画流畅
  - 验证动画时机正确（主菜单初始化）

### Task 4: 与 ReanimSystem 集成（AC: 4, 5）
- [x] 4.1. 确保使用 ECS 零耦合原则
  - 使用 `AnimationCommandComponent` 而非直接调用 ReanimSystem
  - 动画播放通过组件通信，不直接引用系统
- [x] 4.2. 验证性能影响
  - 确保动画播放时 FPS 稳定在 60 FPS
  - 检查内存占用无异常增长
- [x] 4.3. 测试配置化管理
  - 修改 `selectorscreen.yaml` 中的动画配置
  - 验证热修改生效（重启游戏后加载新配置）

### Task 5: 文档更新
- [x] 5.1. 更新 CLAUDE.md
  - 添加 Reanim 动画配置系统说明（已在 Epic 13 中完成）
  - 说明如何使用 AnimationCommandComponent 触发动画
- [ ] 5.2. 更新用户手册（如适用）
  - 说明主菜单动画效果（可选）

---

## Dev Notes

### Previous Story Insights

**来自 Story 12.1（石碑菜单系统）的经验：**
- ✅ Reanim 轨道渲染已验证可行
- ✅ 动画播放通过 `AnimationCommandComponent` 触发
- ✅ 主菜单 Reanim 实体已创建（`MainMenuScene.bgEntity`）

**来自 Epic 13（Reanim 现代化）的经验：**
- ✅ 配置驱动的动画系统已完成
- ✅ 使用 `ReanimConfigManager` 加载配置
- ✅ 使用 `AnimationCommandComponent` 遵循 ECS 零耦合原则

### Architecture Context

#### 僵尸手掌动画实现指南（AC2 - 待完成）

**功能说明**：
- 僵尸手掌动画作为**场景过渡动画**，在点击"冒险模式"按钮后播放
- 播放完成后才切换到关卡选择场景（或直接进入关卡）
- 阻塞式播放：动画期间不可中断，禁用其他交互

**Reanim 文件分析**：
- 文件位置：`data/reanim/Zombie_hand.reanim`
- FPS：30 帧/秒
- 轨道：
  - `arm`：僵尸手臂（从地下升起）
  - `hand`：僵尸手掌（跟随手臂移动）
  - 可能包含手指轨道（`finger1`, `finger2` 等）
  - 可能包含石头碎片轨道（`rock1`-`rock6`）

**图片资源映射**：
```yaml
# data/reanim_config/zombie_hand.yaml（需创建）
id: "zombie_hand"
name: "ZombieHand"
reanim_file: "data/reanim/Zombie_hand.reanim"
default_animation: "anim_rise"  # 默认动画（手掌升起）

images:
  IMAGE_REANIM_ZOMBIE_HAND_ARM: "assets/reanim/Zombie_hand_arm.png"
  IMAGE_REANIM_ZOMBIE_HAND_HAND: "assets/reanim/Zombie_hand_hand.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER1_1: "assets/reanim/Zombie_hand_finger1_1.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER1_2: "assets/reanim/Zombie_hand_finger1_2.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER2_1: "assets/reanim/Zombie_hand_finger2_1.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER2_2: "assets/reanim/Zombie_hand_finger2_2.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER3_1: "assets/reanim/Zombie_hand_finger3_1.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER3_2: "assets/reanim/Zombie_hand_finger3_2.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER4_1: "assets/reanim/Zombie_hand_finger4_1.png"
  IMAGE_REANIM_ZOMBIE_HAND_FINGER4_2: "assets/reanim/Zombie_hand_finger4_2.png"
  IMAGE_REANIM_ZOMBIE_HAND_ROCK1: "assets/reanim/Zombie_hand_rock1.png"
  IMAGE_REANIM_ZOMBIE_HAND_ROCK2: "assets/reanim/Zombie_hand_rock2.png"
  IMAGE_REANIM_ZOMBIE_HAND_ROCK3: "assets/reanim/Zombie_hand_rock3.png"
  IMAGE_REANIM_ZOMBIE_HAND_ROCK4: "assets/reanim/Zombie_hand_rock4.png"
  IMAGE_REANIM_ZOMBIE_HAND_ROCK5: "assets/reanim/Zombie_hand_rock5.png"
  IMAGE_REANIM_ZOMBIE_HAND_ROCK6: "assets/reanim/Zombie_hand_rock6.png"
  IMAGE_REANIM_ZOMBIE_HAND_OVERLAY: "assets/reanim/Zombie_hand_overlay.png"

available_animations:
  - name: "anim_rise"
    display_name: "手掌升起"

# 不需要 animation_combos，使用单动画模式
```

**主菜单集成代码示例**：

```go
// MainMenuScene 状态枚举
type MainMenuState int

const (
    MainMenuStateNormal MainMenuState = iota  // 正常状态
    MainMenuStateZombieHandPlaying            // 僵尸手掌动画播放中
)

// MainMenuScene.Enter() 中创建僵尸手掌实体（初始隐藏）
func (m *MainMenuScene) Enter() {
    // ... 现有代码

    // 创建僵尸手掌实体（但不播放动画）
    m.zombieHandEntity = entities.NewReanimEntity(
        m.entityManager,
        m.resourceManager,
        "zombie_hand",  // 配置 ID
        400.0,          // X 位置（需根据原版游戏调整）
        300.0,          // Y 位置（需根据原版游戏调整）
    )

    // 标记为 UI 元素（不受摄像机影响）
    ecs.AddComponent(m.entityManager, m.zombieHandEntity, &components.UIComponent{})

    // 初始状态
    m.state = MainMenuStateNormal
    m.pendingScene = ""
}

// 冒险模式按钮回调（修改后）
func (m *MainMenuScene) onAdventureModeClicked() {
    // 触发僵尸手掌动画
    ecs.AddComponent(m.entityManager, m.zombieHandEntity, &components.AnimationCommandComponent{
        UnitID:        "zombie_hand",
        AnimationName: "anim_rise",
        Processed:     false,
    })

    // 切换状态，阻塞其他交互
    m.state = MainMenuStateZombieHandPlaying
    m.pendingScene = "LevelSelectScene"  // 或直接进入关卡

    // 禁用所有按钮交互（可选）
    m.disableAllButtons()
}

// MainMenuScene.Update() 中检测动画完成
func (m *MainMenuScene) Update(deltaTime float64) error {
    // ... 现有代码

    // 检测僵尸手掌动画播放完成
    if m.state == MainMenuStateZombieHandPlaying {
        reanimComp, ok := ecs.GetComponent[*components.ReanimComponent](m.entityManager, m.zombieHandEntity)
        if !ok {
            return fmt.Errorf("僵尸手掌实体缺少 ReanimComponent")
        }

        // 方法 1：检查动画是否播放完成（需要 ReanimComponent 提供此字段）
        if reanimComp.IsAnimationFinished() {  // 假设有此方法
            // 切换场景
            m.sceneManager.SwitchScene(m.pendingScene)
            return nil
        }

        // 方法 2：使用计时器估算（备用方案）
        // 假设动画时长约 1.5 秒（需根据实际动画调整）
        m.animationElapsed += deltaTime
        if m.animationElapsed >= 1.5 {
            m.sceneManager.SwitchScene(m.pendingScene)
            return nil
        }
    }

    return nil
}

func (m *MainMenuScene) disableAllButtons() {
    // 遍历所有按钮实体，禁用交互
    buttons := ecs.GetEntitiesWith2[*components.ButtonComponent, *components.ClickableComponent](m.entityManager)
    for _, btn := range buttons {
        clickable, _ := ecs.GetComponent[*components.ClickableComponent](m.entityManager, btn)
        clickable.Enabled = false
    }
}
```

**MainMenuScene 字段扩展**：
```go
type MainMenuScene struct {
    // ... 现有字段
    zombieHandEntity   ecs.EntityID    // 僵尸手掌实体 ID
    state              MainMenuState   // 主菜单状态
    pendingScene       string          // 待切换的场景名称
    animationElapsed   float64         // 动画播放时长（备用方案）
}
```

**动画完成检测方案**：

**方案 1（推荐）**：在 `ReanimComponent` 中添加 `IsAnimationFinished()` 方法
```go
// pkg/components/reanim_component.go
func (r *ReanimComponent) IsAnimationFinished() bool {
    if len(r.CurrentAnimations) == 0 {
        return true
    }

    // 检查第一个动画是否播放完成
    animName := r.CurrentAnimations[0]
    if physicalFrame, ok := r.PhysicalFrames[animName]; ok {
        totalFrames := r.GetTotalFrames(animName)
        return physicalFrame >= totalFrames - 1
    }

    return false
}
```

**方案 2**：添加 `AnimationFinishedComponent` 标记
```go
// pkg/components/animation_finished_component.go
type AnimationFinishedComponent struct {
    AnimationName string  // 完成的动画名称
}

// ReanimSystem 在动画播放完成时添加此组件
```

**方案 3**：使用计时器估算动画时长（最简单，但不够精确）
```go
// 根据动画帧数计算时长
// Zombie_hand.reanim 约 30 帧，FPS=30，时长约 1 秒
const zombieHandAnimDuration = 1.0
```

#### Reanim 动画配置系统（Epic 13）

**配置文件位置**：`data/reanim_config/selectorscreen.yaml`

**配置格式示例**：
```yaml
id: "selectorscreen"
name: "SelectorScreen"
reanim_file: "data/reanim/SelectorScreen.reanim"
default_animation: "anim_open"

images:
  IMAGE_REANIM_SELECTORSCREEN_BG: "assets/reanim/SelectorScreen_BG.png"
  IMAGE_REANIM_SELECTORSCREEN_ZOMBIEHAND: "assets/reanim/SelectorScreen_Zombiehand.png"
  # ... 其他图片映射

available_animations:
  - name: "anim_open"
    display_name: "石碑升起"
  - name: "anim_zombiehand"
    display_name: "僵尸手掌升起"
  - name: "anim_sign"
    display_name: "木牌显示"
  - name: "anim_grass"
    display_name: "草丛动画"

animation_combos:
  - name: "open"
    display_name: "开场动画"
    animations: ["anim_open"]
  - name: "zombiehand"
    display_name: "僵尸手掌"
    animations: ["anim_zombiehand"]
```

#### 动画触发方式（ECS 零耦合）

**推荐方式**：使用 `AnimationCommandComponent`

```go
// ✅ 正确：使用 AnimationCommandComponent 触发动画
ecs.AddComponent(em, entityID, &components.AnimationCommandComponent{
    UnitID:    "selectorscreen",
    ComboName: "zombiehand",
    Processed: false,
})
```

**不推荐方式**：直接调用 ReanimSystem（已废弃）

```go
// ❌ 错误：违反 ECS 零耦合原则
reanimSystem.PlayCombo(entityID, "selectorscreen", "zombiehand")
```

#### 动画播放时机控制

**方案 1：使用 TimerComponent（推荐）**

```go
// 创建延迟触发器实体
timerEntity := em.NewEntity()
ecs.AddComponent(em, timerEntity, &components.TimerComponent{
    Duration: 2.0, // 延迟 2 秒
    Elapsed:  0.0,
})
ecs.AddComponent(em, timerEntity, &components.AnimationTriggerComponent{
    TargetEntity: bgEntity,
    UnitID:       "selectorscreen",
    ComboName:    "zombiehand",
})
```

**方案 2：在 MainMenuScene.Update() 中手动控制**

```go
func (m *MainMenuScene) Update(deltaTime float64) error {
    m.elapsedTime += deltaTime

    // 2 秒后触发僵尸手掌动画
    if m.elapsedTime >= 2.0 && !m.zombieHandPlayed {
        ecs.AddComponent(m.entityManager, m.bgEntity, &components.AnimationCommandComponent{
            UnitID:    "selectorscreen",
            ComboName: "zombiehand",
            Processed: false,
        })
        m.zombieHandPlayed = true
    }

    return nil
}
```

### Project Structure

**新增/修改文件：**
```
data/
└── reanim_config/
    └── selectorscreen.yaml         # 新增：SelectorScreen 动画配置

pkg/scenes/
└── main_menu_scene.go              # 修改：添加动画播放逻辑
```

**已存在文件（无需修改）：**
```
pkg/systems/
└── reanim_system.go                # 已存在：Reanim 动画系统

pkg/components/
└── animation_command_component.go  # 已存在：动画命令组件
```

### Testing Strategy

**手动测试场景：**
1. ✅ 启动游戏，验证石碑升起动画播放
2. ⏸️ 验证僵尸手掌动画在 2-3 秒后播放
3. ✅ 验证动画播放流畅，无卡顿
4. ✅ 验证 FPS 稳定在 60 FPS

**单元测试（可选）：**
- 测试 `selectorscreen.yaml` 配置正确加载
- 测试 `AnimationCommandComponent` 正确添加

---

## Testing

### Integration Testing

**集成测试场景：**
1. ✅ 启动主菜单 → 验证石碑升起动画播放
2. ⏸️ 等待 2-3 秒 → 验证僵尸手掌动画播放
3. ✅ 验证动画结束后保持正确状态
4. ✅ 验证动画播放不影响其他 UI 交互

### Performance Requirements

- 动画播放时 FPS ≥ 60 FPS
- 内存占用增长 < 50MB
- 动画加载时间 < 100ms

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-18 | 1.0 | 追溯创建 Story，记录已完成功能和待实现功能 | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used

- **claude-sonnet-4-5-20250929** (Story 12.6 Task 2 implementation)

### Debug Log References

无

### Completion Notes

**实现完成度**: 100% (5/5 AC 完成)

**已完成功能**:
1. ✅ AC1: 加载 SelectorScreen.reanim 文件（Story 12.1 中完成）
2. ✅ AC2: 播放僵尸手掌升起动画（本次实现）
   - 创建 `zombie_hand.yaml` 配置文件（单一动画模式）
   - 创建 `NewZombieHandEntity()` 工厂函数
   - 在主菜单中创建僵尸手掌实体（初始暂停）
   - 实现点击"冒险模式"按钮触发动画逻辑
   - 实现动画完成检测和场景切换
3. ✅ AC3: 播放石碑升起动画（Story 12.1 中完成）
4. ✅ AC4: 与 ReanimSystem 集成（Epic 13 中完成）
5. ✅ AC5: 动画配置化管理（Epic 13 中完成）

**关键设计决策**:
- ✅ Zombie_hand.reanim 是单一动画文件（无命名动画），直接播放轨道数据
- ✅ 使用 `MainMenuState` 枚举管理主菜单状态（Normal / ZombieHandPlaying）
- ✅ 使用 `ReanimComponent.IsFinished` 检测动画完成
- ✅ 动画播放期间禁用所有按钮交互
- ✅ 僵尸手掌实体初始为暂停状态，点击后解除暂停

**技术实现**:
- 新增文件：
  - `pkg/entities/zombie_hand_factory.go` (僵尸手掌实体工厂)
  - `data/reanim_config/zombie_hand.yaml` (配置文件)
- 修改文件：
  - `pkg/scenes/main_menu_scene.go` (添加状态管理、动画触发、完成检测)

### File List

**新增文件**:
- pkg/entities/zombie_hand_factory.go (僵尸手掌实体工厂)
- data/reanim_config/zombie_hand.yaml (更新为单一动画模式)

**已修改文件**:
- pkg/scenes/main_menu_scene.go (添加僵尸手掌动画逻辑、按钮阻塞逻辑)
- pkg/scenes/main_menu_scene_test.go (添加按钮阻塞测试)

### Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-19 | 1.1 | 修复 Task 2.6 - 动画播放期间按钮阻塞逻辑 | James (Dev) |

**修复详情**:
- 问题：僵尸手掌动画播放期间，其他按钮仍然可以点击
- 根因：Update() 函数中缺少对 menuState 的检查
- 解决方案：
  1. 在 Update() 中添加提前返回逻辑：当 `menuState == MainMenuStateZombieHandPlaying` 时，清空 hover 状态并返回
  2. 这样可以阻塞所有按钮的悬停和点击检测
- 测试：添加 `TestZombieHandAnimationBlocksButtons` 单元测试验证修复
- 结果：✅ 所有测试通过，按钮在动画播放期间正确阻塞

---

## QA Results

### Review Status

⏸️ **待审查** - 等待 AC2 完成后进行完整 QA 审查

### Partial Completion Assessment

**已完成部分评估**: ⭐⭐⭐⭐ (良好)

- ✅ 石碑升起动画实现质量优秀
- ✅ 配置化管理符合架构设计
- ✅ ECS 零耦合原则严格遵循
- ⏸️ 僵尸手掌动画待实现

### Recommended Next Steps

1. 创建 **Story 12.8: 僵尸手掌动画补充**
2. 实现 AC2（僵尸手掌升起动画）
3. 完成后重新进行 QA 审查

---
