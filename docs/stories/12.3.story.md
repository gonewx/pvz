# Story 12.3: 对话框系统基础 (Dialog System Foundation)

## Status
Draft

---

## Story

**As a** 玩家（游戏玩家）,
**I want** 在点击未解锁的菜单选项或功能按钮时看到一个弹出对话框，清楚地告诉我该功能的解锁条件,
**so that** 我能了解如何解锁这些功能，并对游戏进度有清晰的认知。

---

## Story Context

### Existing System Integration
- **Integrates with**: 主菜单场景系统（`pkg/scenes/main_menu_scene.go`）
- **Technology**: Go, Ebitengine, ECS 架构
- **Follows pattern**: UI 实体工厂模式
- **Touch points**:
  - `MainMenuScene.onMenuButtonClicked()` - 菜单按钮点击回调（Story 12.1）
  - `MainMenuScene.onBottomButtonClicked()` - 底部按钮点击回调（Story 12.2）
  - `ResourceManager.LoadImageByID()` - 加载对话框资源
  - 实体渲染逻辑（`MainMenuScene.Draw()`）

### Problem Description

**当前对话框状态：**
- ❌ **没有对话框系统**（点击未解锁按钮无反馈）
- ❌ **无法显示提示信息**（玩家不知道解锁条件）
- ❌ **缺少九宫格拉伸渲染**（对话框大小需要动态调整）

**原版对话框规格：**
根据 `docs/main-menu-spec.md` 和 `docs/.meta/data/data.md`：

1. **对话框外观：**
   - 材质：紫灰色半透明背景
   - 边框：不规则石质边缘
   - 顶部装饰：骷髅头图案（`dialog_header.png`）
   - 居中显示，覆盖主界面

2. **对话框内容：**
   - 标题：黄色文字（如"未解锁！"）
   - 说明文字：黄色文字（如"进行更多新冒险来解锁生存模式。"）
   - 按钮：绿色文字"确定"，灰色按钮背景

3. **交互逻辑：**
   - 点击"确定"按钮 → 关闭对话框
   - 点击对话框外部区域 → 关闭对话框
   - 按 ESC 键 → 关闭对话框
   - 对话框打开时显示半透明遮罩

4. **九宫格拉伸系统：**
   - 对话框使用 13 张图片组成（九宫格资源）
   - 支持动态调整大小（根据文字长度）
   - 边角固定，边缘和中心拉伸

**技术挑战：**
1. 需要实现九宫格拉伸渲染算法
2. 需要处理文字换行和布局
3. 需要实现模态对话框（阻止背景交互）
4. 需要管理对话框生命周期（创建-显示-关闭）

---

## Acceptance Criteria

### Functional Requirements:

**AC1: 未解锁提示对话框正确显示**
- Given: 点击未解锁的菜单选项（如小游戏）
- When: 点击事件触发
- Then:
  - 应显示对话框（居中）
  - 显示半透明遮罩（覆盖背景）
  - 对话框标题："未解锁！"
  - 对话框内容："进行更多新冒险来解锁XX模式。"
  - 显示"确定"按钮

**AC2: 九宫格拉伸正确渲染**
- Given: 对话框需要显示
- When: 调用对话框渲染函数
- Then:
  - 四个边角正确显示（不拉伸）
  - 四个边缘正确拉伸（水平或垂直）
  - 中心区域正确拉伸（双向）
  - 顶部骷髅头装饰正确显示

**AC3: 对话框交互正确响应**
- Given: 对话框已显示
- When: 点击"确定"按钮
- Then:
  - 对话框关闭（实体销毁）
  - 遮罩消失
  - 恢复背景交互

- Given: 对话框已显示
- When: 点击对话框外部区域
- Then:
  - 对话框关闭
  - 遮罩消失

- Given: 对话框已显示
- When: 按 ESC 键
- Then:
  - 对话框关闭
  - 遮罩消失

**AC4: 模态行为正确**
- Given: 对话框已显示
- When: 点击背景的菜单按钮
- Then:
  - 点击事件被对话框拦截
  - 菜单按钮不响应（不跳转场景）
  - 对话框保持显示

### Integration Requirements:

**AC5: 与 Story 12.1 集成**
- 点击未解锁的菜单按钮时显示对话框
- 对话框内容根据模式类型动态生成
- 关闭对话框后菜单按钮恢复正常

**AC6: 与 Story 12.2 集成**
- 点击选项/帮助按钮时显示对话框（临时实现）
- 对话框显示"功能开发中"等提示
- 未来可替换为实际功能对话框

**AC7: 资源加载正确**
- 所有 13 张对话框图片正确加载
- 骷髅头装饰图片正确加载
- 资源加载失败时有 fallback（使用纯色矩形）

### Quality Requirements:

**AC8: 性能要求**
- 对话框打开/关闭动画流畅（如有）
- 九宫格拉伸渲染性能良好（< 1ms）
- 无内存泄漏（对话框实体正确管理）

**AC9: 代码质量**
- 九宫格拉伸算法封装为独立函数
- 对话框组件可复用（其他场景也能使用）
- 遵循 ECS 架构原则
- 代码注释完整，通过 linter 检查

**AC10: 测试覆盖**
- 单元测试覆盖九宫格拉伸算法
- 集成测试覆盖对话框显示和关闭流程
- 手工测试验证 UI 渲染和交互

---

## Tasks / Subtasks

### Task 1: 设计对话框组件和九宫格系统 (AC: 1, 2, 9)

- [ ] **1.1: 设计 DialogComponent 组件**
  - [ ] 定义组件字段（Title, Message, Buttons, Parts 等）
  - [ ] 添加 GoDoc 注释
  - [ ] 创建文件：`pkg/components/dialog_component.go`
  - [ ] 组件结构：
    ```go
    type DialogComponent struct {
        Title       string              // 对话框标题（如"未解锁！"）
        Message     string              // 对话框消息（如"进行更多新冒险..."）
        Buttons     []DialogButton      // 按钮列表（如["确定"]）
        Parts       *DialogParts        // 九宫格图片资源
        IsVisible   bool                // 是否可见
        Width       float64             // 对话框宽度
        Height      float64             // 对话框高度
        // TODO: 添加文字渲染相关字段（字体、颜色等）
    }

    type DialogButton struct {
        Label       string              // 按钮文字
        OnClick     func()              // 点击回调
        // TODO: 添加按钮图片资源
    }
    ```

- [ ] **1.2: 设计 DialogParts 结构（九宫格资源）**
  - [ ] 定义九宫格图片结构：
    ```go
    type DialogParts struct {
        // 四个边角（固定大小，不拉伸）
        TopLeft     *ebiten.Image  // dialog_topleft.png
        TopRight    *ebiten.Image  // dialog_topright.png
        BottomLeft  *ebiten.Image  // dialog_bottomleft.png
        BottomRight *ebiten.Image  // dialog_bottomright.png

        // 四个边缘（单向拉伸）
        TopMiddle    *ebiten.Image  // dialog_topmiddle.png
        BottomMiddle *ebiten.Image  // dialog_bottommiddle.png
        CenterLeft   *ebiten.Image  // dialog_centerleft.png
        CenterRight  *ebiten.Image  // dialog_centerright.png

        // 中心区域（双向拉伸）
        CenterMiddle *ebiten.Image  // dialog_centermiddle.png

        // 特殊装饰
        Header       *ebiten.Image  // dialog_header.png (骷髅头)

        // 大对话框的额外部分（可选）
        BigBottomLeft   *ebiten.Image  // dialog_bigbottomleft.png
        BigBottomMiddle *ebiten.Image  // dialog_bigbottommiddle.png
        BigBottomRight  *ebiten.Image  // dialog_bigbottomright.png
    }
    ```

- [ ] **1.3: 实现九宫格拉伸算法**
  - [ ] 创建函数：`func renderNinePatch(screen *ebiten.Image, parts *DialogParts, x, y, width, height float64)`
  - [ ] 算法步骤：
    1. 计算边角大小（从图片获取）
    2. 计算边缘和中心的拉伸尺寸
    3. 绘制四个边角（固定位置，不拉伸）
    4. 绘制四个边缘（单向拉伸）
    5. 绘制中心区域（双向拉伸）
  - [ ] 详细实现参考 Dev Notes 部分

### Task 2: 创建对话框实体工厂 (AC: 1, 7, 9)

- [ ] **2.1: 创建对话框实体工厂**
  - [ ] 创建文件：`pkg/entities/dialog_factory.go`
  - [ ] 实现函数：
    ```go
    // NewDialogEntity 创建通用对话框实体
    func NewDialogEntity(
        em *ecs.EntityManager,
        rm *game.ResourceManager,
        title string,
        message string,
        buttons []string,
    ) ecs.EntityID
    ```

- [ ] **2.2: 加载九宫格资源**
  - [ ] 实现辅助函数：
    ```go
    func loadDialogParts(rm *game.ResourceManager) (*DialogParts, error) {
        parts := &DialogParts{}

        // 加载所有 13 张图片
        parts.TopLeft, _ = rm.LoadImageByID("IMAGE_DIALOG_TOPLEFT")
        parts.TopRight, _ = rm.LoadImageByID("IMAGE_DIALOG_TOPRIGHT")
        // ... 加载其他 11 张图片

        return parts, nil
    }
    ```
  - [ ] 处理资源加载失败（使用 fallback）

- [ ] **2.3: 创建对话框实体**
  - [ ] 创建对话框实体
  - [ ] 添加组件：
    - `DialogComponent` - 对话框数据
    - `PositionComponent` - 对话框位置（居中）
    - `UIComponent` - UI 标记
  - [ ] 计算对话框大小（根据文字长度）
  - [ ] 计算居中位置

### Task 3: 实现对话框渲染系统 (AC: 2, 8)

- [ ] **3.1: 创建 DialogRenderSystem**
  - [ ] 创建文件：`pkg/systems/dialog_render_system.go`
  - [ ] 实现 `Draw()` 方法：
    1. 查询所有对话框实体
    2. 绘制半透明遮罩（覆盖整个屏幕）
    3. 调用九宫格拉伸算法绘制对话框背景
    4. 绘制骷髅头装饰（顶部中央）
    5. 绘制标题文字
    6. 绘制消息文字（支持换行）
    7. 绘制按钮

- [ ] **3.2: 实现遮罩渲染**
  - [ ] 创建半透明矩形（覆盖整个屏幕）
  - [ ] 颜色：黑色，透明度 50%
  - [ ] 代码示例：
    ```go
    // 绘制半透明遮罩
    mask := ebiten.NewImage(WindowWidth, WindowHeight)
    mask.Fill(color.RGBA{0, 0, 0, 128})  // 黑色，50% 透明度
    screen.DrawImage(mask, &ebiten.DrawImageOptions{})
    ```

- [ ] **3.3: 实现文字渲染**
  - [ ] 使用 `ebitenutil.DebugPrintAt()` 或自定义字体渲染
  - [ ] 支持文字换行（根据对话框宽度）
  - [ ] 文字颜色：黄色（RGB: 255, 255, 0）
  - [ ] TODO: 后续可替换为位图字体渲染

### Task 4: 实现对话框交互逻辑 (AC: 3, 4)

- [ ] **4.1: 创建 DialogInputSystem**
  - [ ] 创建文件：`pkg/systems/dialog_input_system.go`
  - [ ] 实现 `Update()` 方法：
    1. 检测鼠标点击
    2. 检测 ESC 键按下
    3. 判断点击位置（按钮/对话框外部）
    4. 关闭对话框（销毁实体）

- [ ] **4.2: 实现模态行为**
  - [ ] 在 MainMenuScene 中添加对话框检测：
    ```go
    func (m *MainMenuScene) Update(deltaTime float64) {
        // 如果有对话框打开，拦截所有输入
        if m.hasOpenDialog() {
            m.updateDialogInput()
            return  // 阻止背景交互
        }

        // 正常更新菜单按钮
        m.updateMenuButtons()
        m.updateBottomButtons()
    }
    ```

- [ ] **4.3: 实现对话框关闭逻辑**
  - [ ] 创建关闭函数：
    ```go
    func (m *MainMenuScene) closeDialog(dialogEntityID ecs.EntityID) {
        // 销毁对话框实体
        m.entityManager.DestroyEntity(dialogEntityID)

        // 清除对话框引用
        m.currentDialog = 0

        // 播放关闭音效（可选）
        // ...
    }
    ```

### Task 5: 集成到主菜单场景 (AC: 5, 6)

- [ ] **5.1: 修改 MainMenuScene 结构体**
  - [ ] 添加字段：
    ```go
    currentDialog   ecs.EntityID        // 当前打开的对话框实体（0 表示无）
    dialogRenderSys *DialogRenderSystem // 对话框渲染系统
    dialogInputSys  *DialogInputSystem  // 对话框输入系统
    ```

- [ ] **5.2: 在 NewMainMenuScene 中初始化系统**
  - [ ] 创建对话框渲染系统
  - [ ] 创建对话框输入系统

- [ ] **5.3: 修改 onMenuButtonClicked 回调**
  - [ ] 在 Story 12.1 的按钮点击回调中添加对话框逻辑：
    ```go
    func (m *MainMenuScene) onMenuButtonClicked(btnType MenuButtonType, isUnlocked bool) {
        if !isUnlocked {
            // 显示未解锁提示对话框
            message := getUnlockMessage(btnType)
            m.showUnlockedDialog("未解锁！", message)
            return
        }

        // 已解锁，执行正常逻辑
        // ...
    }

    func getUnlockMessage(btnType MenuButtonType) string {
        switch btnType {
        case MenuButtonMiniGame:
            return "进行更多新冒险来解锁玩玩小游戏。"
        case MenuButtonPuzzle:
            return "进行更多新冒险来解锁解谜模式。"
        case MenuButtonSurvival:
            return "进行更多新冒险来解锁生存模式。"
        default:
            return "此功能尚未解锁。"
        }
    }
    ```

- [ ] **5.4: 修改 onBottomButtonClicked 回调**
  - [ ] 在 Story 12.2 的按钮点击回调中添加对话框逻辑：
    ```go
    func (m *MainMenuScene) onBottomButtonClicked(btnType BottomButtonType) {
        switch btnType {
        case BottomButtonOptions:
            m.showUnlockedDialog("选项", "设置功能开发中，敬请期待！")
        case BottomButtonHelp:
            m.showUnlockedDialog("帮助", "帮助功能开发中，敬请期待！")
        case BottomButtonQuit:
            os.Exit(0)
        }
    }
    ```

- [ ] **5.5: 实现 showUnlockedDialog 方法**
  - [ ] 创建方法：
    ```go
    func (m *MainMenuScene) showUnlockedDialog(title, message string) {
        // 关闭已有对话框（如果有）
        if m.currentDialog != 0 {
            m.closeDialog(m.currentDialog)
        }

        // 创建新对话框
        dialogEntity := entities.NewDialogEntity(
            m.entityManager,
            m.resourceManager,
            title,
            message,
            []string{"确定"},
        )

        m.currentDialog = dialogEntity
    }
    ```

### Task 6: 配置资源 ID (AC: 7)

- [ ] **6.1: 检查 resources.yaml 配置**
  - [ ] 确认以下 13 张对话框图片已配置：
    - `IMAGE_DIALOG_TOPLEFT`, `IMAGE_DIALOG_TOPMIDDLE`, `IMAGE_DIALOG_TOPRIGHT`
    - `IMAGE_DIALOG_CENTERLEFT`, `IMAGE_DIALOG_CENTERMIDDLE`, `IMAGE_DIALOG_CENTERRIGHT`
    - `IMAGE_DIALOG_BOTTOMLEFT`, `IMAGE_DIALOG_BOTTOMMIDDLE`, `IMAGE_DIALOG_BOTTOMRIGHT`
    - `IMAGE_DIALOG_BIGBOTTOMLEFT`, `IMAGE_DIALOG_BIGBOTTOMMIDDLE`, `IMAGE_DIALOG_BIGBOTTOMRIGHT`
    - `IMAGE_DIALOG_HEADER`

- [ ] **6.2: 添加缺失的资源配置**
  - [ ] 如果资源未配置，添加到 `assets/config/resources.yaml`
  - [ ] 验证资源文件存在于 `assets/images/` 目录

### Task 7: 测试和验证 (AC: 8, 10)

- [ ] **7.1: 编写单元测试**
  - [ ] 测试文件：`pkg/systems/dialog_render_system_test.go`
  - [ ] 测试用例：
    - `TestNinePatchRendering` - 验证九宫格算法正确性
    - `TestDialogSize` - 验证对话框大小计算
    - `TestDialogPosition` - 验证对话框居中位置
  - [ ] 运行测试：`go test ./pkg/systems -v`

- [ ] **7.2: 集成测试**
  - [ ] 测试场景 1：点击未解锁菜单按钮
    - 启动游戏（新存档，只有冒险模式解锁）
    - 点击"玩玩小游戏"按钮
    - 验证对话框显示
    - 验证对话框内容："进行更多新冒险来解锁玩玩小游戏。"
    - 点击"确定"按钮，验证对话框关闭

  - [ ] 测试场景 2：点击底部按钮
    - 点击"选项"按钮
    - 验证对话框显示："设置功能开发中"
    - 点击对话框外部区域，验证对话框关闭

  - [ ] 测试场景 3：ESC 键关闭
    - 打开对话框
    - 按 ESC 键
    - 验证对话框关闭

  - [ ] 测试场景 4：模态行为
    - 打开对话框
    - 点击背景的冒险模式按钮
    - 验证按钮不响应（不跳转场景）
    - 关闭对话框后再次点击，验证按钮响应

- [ ] **7.3: 视觉对比测试**
  - [ ] 截图当前实现的对话框
  - [ ] 与原版截图对比
  - [ ] 调整九宫格拉伸参数和文字布局

### Task 8: 代码质量检查 (AC: 9)

- [ ] **8.1: 代码格式化**
  - [ ] 运行 `gofmt -w pkg/components/dialog_component.go`
  - [ ] 运行 `gofmt -w pkg/entities/dialog_factory.go`
  - [ ] 运行 `gofmt -w pkg/systems/dialog_render_system.go`
  - [ ] 运行 `gofmt -w pkg/systems/dialog_input_system.go`

- [ ] **8.2: Linter 检查**
  - [ ] 运行 `golangci-lint run ./pkg/components`
  - [ ] 运行 `golangci-lint run ./pkg/entities`
  - [ ] 运行 `golangci-lint run ./pkg/systems`
  - [ ] 修复所有 warnings 和 errors

- [ ] **8.3: 代码审查**
  - [ ] 检查九宫格算法的性能
  - [ ] 检查对话框实体的正确销毁（无内存泄漏）
  - [ ] 检查代码注释完整性

---

## Dev Notes

### Relevant Unified Project Structure

**新增文件：**
- `pkg/components/dialog_component.go` - 对话框组件定义
- `pkg/entities/dialog_factory.go` - 对话框实体工厂
- `pkg/systems/dialog_render_system.go` - 对话框渲染系统
- `pkg/systems/dialog_input_system.go` - 对话框输入系统
- `pkg/systems/dialog_render_system_test.go` - 单元测试

**修改文件：**
- `pkg/scenes/main_menu_scene.go` - 主菜单场景逻辑（集成对话框）
- `assets/config/resources.yaml` - 资源配置（如果需要）

**依赖文件：**
- `pkg/game/resource_manager.go` - 加载资源（已存在）
- `pkg/components/ui_component.go` - UI 组件基类（已存在）
- `pkg/components/position_component.go` - 位置组件（已存在）

---

### Technical Design Details

#### 1. 九宫格拉伸算法详解

**核心思想：**
- 将对话框分为 9 个区域（4 个边角 + 4 个边缘 + 1 个中心）
- 边角固定大小，不拉伸
- 边缘单向拉伸（水平或垂直）
- 中心双向拉伸

**实现代码：**

```go
// renderNinePatch 使用九宫格拉伸渲染对话框
// x, y: 对话框左上角位置
// width, height: 对话框总大小
func renderNinePatch(screen *ebiten.Image, parts *DialogParts, x, y, width, height float64) {
    // 1. 获取边角大小（从图片获取）
    tlBounds := parts.TopLeft.Bounds()
    cornerWidth := float64(tlBounds.Dx())
    cornerHeight := float64(tlBounds.Dy())

    // 2. 计算拉伸区域大小
    stretchWidth := width - cornerWidth*2      // 中间区域宽度
    stretchHeight := height - cornerHeight*2    // 中间区域高度

    // 3. 绘制四个边角（固定位置，不拉伸）
    // 左上角
    drawImage(screen, parts.TopLeft, x, y, 1.0, 1.0)

    // 右上角
    drawImage(screen, parts.TopRight, x+width-cornerWidth, y, 1.0, 1.0)

    // 左下角
    drawImage(screen, parts.BottomLeft, x, y+height-cornerHeight, 1.0, 1.0)

    // 右下角
    drawImage(screen, parts.BottomRight, x+width-cornerWidth, y+height-cornerHeight, 1.0, 1.0)

    // 4. 绘制四个边缘（单向拉伸）
    // 上边缘（水平拉伸）
    tmBounds := parts.TopMiddle.Bounds()
    scaleX := stretchWidth / float64(tmBounds.Dx())
    drawImage(screen, parts.TopMiddle, x+cornerWidth, y, scaleX, 1.0)

    // 下边缘（水平拉伸）
    drawImage(screen, parts.BottomMiddle, x+cornerWidth, y+height-cornerHeight, scaleX, 1.0)

    // 左边缘（垂直拉伸）
    clBounds := parts.CenterLeft.Bounds()
    scaleY := stretchHeight / float64(clBounds.Dy())
    drawImage(screen, parts.CenterLeft, x, y+cornerHeight, 1.0, scaleY)

    // 右边缘（垂直拉伸）
    drawImage(screen, parts.CenterRight, x+width-cornerWidth, y+cornerHeight, 1.0, scaleY)

    // 5. 绘制中心区域（双向拉伸）
    cmBounds := parts.CenterMiddle.Bounds()
    scaleXCenter := stretchWidth / float64(cmBounds.Dx())
    scaleYCenter := stretchHeight / float64(cmBounds.Dy())
    drawImage(screen, parts.CenterMiddle, x+cornerWidth, y+cornerHeight, scaleXCenter, scaleYCenter)
}

// drawImage 辅助函数：绘制带缩放的图片
func drawImage(screen *ebiten.Image, img *ebiten.Image, x, y, scaleX, scaleY float64) {
    op := &ebiten.DrawImageOptions{}
    op.GeoM.Scale(scaleX, scaleY)
    op.GeoM.Translate(x, y)
    screen.DrawImage(img, op)
}
```

#### 2. 对话框大小计算

```go
// calculateDialogSize 计算对话框大小
// message: 对话框消息文字
// 返回：宽度和高度
func calculateDialogSize(message string) (width, height float64) {
    // 最小宽度和高度
    const (
        MinWidth  = 300.0
        MaxWidth  = 600.0
        MinHeight = 150.0
        Padding   = 20.0  // 内边距
        LineHeight = 20.0 // 行高
    )

    // TODO: 根据文字长度计算实际宽度
    // 简化实现：使用固定宽度
    width = 400.0

    // TODO: 根据文字行数计算高度
    // 简化实现：使用固定高度
    height = 200.0

    return width, height
}
```

#### 3. 对话框渲染流程

```go
// DialogRenderSystem.Draw 渲染对话框
func (s *DialogRenderSystem) Draw(screen *ebiten.Image) {
    // 查询所有对话框实体
    dialogEntities := ecs.GetEntitiesWith1[*components.DialogComponent](s.entityManager)

    for _, entityID := range dialogEntities {
        dialogComp, _ := ecs.GetComponent[*components.DialogComponent](s.entityManager, entityID)
        posComp, _ := ecs.GetComponent[*components.PositionComponent](s.entityManager, entityID)

        if !dialogComp.IsVisible {
            continue
        }

        // 1. 绘制半透明遮罩
        s.drawOverlay(screen)

        // 2. 绘制对话框背景（九宫格）
        renderNinePatch(screen, dialogComp.Parts, posComp.X, posComp.Y, dialogComp.Width, dialogComp.Height)

        // 3. 绘制骷髅头装饰（顶部中央）
        s.drawHeader(screen, dialogComp.Parts.Header, posComp.X, posComp.Y, dialogComp.Width)

        // 4. 绘制标题文字
        s.drawTitle(screen, dialogComp.Title, posComp.X, posComp.Y, dialogComp.Width)

        // 5. 绘制消息文字
        s.drawMessage(screen, dialogComp.Message, posComp.X, posComp.Y, dialogComp.Width, dialogComp.Height)

        // 6. 绘制按钮
        s.drawButtons(screen, dialogComp.Buttons, posComp.X, posComp.Y, dialogComp.Width, dialogComp.Height)
    }
}

func (s *DialogRenderSystem) drawOverlay(screen *ebiten.Image) {
    // 创建半透明黑色遮罩
    overlay := ebiten.NewImage(WindowWidth, WindowHeight)
    overlay.Fill(color.RGBA{0, 0, 0, 128})  // 50% 透明度
    screen.DrawImage(overlay, &ebiten.DrawImageOptions{})
}

func (s *DialogRenderSystem) drawTitle(screen *ebiten.Image, title string, x, y, width float64) {
    // 标题居中显示在对话框顶部
    titleX := x + width/2 - float64(len(title)*6)/2  // 简化：假设每个字符宽 6 像素
    titleY := y + 30

    // 黄色文字
    ebitenutil.DebugPrintAt(screen, title, int(titleX), int(titleY))
}

func (s *DialogRenderSystem) drawMessage(screen *ebiten.Image, message string, x, y, width, height float64) {
    // 消息居中显示在对话框中部
    messageX := x + width/2 - float64(len(message)*6)/2
    messageY := y + height/2

    // 黄色文字
    ebitenutil.DebugPrintAt(screen, message, int(messageX), int(messageY))
}

func (s *DialogRenderSystem) drawButtons(screen *ebiten.Image, buttons []DialogButton, x, y, width, height float64) {
    // 按钮居中显示在对话框底部
    for i, btn := range buttons {
        btnX := x + width/2 - 50  // 按钮宽度假设 100
        btnY := y + height - 50

        // TODO: 绘制按钮背景
        // TODO: 绘制按钮文字
        ebitenutil.DebugPrintAt(screen, btn.Label, int(btnX), int(btnY))
    }
}
```

---

### Resource Requirements

**必需的图片资源（13 张）：**

| 资源 ID | 文件路径 | 用途 |
|---------|---------|------|
| `IMAGE_DIALOG_TOPLEFT` | `assets/images/dialog_topleft.png` | 左上角 |
| `IMAGE_DIALOG_TOPMIDDLE` | `assets/images/dialog_topmiddle.png` | 上边缘 |
| `IMAGE_DIALOG_TOPRIGHT` | `assets/images/dialog_topright.png` | 右上角 |
| `IMAGE_DIALOG_CENTERLEFT` | `assets/images/dialog_centerleft.png` | 左边缘 |
| `IMAGE_DIALOG_CENTERMIDDLE` | `assets/images/dialog_centermiddle.png` | 中心区域 |
| `IMAGE_DIALOG_CENTERRIGHT` | `assets/images/dialog_centerright.png` | 右边缘 |
| `IMAGE_DIALOG_BOTTOMLEFT` | `assets/images/dialog_bottomleft.png` | 左下角 |
| `IMAGE_DIALOG_BOTTOMMIDDLE` | `assets/images/dialog_bottommiddle.png` | 下边缘 |
| `IMAGE_DIALOG_BOTTOMRIGHT` | `assets/images/dialog_bottomright.png` | 右下角 |
| `IMAGE_DIALOG_BIGBOTTOMLEFT` | `assets/images/dialog_bigbottomleft.png` | 大对话框左下角 |
| `IMAGE_DIALOG_BIGBOTTOMMIDDLE` | `assets/images/dialog_bigbottommiddle.png` | 大对话框下边缘 |
| `IMAGE_DIALOG_BIGBOTTOMRIGHT` | `assets/images/dialog_bigbottomright.png` | 大对话框右下角 |
| `IMAGE_DIALOG_HEADER` | `assets/images/dialog_header.png` | 骷髅头装饰 |

---

### Testing Strategy

#### 单元测试

**测试文件：** `pkg/systems/dialog_render_system_test.go`

**测试用例：**

```go
func TestNinePatchRendering(t *testing.T) {
    // 创建测试用的九宫格资源
    parts := createTestDialogParts()

    // 创建测试画布
    screen := ebiten.NewImage(800, 600)

    // 渲染对话框
    renderNinePatch(screen, parts, 200, 150, 400, 300)

    // 验证：边角不拉伸，边缘和中心拉伸
    // TODO: 添加具体验证逻辑
}

func TestDialogSize(t *testing.T) {
    width, height := calculateDialogSize("短消息")
    assert.Equal(t, 400.0, width)
    assert.Equal(t, 200.0, height)

    width, height = calculateDialogSize("这是一条很长很长很长的消息，需要换行显示")
    // TODO: 验证长消息的大小计算
}
```

#### 集成测试

详见 Task 7.2

---

## Risk and Compatibility Check

### Primary Risks

**Risk 1: 九宫格拉伸算法复杂**
- **风险等级**: 中高
- **影响**: 对话框显示不正确，边缘重叠或缺失
- **缓解措施**:
  - 参考现有九宫格实现（Unity/Web）
  - 单独测试拉伸算法
  - 逐步调试边角、边缘、中心的渲染

**Risk 2: 文字渲染限制**
- **风险等级**: 中
- **影响**: 文字显示效果差，无法换行
- **缓解措施**:
  - 初版使用 `ebitenutil.DebugPrint`（临时方案）
  - 后续升级为位图字体渲染
  - 文字换行算法可简化（固定宽度）

**Risk 3: 资源文件缺失**
- **风险等级**: 低
- **影响**: 对话框无法显示
- **缓解措施**:
  - 启动时校验资源
  - fallback 使用纯色矩形

**Risk 4: 性能问题**
- **风险等级**: 低
- **影响**: 九宫格拉伸每帧渲染可能影响性能
- **缓解措施**:
  - 对话框数量极少（通常只有 1 个）
  - 九宫格算法优化（避免重复计算）

### Rollback Plan

- **简单回滚**: `git revert` 本 Story 的所有提交
- **部分回滚**: 删除对话框相关代码，点击未解锁按钮时只打印日志
- **影响范围**: 主菜单场景，不影响游戏玩法
- **数据兼容性**: 无数据变更

### Compatibility Verification

- [x] **无 API 破坏性变更** - 只添加新系统和组件
- [x] **无数据库变更** - 只有 UI 渲染
- [x] **遵循现有设计模式** - 使用 ECS 架构
- [x] **向后兼容** - 不影响其他场景
- [x] **可复用性** - 对话框系统可用于其他场景

---

## Validation Checklist

### Scope Validation

- [x] **Story 可在一个开发会话内完成** - 估计 6-8 小时
- [x] **集成方法明确** - 创建对话框系统，集成到主菜单
- [x] **遵循现有模式** - 使用 ECS 架构和实体工厂
- [x] **无需架构工作** - 复用现有框架

### Clarity Check

- [x] **Story 需求明确无歧义** - AC 详细描述功能
- [x] **集成点清晰指定** - MainMenuScene + 新增系统
- [x] **成功标准可测试** - 有单元测试和集成测试
- [x] **回滚方法简单可行** - git revert

### Dependencies Check

- [ ] **Story 12.1 已完成** - 菜单按钮系统（需要集成）
- [ ] **Story 12.2 已完成** - 底部按钮系统（需要集成）
- [x] **无外部依赖** - 对话框系统独立实现

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-01 | 0.1 | 初始 Story 创建，基于 Epic 12 和规格文档分析 | Sarah (PO) |

---

## Estimated Effort

**开发时间**: 6-8 小时

**分解：**
- 九宫格系统设计和实现: 2-3 小时（核心难点）
- 对话框组件和工厂: 1-1.5 小时
- 渲染和输入系统: 1.5-2 小时
- 主菜单集成: 1-1.5 小时
- 测试和调试: 1-1.5 小时

**优先级**: ⭐⭐⭐⭐⭐ 高（阶段 1 核心功能，Story 12.1 和 12.2 的依赖）

---

## Notes

- 本 Story 是三个核心 Story 中最复杂的一个（九宫格拉伸）
- 九宫格算法是关键技术难点，需要仔细实现和测试
- 文字渲染初版可以简化（使用 DebugPrint），后续优化
- 对话框系统是通用组件，后续其他场景（设置、帮助等）都会使用
- Story 12.1 和 12.2 依赖本 Story 实现完整的未解锁提示功能
- 建议优先实现九宫格拉伸，再添加文字和按钮
