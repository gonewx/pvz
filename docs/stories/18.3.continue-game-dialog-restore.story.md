# Story 18.3: 继续游戏对话框与场景恢复

## Status

Ready

## Story

**As a** 玩家,
**I want** to choose whether to continue my saved game or restart the level,
**so that** I have control over my game progress.

## Acceptance Criteria

1. **继续游戏对话框**
   - Title: "继续游戏?"
   - Message: "你想继续当前游戏还是重玩此关卡？"
   - 按钮布局（两行）:
     - 第一行: [继续] [重玩关卡]
     - 第二行: [取消]（居中）
   - 复用 `DialogComponent` 和现有对话框样式

2. **按钮行为**
   - **继续**: 调用 `GameScene.LoadFromSave()` 恢复游戏
   - **重玩关卡**: 删除存档，正常开始该关卡
   - **取消**: 关闭对话框，返回主菜单（不进入游戏）

3. **GameScene.LoadFromSave() 实现**
   - 恢复 GameState 状态（阳光、波次、时间等）
   - 重建所有植物实体
   - 重建所有僵尸实体
   - 重建所有子弹实体
   - 重建所有阳光实体
   - 重建所有除草车实体
   - 恢复草坪网格占用状态

4. **动画状态恢复**
   - Reanim 动画从 idle 状态开始（简化处理）
   - 允许轻微的动画跳跃（可接受）

5. **错误处理**
   - 存档加载失败时显示错误提示
   - 提供删除损坏存档的选项

6. **单元测试**: 覆盖率 ≥ 80%

## Tasks / Subtasks

### Task 1: 实现继续游戏对话框 (AC: 1)

- [ ] 修改 `pkg/scenes/main_menu_scene.go`
- [ ] 实现 `showContinueGameDialog(info *BattleSaveInfo)` 方法
  ```go
  func (s *MainMenuScene) showContinueGameDialog(info *game.BattleSaveInfo) {
      // 创建对话框实体
      dialogEntity := s.entityManager.CreateEntity()

      // 构建对话框内容
      ecs.AddComponent(s.entityManager, dialogEntity, &components.DialogComponent{
          Title:     "继续游戏?",
          Message:   "你想继续当前游戏还是重玩此关卡？",
          IsVisible: true,
          Width:     400,
          Height:    200,
          Buttons: []components.DialogButton{
              // 第一行按钮
              {
                  Label: "继续",
                  OnClick: func() {
                      s.onContinueGame(info)
                  },
                  // 位置在 renderDialog 中计算
              },
              {
                  Label: "重玩关卡",
                  OnClick: func() {
                      s.onRestartLevel(info)
                  },
              },
              // 第二行按钮
              {
                  Label: "取消",
                  OnClick: func() {
                      s.onCancelContinue(dialogEntity)
                  },
              },
          },
          Parts: s.dialogParts, // 复用现有对话框资源
      })

      s.continueDialogEntity = dialogEntity
  }
  ```
- [ ] 实现对话框按钮位置计算（两行布局）
- [ ] 添加 `continueDialogEntity ecs.EntityID` 字段到 MainMenuScene

### Task 2: 实现按钮回调 (AC: 2)

- [ ] 实现 `onContinueGame(info *BattleSaveInfo)` 方法
  ```go
  func (s *MainMenuScene) onContinueGame(info *game.BattleSaveInfo) {
      log.Printf("[MainMenuScene] Continue game: level %s", info.LevelID)

      // 关闭对话框
      s.closeContinueDialog()

      // 切换到游戏场景（加载模式）
      s.sceneManager.SwitchTo(NewGameSceneFromSave(
          s.resourceManager,
          info.LevelID,
          s.saveManager.GetBattleSavePath(s.saveManager.GetCurrentUser()),
      ))
  }
  ```
- [ ] 实现 `onRestartLevel(info *BattleSaveInfo)` 方法
  ```go
  func (s *MainMenuScene) onRestartLevel(info *game.BattleSaveInfo) {
      log.Printf("[MainMenuScene] Restart level: %s", info.LevelID)

      // 删除存档
      username := s.saveManager.GetCurrentUser()
      if err := s.saveManager.DeleteBattleSave(username); err != nil {
          log.Printf("[MainMenuScene] Warning: Failed to delete save: %v", err)
      }

      // 关闭对话框
      s.closeContinueDialog()

      // 正常开始该关卡
      s.sceneManager.SwitchTo(NewGameScene(s.resourceManager, info.LevelID))
  }
  ```
- [ ] 实现 `onCancelContinue(dialogEntity ecs.EntityID)` 方法
  ```go
  func (s *MainMenuScene) onCancelContinue(dialogEntity ecs.EntityID) {
      log.Printf("[MainMenuScene] Cancel continue dialog")

      // 关闭对话框
      s.closeContinueDialog()

      // 保持在主菜单（不做任何事）
  }
  ```
- [ ] 实现 `closeContinueDialog()` 方法

### Task 3: 实现 NewGameSceneFromSave 构造函数 (AC: 3)

- [ ] 修改 `pkg/scenes/game_scene.go`
- [ ] 添加 `NewGameSceneFromSave(rm, levelID, savePath string) *GameScene`
  ```go
  func NewGameSceneFromSave(
      resourceManager *game.ResourceManager,
      levelID string,
      savePath string,
  ) *GameScene {
      gs := &GameScene{
          resourceManager: resourceManager,
          levelID:         levelID,
          loadFromSave:    true,
          savePath:        savePath,
      }
      return gs
  }
  ```
- [ ] 添加字段到 GameScene
  ```go
  type GameScene struct {
      // 现有字段...
      loadFromSave bool   // 是否从存档加载
      savePath     string // 存档文件路径
  }
  ```

### Task 4: 实现 GameScene.LoadFromSave() (AC: 3)

- [ ] 在 `GameScene.Init()` 或 `GameScene.initializeLevel()` 中检查 `loadFromSave`
  ```go
  func (gs *GameScene) initializeLevel() {
      if gs.loadFromSave {
          if err := gs.loadFromSaveFile(); err != nil {
              log.Printf("[GameScene] Failed to load from save: %v, starting fresh", err)
              gs.loadFromSave = false
              // 继续正常初始化
          } else {
              return // 加载成功，跳过正常初始化
          }
      }
      // 正常初始化流程...
  }
  ```
- [ ] 实现 `loadFromSaveFile() error` 方法
  ```go
  func (gs *GameScene) loadFromSaveFile() error {
      // 1. 加载存档数据
      serializer := game.NewBattleSerializer()
      data, err := serializer.LoadBattle(gs.savePath)
      if err != nil {
          return fmt.Errorf("failed to load battle save: %w", err)
      }

      // 2. 恢复 GameState
      gameState := game.GetGameState()
      gs.restoreGameState(gameState, data)

      // 3. 恢复实体
      gs.restorePlants(data.Plants)
      gs.restoreZombies(data.Zombies)
      gs.restoreProjectiles(data.Projectiles)
      gs.restoreSuns(data.Suns)
      gs.restoreLawnmowers(data.Lawnmowers)

      // 4. 删除存档（成功加载后）
      username := gameState.GetSaveManager().GetCurrentUser()
      gameState.GetSaveManager().DeleteBattleSave(username)

      log.Printf("[GameScene] Successfully loaded from save: Level %s, Sun %d, Wave %d",
          data.LevelID, data.Sun, data.CurrentWaveIndex)

      return nil
  }
  ```

### Task 5: 实现实体恢复方法 (AC: 3)

- [ ] 实现 `restoreGameState(gs *GameState, data *BattleSaveData)`
  ```go
  func (scene *GameScene) restoreGameState(gs *game.GameState, data *game.BattleSaveData) {
      gs.Sun = data.Sun
      gs.LevelTime = data.LevelTime
      gs.CurrentWaveIndex = data.CurrentWaveIndex
      gs.SpawnedWaves = data.SpawnedWaves
      gs.TotalZombiesSpawned = data.TotalZombiesSpawned
      gs.ZombiesKilled = data.ZombiesKilled
  }
  ```
- [ ] 实现 `restorePlants(plants []PlantData)`
  ```go
  func (scene *GameScene) restorePlants(plants []game.PlantData) {
      for _, p := range plants {
          // 使用实体工厂创建植物
          plantType := components.PlantType(p.PlantType)
          entity := entities.NewPlantEntity(
              scene.entityManager,
              scene.resourceManager,
              plantType,
              p.GridRow,
              p.GridCol,
          )

          // 恢复生命值
          if healthComp, ok := ecs.GetComponent[*components.HealthComponent](scene.entityManager, entity); ok {
              healthComp.CurrentHealth = p.Health
          }

          // 更新草坪网格占用
          scene.lawnGrid.SetCellOccupied(p.GridRow, p.GridCol, true)
      }
  }
  ```
- [ ] 实现 `restoreZombies(zombies []ZombieData)`
  ```go
  func (scene *GameScene) restoreZombies(zombies []game.ZombieData) {
      for _, z := range zombies {
          // 使用实体工厂创建僵尸
          entity := entities.NewZombieEntity(
              scene.entityManager,
              scene.resourceManager,
              z.ZombieType,
              z.Lane,
          )

          // 恢复位置
          if posComp, ok := ecs.GetComponent[*components.PositionComponent](scene.entityManager, entity); ok {
              posComp.X = z.X
              posComp.Y = z.Y
          }

          // 恢复速度
          if velComp, ok := ecs.GetComponent[*components.VelocityComponent](scene.entityManager, entity); ok {
              velComp.X = z.VelocityX
          }

          // 恢复生命值
          if healthComp, ok := ecs.GetComponent[*components.HealthComponent](scene.entityManager, entity); ok {
              healthComp.CurrentHealth = z.Health
          }

          // 恢复护甲
          if z.ArmorHealth > 0 {
              if armorComp, ok := ecs.GetComponent[*components.ArmorComponent](scene.entityManager, entity); ok {
                  armorComp.CurrentArmor = z.ArmorHealth
              }
          }
      }
  }
  ```
- [ ] 实现 `restoreProjectiles(projectiles []ProjectileData)`
- [ ] 实现 `restoreSuns(suns []SunData)`
- [ ] 实现 `restoreLawnmowers(lawnmowers []LawnmowerData)`

### Task 6: 对话框渲染支持两行按钮布局 (AC: 1)

- [ ] 修改 `pkg/systems/dialog_render_system.go` 或相关渲染代码
- [ ] 支持按钮的 `Row` 属性或自动布局
  ```go
  // 按钮布局计算
  // 第一行：[继续] [重玩关卡] - 并排
  // 第二行：[取消] - 居中
  func calculateButtonPositions(buttons []DialogButton, dialogWidth float64) {
      if len(buttons) >= 3 {
          // 第一行两个按钮
          rowY1 := // ...
          buttons[0].X = dialogWidth/4 - buttonWidth/2
          buttons[0].Y = rowY1
          buttons[1].X = dialogWidth*3/4 - buttonWidth/2
          buttons[1].Y = rowY1

          // 第二行一个按钮居中
          rowY2 := rowY1 + buttonHeight + spacing
          buttons[2].X = dialogWidth/2 - buttonWidth/2
          buttons[2].Y = rowY2
      }
  }
  ```

### Task 7: 错误处理 (AC: 5)

- [ ] 在 `loadFromSaveFile()` 中处理加载失败
- [ ] 显示错误对话框（可选）
  ```go
  func (scene *GameScene) showLoadErrorDialog(err error) {
      // 创建错误对话框
      // "存档加载失败，是否删除损坏的存档并重新开始？"
      // [删除并重新开始] [取消]
  }
  ```

### Task 8: 单元测试 (AC: 6)

- [ ] 创建 `pkg/scenes/game_scene_save_test.go`
  - [ ] 测试 `loadFromSaveFile()` 正常加载
  - [ ] 测试 `restorePlants()` 植物恢复
  - [ ] 测试 `restoreZombies()` 僵尸恢复
  - [ ] 测试加载失败时的降级处理
- [ ] 扩展 `pkg/scenes/main_menu_scene_test.go`
  - [ ] 测试对话框显示
  - [ ] 测试"继续"按钮行为
  - [ ] 测试"重玩关卡"按钮行为
  - [ ] 测试"取消"按钮行为
- [ ] 确保覆盖率 ≥ 80%

## Dev Notes

### 架构上下文

本 Story 是 Epic 18 的最后一个 Story，实现用户交互界面和游戏场景恢复逻辑。

**核心流程**:
```
MainMenuScene.showContinueGameDialog()
    ↓ 用户点击"继续"
MainMenuScene.onContinueGame()
    ↓ 切换场景
NewGameSceneFromSave()
    ↓ 初始化时
GameScene.loadFromSaveFile()
    ↓ 调用
BattleSerializer.LoadBattle()
    ↓ 恢复
GameScene.restorePlants/Zombies/...()
    ↓
游戏继续
```

### 对话框按钮布局

```
┌─────────────────────────────────────────┐
│              继续游戏?                   │
│                                         │
│   你想继续当前游戏还是重玩此关卡？         │
│                                         │
│      [继续]          [重玩关卡]          │ ← 第一行
│               [取消]                    │ ← 第二行
│                                         │
└─────────────────────────────────────────┘
```

### 实体恢复注意事项

1. **植物**:
   - 需要更新草坪网格占用状态
   - 动画从 idle 开始（简化处理）

2. **僵尸**:
   - 位置直接恢复（X, Y）
   - 行为状态可以简化为 walking（让系统重新判断）

3. **子弹**:
   - 简单恢复位置和速度即可

4. **阳光**:
   - 恢复位置和生命周期
   - 收集动画状态可以重置

5. **除草车**:
   - 如果已触发，需要重建并设置正确位置
   - 如果未触发，保持初始位置

### 现有代码参考

**DialogComponent** (`pkg/components/dialog_component.go`):
- 已有 `Buttons []DialogButton` 支持
- 需要检查是否支持多行布局

**实体工厂**:
- `entities.NewPlantEntity()` - 植物创建
- `entities.NewZombieEntity()` 或 `entities.NewBasicZombieEntity()` - 僵尸创建
- `entities.NewProjectileEntity()` - 子弹创建
- `entities.NewSunEntity()` - 阳光创建
- `entities.NewLawnmowerEntity()` - 除草车创建

### 简化处理

为了降低复杂度，以下状态采用简化处理：
1. **动画状态**: 所有实体从默认动画状态开始，不保存具体帧
2. **攻击冷却**: 植物冷却从 0 开始（可能导致立即攻击，可接受）
3. **行为状态**: 僵尸行为让系统重新判断

## Testing

### 测试文件位置

- `pkg/scenes/game_scene_save_test.go` (新增)
- `pkg/scenes/main_menu_scene_test.go` (扩展)

### 关键测试场景

**1. 对话框显示测试**:
```go
func TestMainMenuScene_ShowContinueDialog(t *testing.T) {
    scene := createTestMainMenuScene()
    info := &game.BattleSaveInfo{LevelID: "1-2", Sun: 100}

    scene.showContinueGameDialog(info)

    // 验证对话框实体已创建
    assert.NotEqual(t, ecs.EntityID(0), scene.continueDialogEntity)

    // 验证对话框组件
    dialog, ok := ecs.GetComponent[*components.DialogComponent](scene.entityManager, scene.continueDialogEntity)
    assert.True(t, ok)
    assert.Equal(t, "继续游戏?", dialog.Title)
    assert.Equal(t, 3, len(dialog.Buttons))
}
```

**2. 场景恢复测试**:
```go
func TestGameScene_LoadFromSave(t *testing.T) {
    // 创建测试存档
    tmpDir := t.TempDir()
    savePath := filepath.Join(tmpDir, "test_battle.sav")
    createTestBattleSave(savePath, "1-2", 150, 3) // level, sun, wave

    // 创建场景
    scene := NewGameSceneFromSave(nil, "1-2", savePath)
    scene.entityManager = ecs.NewEntityManager()

    // 加载
    err := scene.loadFromSaveFile()
    assert.NoError(t, err)

    // 验证 GameState
    gs := game.GetGameState()
    assert.Equal(t, 150, gs.Sun)
    assert.Equal(t, 3, gs.CurrentWaveIndex)
}
```

**3. 植物恢复测试**:
```go
func TestGameScene_RestorePlants(t *testing.T) {
    scene := createTestGameScene()
    plants := []game.PlantData{
        {PlantType: "peashooter", GridRow: 2, GridCol: 3, Health: 200, MaxHealth: 300},
        {PlantType: "sunflower", GridRow: 1, GridCol: 1, Health: 300, MaxHealth: 300},
    }

    scene.restorePlants(plants)

    // 验证实体数量
    entities := ecs.GetEntitiesWith1[*components.PlantComponent](scene.entityManager)
    assert.Equal(t, 2, len(entities))

    // 验证生命值
    for _, entity := range entities {
        healthComp, _ := ecs.GetComponent[*components.HealthComponent](scene.entityManager, entity)
        plantComp, _ := ecs.GetComponent[*components.PlantComponent](scene.entityManager, entity)
        if plantComp.PlantType == components.PlantPeashooter {
            assert.Equal(t, 200, healthComp.CurrentHealth)
        }
    }
}
```

### 测试命令

```bash
# 运行场景测试
go test ./pkg/scenes -v -run TestGameScene_Load
go test ./pkg/scenes -v -run TestMainMenuScene_Continue

# 查看覆盖率
go test ./pkg/scenes -cover
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-29 | 0.1 | Initial story creation | John (PM Agent) |
