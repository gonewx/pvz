# Story 17.1: 难度引擎 - 轮数与级别容量计算

## Status

Done

## Story

**As a** 开发者,
**I want** to implement the difficulty engine with round calculation and level capacity caps,
**so that** zombie spawning follows the original game's dynamic difficulty system.

## Acceptance Criteria

1. **轮数计算**:
   - 实现公式: `RoundNumber = TotalCompletedFlags / 2 - 1`
   - 支持一周目/二周目状态判断
   - 正确处理负数轮数（一周目早期关卡）

2. **级别容量上限**:
   - 实现公式: `CapacityCap = int(int((CurrentWaveNum + RoundNumber * WavesPerRound) * 0.8) / 2) + 1`
   - 大波（旗帜波）容量 × 2.5 并向零取整
   - 级别上限限制每波僵尸的级别总和

3. **僵尸级别数据**:
   - 普通僵尸: 级别 1
   - 路障僵尸: 级别 2
   - 铁桶僵尸: 级别 4
   - 巨人僵尸: 级别 10

4. **配置文件**:
   - 创建 `data/zombie_stats.yaml` 存储僵尸属性
   - 支持热加载和数值调整

5. **单元测试**: 覆盖率 ≥ 80%

## Tasks / Subtasks

- [x] **Task 1: 创建僵尸属性配置文件** (AC: 3, 4)
  - [x] 创建 `data/zombie_stats.yaml`，定义所有僵尸的级别、权重、血量属性
  - [x] 定义数据结构：`ZombieStats` 包含 `Level`, `Weight`, `BaseHealth`, `Tier1AccessoryHealth`, `Tier2AccessoryHealth`
  - [x] 配置现有僵尸类型：basic (级别1), conehead (级别2), buckethead (级别4)

- [x] **Task 2: 实现僵尸属性配置加载器** (AC: 4)
  - [x] 创建 `pkg/config/zombie_stats.go`
  - [x] 实现 `ZombieStatsConfig` 结构体
  - [x] 实现 `LoadZombieStats(filepath string) (*ZombieStatsConfig, error)` 函数
  - [x] 添加单元测试 `pkg/config/zombie_stats_test.go`

- [x] **Task 3: 实现难度引擎核心组件** (AC: 1, 2)
  - [x] 创建 `pkg/components/difficulty_component.go`
  - [x] 定义 `DifficultyComponent` 结构体，包含：
    - `TotalCompletedFlags int` - 已完成的旗帜总数
    - `RoundNumber int` - 计算的轮数
    - `IsSecondPlaythrough bool` - 是否为二周目
    - `WavesPerRound int` - 每轮波次数（默认20）

- [x] **Task 4: 实现难度引擎系统** (AC: 1, 2)
  - [x] 创建 `pkg/systems/difficulty_engine.go`
  - [x] 实现 `DifficultyEngine` 结构体
  - [x] 实现 `CalculateRoundNumber(totalCompletedFlags int) int` 方法
  - [x] 实现 `CalculateLevelCapacity(waveNum int, roundNumber int, wavesPerRound int, isFlagWave bool) int` 方法
  - [x] 实现 `GetZombieLevel(zombieType string) int` 方法（从配置读取）
  - [x] 实现 `ValidateWaveCapacity(zombieTypes []string, capacityCap int) bool` 方法

- [x] **Task 5: 添加难度引擎单元测试** (AC: 5)
  - [x] 创建 `pkg/systems/difficulty_engine_test.go`
  - [x] 测试 `CalculateRoundNumber`：正数、零、负数轮数场景
  - [x] 测试 `CalculateLevelCapacity`：常规波、旗帜波、不同轮数
  - [x] 测试 `ValidateWaveCapacity`：级别总和验证
  - [x] 目标覆盖率 ≥ 80%（实际达到 100%）

- [x] **Task 6: 集成到 GameState** (AC: 1, 2)
  - [x] 在 `pkg/game/game_state.go` 中添加难度引擎数据字段（避免循环依赖）
  - [x] 在 GameState 初始化时设置默认值
  - [x] 添加 `GetCurrentRoundNumber()` 和 `GetWaveCapacity(waveNum int, isFlagWave bool)` 辅助方法

## Dev Notes

### 架构上下文

本故事是 Epic 17（僵尸生成引擎）的第一个故事，为后续的波次计时系统和行分配算法提供基础数据支持。

**系统定位**:
```
DifficultyEngine (本故事)
    ↓ 提供级别容量数据
WaveTimingSystem (Story 17.6-17.8)
    ↓ 决定何时刷新下一波
WaveSpawnSystem (现有，需修改)
    ↓ 生成僵尸时调用 DifficultyEngine 验证
LaneAllocator (Story 17.4-17.5)
    ↓ 决定僵尸出现在哪一行
```

### 技术实现细节

**轮数计算公式** [Source: .meta/levels/ZombieGenerationModuleDesignDocument.md#二-轮数计算]:
```go
// RoundNumber = TotalCompletedFlags / 2 - 1
func (d *DifficultyEngine) CalculateRoundNumber(totalCompletedFlags int) int {
    return totalCompletedFlags/2 - 1
}
```

**一周目 vs 二周目**:
- 一周目首次通关前：`TotalCompletedFlags` 从 0 开始累加
- 二周目：所有常规关卡变为 20 波（如 1-1, 1-2），特殊关卡变为 30 波（如 1-7, 1-9）

**级别容量上限公式** [Source: .meta/levels/ZombieGenerationModuleDesignDocument.md#二-级别容量上限]:
```go
// CapacityCap = int(int((CurrentWaveNum + RoundNumber * WavesPerRound) * 0.8) / 2) + 1
func (d *DifficultyEngine) CalculateLevelCapacity(waveNum, roundNumber, wavesPerRound int, isFlagWave bool) int {
    base := int(int(float64(waveNum+roundNumber*wavesPerRound)*0.8) / 2) + 1
    if isFlagWave {
        // 大波（旗帜波）容量 × 2.5 并向零取整
        return int(float64(base) * 2.5)
    }
    return base
}
```

**僵尸级别数据** [Source: .meta/levels/ZombieGenerationModuleDesignDocument.md#三-僵尸基础数据]:

| 僵尸类型 | 级别 (Level) | 权重 (Weight) | 本体血量 | I类饰品血量 |
|----------|-------------|--------------|---------|------------|
| basic    | 1           | 4000         | 270     | -          |
| conehead | 2           | 4000         | 270     | 370        |
| buckethead | 4         | 3000         | 270     | 1100       |
| gargantuar | 10        | 1500         | 3000    | -          |

### 文件位置参考 [Source: docs/architecture/unified-project-structure.md]

```
pkg/
├── config/
│   └── zombie_stats.go        # 新增：僵尸属性配置加载器
├── components/
│   └── difficulty_component.go # 新增：难度组件
├── systems/
│   └── difficulty_engine.go   # 新增：难度引擎系统
└── game/
    └── game_state.go          # 修改：添加难度引擎引用

data/
└── zombie_stats.yaml          # 新增：僵尸属性配置
```

### 现有代码参考

**现有关卡配置结构** (`pkg/config/level_config.go:12-68`):
- `LevelConfig` 结构体已包含 `Waves []WaveConfig` 和 `EnabledLanes []int`
- 可在此基础上扩展难度相关字段

**现有波次生成系统** (`pkg/systems/wave_spawn_system.go`):
- `WaveSpawnSystem` 已实现基本的僵尸生成逻辑
- 本故事的 DifficultyEngine 将为其提供级别容量验证

### zombie_stats.yaml 配置示例

```yaml
# data/zombie_stats.yaml
# 僵尸属性配置文件
# 用于难度引擎计算级别容量

zombies:
  basic:
    level: 1
    weight: 4000
    baseHealth: 270
    tier1AccessoryHealth: 0
    tier2AccessoryHealth: 0

  conehead:
    level: 2
    weight: 4000
    baseHealth: 270
    tier1AccessoryHealth: 370
    tier2AccessoryHealth: 0

  buckethead:
    level: 4
    weight: 3000
    baseHealth: 270
    tier1AccessoryHealth: 1100
    tier2AccessoryHealth: 0

  # 以下为未来扩展（本故事不实现）
  gargantuar:
    level: 10
    weight: 1500
    baseHealth: 3000
    tier1AccessoryHealth: 0
    tier2AccessoryHealth: 0
```

### ECS 架构约束 [Source: docs/architecture/coding-standards.md]

1. **组件（Component）仅存储数据**，不包含方法
2. **系统（System）处理逻辑**，通过 EntityManager 查询组件
3. **零耦合原则**：系统间不直接调用，通过组件或 EventBus 通信

### 泛型 API 使用 [Source: docs/architecture/ecs-generics-migration-guide.md]

使用 Go 泛型 API 进行组件操作：
```go
// 获取组件
difficulty, ok := ecs.GetComponent[*components.DifficultyComponent](em, entityID)

// 添加组件
ecs.AddComponent(em, entityID, &components.DifficultyComponent{
    TotalCompletedFlags: 0,
    RoundNumber:         -1,
    IsSecondPlaythrough: false,
    WavesPerRound:       20,
})
```

## Testing

### 测试文件位置
- `pkg/config/zombie_stats_test.go` - 配置加载测试
- `pkg/systems/difficulty_engine_test.go` - 难度引擎测试

### 测试策略 [Source: docs/architecture/testing-strategy.md]
- 使用 Go 标准库 `testing` 包
- 单元测试覆盖率目标 ≥ 80%

### 关键测试场景

**1. 轮数计算测试**:
```go
func TestCalculateRoundNumber(t *testing.T) {
    tests := []struct {
        name               string
        totalCompletedFlags int
        expectedRound      int
    }{
        {"一周目1-1（0旗）", 0, -1},
        {"一周目1-2（1旗）", 1, -1},
        {"一周目1-3（2旗）", 2, 0},
        {"一周目完成（50旗）", 50, 24},
        {"二周目开始", 52, 25},
    }
    // ...
}
```

**2. 级别容量测试**:
```go
func TestCalculateLevelCapacity(t *testing.T) {
    tests := []struct {
        name        string
        waveNum     int
        roundNumber int
        wavesPerRound int
        isFlagWave  bool
        expected    int
    }{
        {"第1波，轮数0", 1, 0, 20, false, 1},
        {"第10波（旗帜波），轮数0", 10, 0, 20, true, 10}, // 4 * 2.5 = 10
        {"第20波（最终波），轮数1", 20, 1, 20, true, 40}, // 16 * 2.5 = 40
    }
    // ...
}
```

**3. 僵尸级别验证测试**:
```go
func TestValidateWaveCapacity(t *testing.T) {
    // 容量上限为5时：
    // - 5个普通僵尸(5×1=5)：通过
    // - 2个路障僵尸(2×2=4)：通过
    // - 2个铁桶僵尸(2×4=8)：失败
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-27 | 0.1 | Initial draft creation | Bob (Scrum Master) |
| 2025-11-27 | 1.0 | Implementation complete | James (Dev Agent) |

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Completion Notes
1. **所有任务完成**: 6个任务全部实现并测试通过
2. **测试覆盖率**: difficulty_engine.go 达到 100% 覆盖率，超过 80% 目标
3. **架构调整**: 为避免循环依赖 (game → systems → entities → game)，在 GameState 中直接实现辅助方法而不是持有 DifficultyEngine 引用。DifficultyEngine 作为独立系统可在场景中使用

### File List
**新增文件:**
- `data/zombie_stats.yaml` - 僵尸属性配置文件
- `pkg/config/zombie_stats.go` - 僵尸属性配置加载器
- `pkg/config/zombie_stats_test.go` - 配置加载器单元测试
- `pkg/components/difficulty_component.go` - 难度组件（纯数据）
- `pkg/systems/difficulty_engine.go` - 难度引擎系统
- `pkg/systems/difficulty_engine_test.go` - 难度引擎单元测试

**修改文件:**
- `pkg/game/game_state.go` - 添加难度引擎数据字段和辅助方法

### Debug Log References
无调试日志

### Technical Decisions
1. **循环依赖解决方案**: 原设计要求 GameState 持有 DifficultyEngine 引用，但发现存在循环依赖。解决方案是将难度计算逻辑复制到 GameState 的辅助方法中，DifficultyEngine 作为独立系统在需要时实例化使用
2. **测试用例修正**: 负数轮数和高轮数的测试期望值根据实际公式计算结果进行了修正

---

## QA Results

### Review Date: 2025-11-27

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

实现质量优秀。代码结构清晰，遵循 ECS 架构规范，组件仅存储数据，系统包含逻辑。公式实现正确，与设计文档一致。循环依赖问题的解决方案合理，通过在 GameState 中复制计算逻辑避免了包依赖问题。

**代码亮点:**
- 完整的注释和文档字符串
- 合理的默认值处理（zombieStats 为 nil 时返回默认级别 1）
- 配置验证完善（检查级别≥1、权重≥0、血量≥0）
- 测试覆盖全面，包含边界条件（负数轮数、高轮数、空列表等）

### Refactoring Performed

无需重构。代码质量已达到生产标准。

### Compliance Check

- Coding Standards: ✓ 符合 Go 编码规范，使用 gofmt 格式化
- Project Structure: ✓ 文件位置符合 unified-project-structure.md 规范
- Testing Strategy: ✓ 测试覆盖率 100%（difficulty_engine.go），超过 80% 目标
- All ACs Met: ✓ 所有 5 个验收标准完全满足

### Improvements Checklist

- [x] 轮数计算公式实现正确 (AC1)
- [x] 级别容量上限公式实现正确，含旗帜波 ×2.5 (AC2)
- [x] 僵尸级别数据配置完整 (AC3)
- [x] zombie_stats.yaml 配置文件创建并支持验证 (AC4)
- [x] 单元测试覆盖率达到 100% (AC5 要求 ≥80%)
- [x] GameState 集成完成，包含辅助方法
- [ ] 建议：为 GameState 的难度计算辅助方法添加单元测试（未来改进）

### Security Review

无安全风险。配置文件仅读取操作，无用户输入处理，无网络请求。

### Performance Considerations

无性能问题。所有计算均为 O(1) 复杂度（轮数计算、容量计算）或 O(n) 复杂度（级别总和计算，n 为僵尸数量）。配置文件加载为一次性操作。

### Files Modified During Review

无文件修改。

### Gate Status

Gate: **PASS** → docs/qa/gates/17.1-difficulty-engine.yml

### Recommended Status

✓ **Ready for Done** - 所有验收标准满足，测试通过，代码质量优秀。
