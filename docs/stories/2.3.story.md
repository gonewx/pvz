# Story 2.3: 自然阳光掉落

## Status
Done

## Story
**As a** 玩家,
**I want** to see suns periodically fall from the sky,
**so that** I can collect them as a primary resource.

## Acceptance Criteria
1. 游戏开始后,会按照一定的时间间隔(例如5-10秒)从屏幕顶部的随机位置生成一个阳光单位。
2. 阳光单位会以平滑的动画垂直下落,并停留在草坪区域内的一个随机位置。
3. 阳光单位在地面上停留一段时间后(例如8秒),如果没有被收集,会自动消失。
4. 同一时间屏幕上可以存在多个掉落的阳光。

## Tasks / Subtasks

- [x] Task 1: 创建 ECS 框架核心组件 (AC: 4)
  - [x] 创建 `pkg/ecs/entity_manager.go` 文件
  - [x] 定义 `EntityID` 类型 (使用 `uint64`)
  - [x] 实现 `EntityManager` 结构体,管理实体和组件
  - [x] 实现 `CreateEntity() EntityID` - 创建新实体并返回唯一ID
  - [x] 实现 `DestroyEntity(id EntityID)` - 标记实体待删除
  - [x] 实现 `AddComponent(id EntityID, component interface{})` - 为实体添加组件
  - [x] 实现 `GetComponent(id EntityID, componentType reflect.Type) interface{}` - 获取组件
  - [x] 实现 `HasComponent(id EntityID, componentType reflect.Type) bool` - 检查组件
  - [x] 实现 `RemoveMarkedEntities()` - 清理已标记删除的实体
  - [x] 使用 `map[EntityID]map[reflect.Type]interface{}` 存储实体-组件映射
  [Source: architecture/high-level-architecture.md#ECS架构, architecture/coding-standards.md]

- [x] Task 2: 创建阳光实体所需的组件定义 (AC: 1, 2, 3)
  - [x] 创建 `pkg/components/position.go` - 定义 `PositionComponent` 结构体 `{X, Y float64}`
  - [x] 创建 `pkg/components/sprite.go` - 定义 `SpriteComponent` 结构体 `{Image *ebiten.Image}`
  - [x] 创建 `pkg/components/velocity.go` - 定义 `VelocityComponent` 结构体 `{VX, VY float64}`
  - [x] 创建 `pkg/components/lifetime.go` - 定义 `LifetimeComponent` 结构体 `{MaxLifetime, CurrentLifetime float64, IsExpired bool}`
  - [x] 创建 `pkg/components/sun.go` - 定义 `SunComponent` 结构体 `{State SunState, TargetY float64}`
  - [x] 在 `sun.go` 中定义 `SunState` 枚举: `SunFalling`, `SunLanded`, `SunCollecting`
  - [x] 为所有组件添加 GoDoc 注释说明用途
  [Source: architecture/data-models.md#PositionComponent, architecture/data-models.md#SpriteComponent, architecture/coding-standards.md]

- [x] Task 3: 实现阳光实体工厂函数 (AC: 1, 2)
  - [x] 创建 `pkg/entities/sun_factory.go` 文件
  - [x] 实现 `NewSunEntity(manager *ecs.EntityManager, rm *game.ResourceManager, startX, targetY float64) ecs.EntityID`
  - [x] 在工厂函数中:
    - [x] 加载阳光图片资源 `assets/images/interface/Sun.gif`
    - [x] 创建实体并添加 `PositionComponent` (X=startX, Y=-50 屏幕顶部外)
    - [x] 添加 `SpriteComponent` (使用加载的阳光图片)
    - [x] 添加 `VelocityComponent` (VX=0, VY=60 像素/秒 - 原版掉落速度)
    - [x] 添加 `LifetimeComponent` (MaxLifetime=15秒: 掉落2秒+停留13秒后消失)
    - [x] 添加 `SunComponent` (State=SunFalling, TargetY=targetY)
  - [x] 返回创建的实体ID
  [Source: architecture/unified-project-structure.md#pkg/entities, 原版游戏机制]

- [x] Task 4: 实现阳光移动系统 (AC: 2)
  - [x] 创建 `pkg/systems/sun_movement_system.go` 文件
  - [x] 实现 `SunMovementSystem` 结构体包含 `entityManager *ecs.EntityManager` 字段
  - [x] 实现 `NewSunMovementSystem(em *ecs.EntityManager) *SunMovementSystem` 构造函数
  - [x] 实现 `Update(deltaTime float64)` 方法:
    - [x] 查询所有同时拥有 `SunComponent`, `PositionComponent`, `VelocityComponent` 的实体
    - [x] 对于每个阳光实体,检查 `SunState`:
      - [x] 如果 `State == SunFalling`:
        - [x] 更新位置: `position.Y += velocity.VY * deltaTime`
        - [x] 如果 `position.Y >= sun.TargetY`,设置 `State = SunLanded`, `velocity.VY = 0`
      - [x] 如果 `State == SunLanded`: 保持静止(不移动)
      - [x] 如果 `State == SunCollecting`: 由 Story 2.4 实现收集动画
  [Source: architecture/high-level-architecture.md#Systems, architecture/coding-standards.md#零耦合原则]

- [x] Task 5: 实现生命周期系统 (AC: 3)
  - [x] 创建 `pkg/systems/lifetime_system.go` 文件
  - [x] 实现 `LifetimeSystem` 结构体包含 `entityManager *ecs.EntityManager` 字段
  - [x] 实现 `NewLifetimeSystem(em *ecs.EntityManager) *LifetimeSystem` 构造函数
  - [x] 实现 `Update(deltaTime float64)` 方法:
    - [x] 查询所有拥有 `LifetimeComponent` 的实体
    - [x] 对于每个实体:
      - [x] 增加 `CurrentLifetime += deltaTime`
      - [x] 如果 `CurrentLifetime >= MaxLifetime`,标记 `IsExpired = true`
      - [x] 如果 `IsExpired == true`,调用 `entityManager.DestroyEntity(id)` 标记删除
  - [x] 系统不直接删除实体,只标记,由 EntityManager 统一清理
  [Source: architecture/coding-standards.md#零耦合原则, architecture/unified-project-structure.md#pkg/systems]

- [x] Task 6: 实现阳光生成系统 (AC: 1)
  - [x] 创建 `pkg/systems/sun_spawn_system.go` 文件
  - [x] 实现 `SunSpawnSystem` 结构体:
    - [x] `entityManager *ecs.EntityManager`
    - [x] `resourceManager *game.ResourceManager`
    - [x] `spawnTimer float64` - 当前计时器
    - [x] `spawnInterval float64` - 生成间隔(8秒,原版机制)
    - [x] `minX, maxX float64` - 阳光生成的水平范围(草坪区域)
    - [x] `minTargetY, maxTargetY float64` - 阳光落地的垂直范围
  - [x] 实现 `NewSunSpawnSystem(em, rm, minX, maxX, minY, maxY)` 构造函数,初始化 `spawnInterval=8.0`
  - [x] 实现 `Update(deltaTime float64)` 方法:
    - [x] 累加 `spawnTimer += deltaTime`
    - [x] 如果 `spawnTimer >= spawnInterval`:
      - [x] 重置计时器 `spawnTimer = 0`
      - [x] 生成随机起始X坐标: `startX = minX + rand.Float64() * (maxX - minX)`
      - [x] 生成随机落地Y坐标: `targetY = minTargetY + rand.Float64() * (maxTargetY - minTargetY)`
      - [x] 调用 `entities.NewSunEntity(entityManager, resourceManager, startX, targetY)`
  - [x] 草坪区域坐标基于 GameScene 布局:
    - [x] 水平范围: X 从 250 到 900 (草坪宽度)
    - [x] 垂直范围: Y 从 100 到 550 (避开UI和屏幕边缘)
  [Source: 原版PVZ游戏机制 - 阳光每8秒生成一次, Story 2.1草坪布局]

- [x] Task 7: 实现渲染系统 (AC: 2, 4)
  - [x] 创建 `pkg/systems/render_system.go` 文件
  - [x] 实现 `RenderSystem` 结构体包含 `entityManager *ecs.EntityManager` 字段
  - [x] 实现 `NewRenderSystem(em *ecs.EntityManager) *RenderSystem` 构造函数
  - [x] 实现 `Draw(screen *ebiten.Image)` 方法:
    - [x] 查询所有同时拥有 `PositionComponent` 和 `SpriteComponent` 的实体
    - [x] 对于每个实体:
      - [x] 创建 `ebiten.DrawImageOptions`
      - [x] 设置平移: `op.GeoM.Translate(position.X, position.Y)`
      - [x] 调用 `screen.DrawImage(sprite.Image, op)` 绘制到屏幕
  - [x] 渲染系统独立于实体类型,可渲染所有拥有位置和精灵组件的实体
  [Source: architecture/high-level-architecture.md#渲染系统, architecture/coding-standards.md]

- [x] Task 8: 在 GameScene 中集成 ECS 和阳光系统 (AC: All)
  - [x] 修改 `pkg/scenes/game_scene.go`,添加字段:
    - [x] `entityManager *ecs.EntityManager`
    - [x] `sunSpawnSystem *systems.SunSpawnSystem`
    - [x] `sunMovementSystem *systems.SunMovementSystem`
    - [x] `lifetimeSystem *systems.LifetimeSystem`
    - [x] `renderSystem *systems.RenderSystem`
  - [x] 在 `NewGameScene` 构造函数中:
    - [x] 创建 `EntityManager` 实例
    - [x] 创建并初始化所有系统(传入 entityManager 和其他依赖)
    - [x] 设置阳光生成系统的草坪范围参数(250-900, 100-550)
  - [x] 在 `Update(deltaTime float64)` 方法中:
    - [x] 动画播放完成后(`!isIntroAnimPlaying`),按顺序调用:
      - [x] `sunSpawnSystem.Update(deltaTime)` - 生成阳光
      - [x] `sunMovementSystem.Update(deltaTime)` - 移动阳光
      - [x] `lifetimeSystem.Update(deltaTime)` - 检查过期
      - [x] `entityManager.RemoveMarkedEntities()` - 清理已删除实体
    - [x] 系统调用顺序确保逻辑一致性
  - [x] 在 `Draw(screen *ebiten.Image)` 方法中:
    - [x] 在绘制完 UI 元素后,调用 `renderSystem.Draw(screen)` 渲染所有实体
  - [x] 移除 Story 2.2 的临时键盘测试代码(A/S键)
  [Source: Story 2.1 GameScene架构, architecture/high-level-architecture.md#数据流]

- [x] Task 9: 编写 ECS 框架单元测试 (AC: All)
  - [x] 创建 `pkg/ecs/entity_manager_test.go`
  - [x] 测试实体创建和唯一ID生成
  - [x] 测试组件添加、获取和检查功能
  - [x] 测试实体标记删除和清理机制
  - [x] 测试多实体和多组件的并发管理
  - [x] 确保测试覆盖率达到 80%+
  [Source: architecture/testing-strategy.md#单元测试, architecture/coding-standards.md]

- [x] Task 10: 编写组件和系统单元测试 (AC: All)
  - [x] 创建 `pkg/systems/sun_movement_system_test.go` - 测试阳光掉落和停留逻辑
  - [x] 创建 `pkg/systems/lifetime_system_test.go` - 测试生命周期计时和过期标记
  - [x] 创建 `pkg/systems/sun_spawn_system_test.go` - 测试定时生成和随机位置
  - [x] 创建 `pkg/systems/render_system_test.go` - 测试渲染系统查询和绘制调用
  - [x] 每个系统的测试包含正常流程和边界情况
  [Source: architecture/testing-strategy.md#单元测试目标80%+]

- [x] Task 11: 集成测试与验证 (AC: All)
  - [x] 运行游戏,进入 GameScene
  - [x] 验证动画播放完成后开始生成阳光
  - [x] 验证阳光从屏幕顶部掉落(AC 1)
  - [x] 验证阳光平滑下落并停留在草坪上(AC 2)
  - [x] 验证阳光在地面停留约8秒后自动消失(AC 3)
  - [x] 验证同时存在多个阳光实体,互不干扰(AC 4)
  - [x] 验证 go test 所有测试通过
  - [x] 验证 go build 编译成功
  [Source: architecture/testing-strategy.md#集成测试]

## Dev Notes

### 前序故事关键洞察
[Source: docs/stories/2.2.story.md - Dev Agent Record & QA Results]

**Story 2.2 已实现的功能:**
- ✅ GameState 单例管理全局游戏状态(阳光数量)
- ✅ GameScene 架构完善,包含 Update/Draw 循环
- ✅ 阳光计数器 UI 已实现,显示 GameState.Sun 值
- ✅ GameScene 包含3秒开场动画(相机滑动)
- ✅ ResourceManager 支持图片和字体资源加载

**重要接口:**
```go
// GameState API (pkg/game/game_state.go)
func GetGameState() *GameState  // 获取全局单例
func (gs *GameState) GetSun() int
func (gs *GameState) AddSun(amount int)
func (gs *GameState) SpendSun(amount int) bool

// GameScene 结构 (pkg/scenes/game_scene.go)
type GameScene struct {
    resourceManager *game.ResourceManager
    sceneManager *game.SceneManager
    gameState *game.GameState
    // ... UI资源字段
    isIntroAnimPlaying bool  // 动画播放完成后才能开始游戏逻辑
}
```

**本故事注意事项:**
- 阳光生成应等待开场动画完成(`!isIntroAnimPlaying`)
- Story 2.2 的临时键盘测试代码(A/S键)应在本故事中移除
- 阳光收集功能(点击阳光)将在 Story 2.4 实现
- 本故事专注于阳光的生成、掉落和自动消失机制

### 架构概览
[Source: architecture/high-level-architecture.md]

**ECS (实体-组件-系统) 架构核心原则:**

1. **实体 (Entity)**:
   - 实体只是一个唯一的标识符(EntityID),通常是 uint64
   - 实体本身不包含任何数据或行为
   - 一个实体通过关联多个组件来获得属性和能力

2. **组件 (Component)**:
   - 组件是纯数据结构(Plain Old Data Structures)
   - 严禁在组件中包含任何方法或行为逻辑
   - 示例: `PositionComponent{X, Y float64}`, `VelocityComponent{VX, VY float64}`
   - 组件通过组合来定义实体的能力(如: 位置+速度=可移动实体)

3. **系统 (System)**:
   - 系统包含所有的行为逻辑
   - 系统查询拥有特定组件集合的实体,并对其进行操作
   - 系统之间严禁直接调用,必须通过 EntityManager 或 EventBus 通信
   - 系统示例: MovementSystem 查询所有拥有 Position+Velocity 的实体并更新位置

4. **EntityManager**:
   - 负责管理所有实体和组件的映射关系
   - 提供创建、销毁实体的接口
   - 提供添加、获取、移除组件的接口
   - 提供查询特定组件组合的实体的接口

**ECS 架构优势:**
- 高度解耦: 组件可任意组合,无继承层级
- 易于扩展: 添加新行为只需新增组件和系统
- 性能优化: 数据局部性好,便于缓存优化
- 代码复用: 同一系统可处理所有相关实体

**原版游戏阳光掉落机制:**
[Source: 原版 Plants vs Zombies PC 版游戏机制分析]

- 阳光每 **8 秒** 生成一次(开发者可用随机间隔 7-10 秒增加自然感)
- 阳光从屏幕顶部随机 X 坐标生成,初始 Y = -50(屏幕外)
- 阳光以 **60 像素/秒** 的速度垂直下落
- 阳光落到草坪上的随机 Y 坐标(约 100-550 像素)停止
- 阳光在地面停留 **约 13 秒** 后消失(加上掉落的2秒,总生命周期约15秒)
- 多个阳光可同时存在,互不干扰

### ECS 框架实现规范
[Source: architecture/high-level-architecture.md#ECS架构, architecture/coding-standards.md]

**EntityManager 核心数据结构:**
```go
// pkg/ecs/entity_manager.go

package ecs

import "reflect"

type EntityID uint64

type EntityManager struct {
    nextID uint64
    // 实体-组件映射: EntityID -> ComponentType -> Component实例
    components map[EntityID]map[reflect.Type]interface{}
    // 待删除的实体ID列表
    entitiesToDestroy []EntityID
}

func NewEntityManager() *EntityManager {
    return &EntityManager{
        nextID:            1, // ID从1开始,0保留为无效ID
        components:        make(map[EntityID]map[reflect.Type]interface{}),
        entitiesToDestroy: make([]EntityID, 0),
    }
}

// CreateEntity 创建新实体并返回唯一ID
func (em *EntityManager) CreateEntity() EntityID {
    id := EntityID(em.nextID)
    em.nextID++
    em.components[id] = make(map[reflect.Type]interface{})
    return id
}

// AddComponent 为实体添加组件
func (em *EntityManager) AddComponent(id EntityID, component interface{}) {
    componentType := reflect.TypeOf(component)
    em.components[id][componentType] = component
}

// GetComponent 获取实体的特定类型组件
func (em *EntityManager) GetComponent(id EntityID, componentType reflect.Type) (interface{}, bool) {
    if compMap, exists := em.components[id]; exists {
        if comp, found := compMap[componentType]; found {
            return comp, true
        }
    }
    return nil, false
}

// HasComponent 检查实体是否拥有特定类型组件
func (em *EntityManager) HasComponent(id EntityID, componentType reflect.Type) bool {
    if compMap, exists := em.components[id]; exists {
        _, found := compMap[componentType]
        return found
    }
    return false
}

// DestroyEntity 标记实体待删除(不立即删除)
func (em *EntityManager) DestroyEntity(id EntityID) {
    em.entitiesToDestroy = append(em.entitiesToDestroy, id)
}

// RemoveMarkedEntities 清理所有标记删除的实体
func (em *EntityManager) RemoveMarkedEntities() {
    for _, id := range em.entitiesToDestroy {
        delete(em.components, id)
    }
    em.entitiesToDestroy = em.entitiesToDestroy[:0] // 清空切片
}

// GetEntitiesWith 查询拥有指定组件类型组合的所有实体
// 参数: componentTypes ...reflect.Type - 需要的组件类型列表
// 返回: []EntityID - 满足条件的实体ID列表
func (em *EntityManager) GetEntitiesWith(componentTypes ...reflect.Type) []EntityID {
    result := make([]EntityID, 0)

    for id, compMap := range em.components {
        hasAll := true
        for _, ct := range componentTypes {
            if _, found := compMap[ct]; !found {
                hasAll = false
                break
            }
        }
        if hasAll {
            result = append(result, id)
        }
    }

    return result
}
```

**关键设计决策:**

1. **延迟删除机制**: 实体不会立即删除,而是先标记,在帧末统一清理
   - 避免在系统遍历实体时修改集合导致的迭代器失效问题
   - 确保所有系统在同一帧内看到一致的实体状态

2. **使用 reflect.Type 作为组件类型标识**:
   - Go 语言没有泛型(Go 1.18前),使用反射实现类型安全的组件查询
   - 性能足够(ECS 框架本身非性能瓶颈,2D游戏实体数量有限)

3. **组件存储为 interface{}**:
   - 使用类型断言获取具体组件实例
   - 系统获取组件后需要类型断言: `pos := comp.(*components.PositionComponent)`

### 组件定义规范
[Source: architecture/data-models.md, architecture/coding-standards.md]

**必需组件(本故事):**

```go
// pkg/components/position.go
package components

// PositionComponent 存储实体在游戏世界中的二维坐标
type PositionComponent struct {
    X, Y float64
}

// pkg/components/sprite.go
package components

import "github.com/hajimehoshi/ebiten/v2"

// SpriteComponent 存储实体的视觉表现(当前绘制的图像)
type SpriteComponent struct {
    Image *ebiten.Image
}

// pkg/components/velocity.go
package components

// VelocityComponent 存储实体的移动速度(像素/秒)
type VelocityComponent struct {
    VX, VY float64  // X轴和Y轴速度
}

// pkg/components/lifetime.go
package components

// LifetimeComponent 管理实体的生命周期
// 用于自动清理存在时间超过上限的实体(如阳光、子弹)
type LifetimeComponent struct {
    MaxLifetime     float64  // 最大生命周期(秒)
    CurrentLifetime float64  // 当前已存在时间(秒)
    IsExpired       bool     // 是否已过期
}

// pkg/components/sun.go
package components

// SunState 表示阳光的状态
type SunState int

const (
    SunFalling    SunState = iota  // 正在下落
    SunLanded                       // 已落地,静止
    SunCollecting                   // 正在被收集(Story 2.4)
)

// SunComponent 标记实体为阳光,并存储阳光特定的状态
type SunComponent struct {
    State   SunState  // 当前状态
    TargetY float64   // 目标落地Y坐标
}
```

**组件设计原则:**
- 组件只包含数据字段,严禁包含方法(除了可能的简单 getter/setter)
- 字段使用 PascalCase(公开访问)
- 添加清晰的 GoDoc 注释说明组件用途和字段含义

### 系统实现规范
[Source: architecture/coding-standards.md#零耦合原则]

**系统基本结构模式:**

```go
// pkg/systems/example_system.go
package systems

import (
    "reflect"
    "github.com/gonewx/pvz/pkg/ecs"
    "github.com/gonewx/pvz/pkg/components"
)

// ExampleSystem 示例系统,展示标准系统结构
type ExampleSystem struct {
    entityManager *ecs.EntityManager
    // 其他依赖...
}

// NewExampleSystem 构造函数,通过依赖注入获取 EntityManager
func NewExampleSystem(em *ecs.EntityManager) *ExampleSystem {
    return &ExampleSystem{
        entityManager: em,
    }
}

// Update 系统逻辑更新方法(每帧调用)
func (s *ExampleSystem) Update(deltaTime float64) {
    // 1. 查询拥有特定组件的所有实体
    entities := s.entityManager.GetEntitiesWith(
        reflect.TypeOf(&components.PositionComponent{}),
        reflect.TypeOf(&components.VelocityComponent{}),
    )

    // 2. 遍历实体并处理
    for _, id := range entities {
        // 获取组件
        posComp, _ := s.entityManager.GetComponent(id, reflect.TypeOf(&components.PositionComponent{}))
        velComp, _ := s.entityManager.GetComponent(id, reflect.TypeOf(&components.VelocityComponent{}))

        // 类型断言
        pos := posComp.(*components.PositionComponent)
        vel := velComp.(*components.VelocityComponent)

        // 处理逻辑
        pos.X += vel.VX * deltaTime
        pos.Y += vel.VY * deltaTime
    }
}
```

**系统设计关键原则:**

1. **零耦合**: 系统之间严禁直接调用,必须通过 EntityManager 查询实体和组件
2. **依赖注入**: 所有依赖(如 EntityManager, ResourceManager)通过构造函数注入
3. **单一职责**: 每个系统只负责一类行为(如移动、渲染、生命周期管理)
4. **查询 → 处理**: 先查询拥有特定组件的实体,再遍历处理

### 阳光生成系统详细设计
[Source: 原版游戏机制, Story 2.1草坪布局]

**草坪区域坐标计算:**

根据 Story 2.1 的 GameScene 布局:
- 窗口尺寸: 1400x600 (WindowWidth, WindowHeight)
- Seed Bank: X=0, Y=0, Width=500, Height=87
- 草坪背景: background1.jpg (开场动画后相机固定在 GameCameraX=220)

**阳光生成范围:**
- 水平范围 (X): 250 到 900 像素
  - 左边界: 避开左侧 UI 元素(Seed Bank 等)
  - 右边界: 避开屏幕右侧边缘
- 垂直范围 (Y): 100 到 550 像素
  - 上边界: 避开顶部 UI (Seed Bank 高度87像素)
  - 下边界: 避开屏幕底部边缘

**阳光生成逻辑:**
```go
// pkg/systems/sun_spawn_system.go 伪代码

func (s *SunSpawnSystem) Update(deltaTime float64) {
    s.spawnTimer += deltaTime

    if s.spawnTimer >= s.spawnInterval {
        s.spawnTimer = 0  // 重置计时器

        // 生成随机起始X坐标(屏幕顶部)
        startX := s.minX + rand.Float64() * (s.maxX - s.minX)

        // 生成随机落地Y坐标(草坪区域)
        targetY := s.minTargetY + rand.Float64() * (s.maxTargetY - s.minTargetY)

        // 创建阳光实体
        entities.NewSunEntity(s.entityManager, s.resourceManager, startX, targetY)
    }
}
```

**生成间隔调优:**
- 基础间隔: 8 秒(原版游戏机制)
- 可选: 添加随机偏移 ±1 秒增加自然感
- MVP 阶段使用固定 8 秒即可

### 项目结构
[Source: architecture/unified-project-structure.md]

**本故事涉及的新建文件:**
```
pvz/
├── pkg/
│   ├── ecs/                         # 新建目录
│   │   ├── entity_manager.go        # ECS 核心框架
│   │   └── entity_manager_test.go   # 单元测试
│   │
│   ├── components/                  # 新建目录
│   │   ├── position.go              # 位置组件
│   │   ├── sprite.go                # 精灵组件
│   │   ├── velocity.go              # 速度组件
│   │   ├── lifetime.go              # 生命周期组件
│   │   └── sun.go                   # 阳光组件
│   │
│   ├── entities/                    # 新建目录
│   │   └── sun_factory.go           # 阳光实体工厂
│   │
│   ├── systems/                     # 新建目录
│   │   ├── sun_spawn_system.go      # 阳光生成系统
│   │   ├── sun_spawn_system_test.go
│   │   ├── sun_movement_system.go   # 阳光移动系统
│   │   ├── sun_movement_system_test.go
│   │   ├── lifetime_system.go       # 生命周期系统
│   │   ├── lifetime_system_test.go
│   │   ├── render_system.go         # 渲染系统
│   │   └── render_system_test.go
│   │
│   └── scenes/
│       └── game_scene.go            # 修改: 集成 ECS 和系统
│
└── assets/
    └── images/
        └── interface/
            └── Sun.gif              # 阳光图片资源(已存在)
```

**目录职责:**
- `pkg/ecs/`: ECS 框架核心,实体和组件管理
- `pkg/components/`: 所有组件定义(纯数据结构)
- `pkg/entities/`: 实体工厂函数(创建预配置的实体)
- `pkg/systems/`: 所有系统实现(行为逻辑)
- `pkg/scenes/`: 游戏场景,组装和驱动系统

### GameScene 集成流程
[Source: Story 2.1 GameScene架构, architecture/high-level-architecture.md#数据流]

**修改 GameScene 结构体:**
```go
// pkg/scenes/game_scene.go

type GameScene struct {
    // ... 现有字段 (resourceManager, sceneManager, gameState, UI资源等)

    // 新增: ECS 框架和系统
    entityManager      *ecs.EntityManager
    sunSpawnSystem     *systems.SunSpawnSystem
    sunMovementSystem  *systems.SunMovementSystem
    lifetimeSystem     *systems.LifetimeSystem
    renderSystem       *systems.RenderSystem
}
```

**修改 NewGameScene 构造函数:**
```go
func NewGameScene(rm *game.ResourceManager, sm *game.SceneManager) *GameScene {
    scene := &GameScene{
        // ... 现有初始化代码
    }

    // 加载 UI 资源
    scene.loadResources()

    // 初始化 ECS 框架
    scene.entityManager = ecs.NewEntityManager()

    // 初始化系统
    scene.renderSystem = systems.NewRenderSystem(scene.entityManager)
    scene.sunMovementSystem = systems.NewSunMovementSystem(scene.entityManager)
    scene.lifetimeSystem = systems.NewLifetimeSystem(scene.entityManager)

    // 初始化阳光生成系统,传入草坪范围参数
    scene.sunSpawnSystem = systems.NewSunSpawnSystem(
        scene.entityManager,
        rm,
        250.0,  // minX - 草坪左边界
        900.0,  // maxX - 草坪右边界
        100.0,  // minTargetY - 草坪上边界
        550.0,  // maxTargetY - 草坪下边界
    )

    return scene
}
```

**修改 Update 方法:**
```go
func (s *GameScene) Update(deltaTime float64) {
    // 处理开场动画
    if s.isIntroAnimPlaying {
        s.updateIntroAnimation(deltaTime)
        return  // 动画期间不执行游戏逻辑
    }

    // 移除 Story 2.2 的临时键盘测试代码(A/S键)

    // 按顺序更新所有系统
    s.sunSpawnSystem.Update(deltaTime)       // 生成阳光
    s.sunMovementSystem.Update(deltaTime)    // 移动阳光
    s.lifetimeSystem.Update(deltaTime)       // 检查生命周期
    s.entityManager.RemoveMarkedEntities()   // 清理已删除实体

    // 未来: 其他系统更新(输入、行为、碰撞等)
}
```

**修改 Draw 方法:**
```go
func (s *GameScene) Draw(screen *ebiten.Image) {
    // 绘制背景
    s.drawBackground(screen)

    // 绘制 UI 元素
    s.drawSeedBank(screen)
    s.drawSunCounter(screen)
    s.drawShovel(screen)

    // 绘制所有实体(阳光、植物、僵尸等)
    s.renderSystem.Draw(screen)
}
```

**关键注意事项:**
1. 系统更新顺序很重要:
   - 先生成(Spawn) → 再移动(Movement) → 再检查生命周期(Lifetime) → 最后清理(Remove)
   - 确保逻辑一致性,避免竞态条件

2. 开场动画期间不执行游戏逻辑:
   - 只有 `isIntroAnimPlaying == false` 后才开始生成阳光
   - 避免玩家在动画期间看到阳光突然出现

3. 清理工作:
   - 移除 Story 2.2 的临时键盘测试代码(按 A/S 键增减阳光)
   - 这些代码在 Story 2.4 实现真实阳光收集后不再需要

### Testing
[Source: architecture/testing-strategy.md]

**测试框架**: Go 标准库 `testing` 包

**测试文件位置**:
- `pkg/ecs/entity_manager_test.go` - ECS 框架单元测试
- `pkg/systems/*_test.go` - 各系统单元测试

**测试覆盖率目标**:
- ECS 框架(`pkg/ecs`)目标覆盖率 **90%+**(核心基础设施)
- Systems(`pkg/systems`)目标覆盖率 **80%+**
- Components 无需测试(纯数据结构)

**ECS 框架测试重点**:

```go
// pkg/ecs/entity_manager_test.go 示例测试

func TestCreateEntity(t *testing.T) {
    em := NewEntityManager()
    id1 := em.CreateEntity()
    id2 := em.CreateEntity()

    // 测试实体ID唯一性
    if id1 == id2 {
        t.Error("Entity IDs should be unique")
    }
}

func TestAddAndGetComponent(t *testing.T) {
    em := NewEntityManager()
    id := em.CreateEntity()

    // 添加组件
    pos := &components.PositionComponent{X: 100, Y: 200}
    em.AddComponent(id, pos)

    // 获取组件
    comp, found := em.GetComponent(id, reflect.TypeOf(&components.PositionComponent{}))
    if !found {
        t.Error("Component should be found")
    }

    retrieved := comp.(*components.PositionComponent)
    if retrieved.X != 100 || retrieved.Y != 200 {
        t.Error("Component data mismatch")
    }
}

func TestDestroyEntity(t *testing.T) {
    em := NewEntityManager()
    id := em.CreateEntity()
    em.AddComponent(id, &components.PositionComponent{})

    // 标记删除
    em.DestroyEntity(id)

    // 清理前实体仍存在
    if !em.HasComponent(id, reflect.TypeOf(&components.PositionComponent{})) {
        t.Error("Entity should still exist before cleanup")
    }

    // 清理后实体消失
    em.RemoveMarkedEntities()
    if em.HasComponent(id, reflect.TypeOf(&components.PositionComponent{})) {
        t.Error("Entity should be removed after cleanup")
    }
}

func TestGetEntitiesWith(t *testing.T) {
    em := NewEntityManager()

    // 创建不同组件组合的实体
    id1 := em.CreateEntity()
    em.AddComponent(id1, &components.PositionComponent{})
    em.AddComponent(id1, &components.VelocityComponent{})

    id2 := em.CreateEntity()
    em.AddComponent(id2, &components.PositionComponent{})

    // 查询拥有 Position+Velocity 的实体
    entities := em.GetEntitiesWith(
        reflect.TypeOf(&components.PositionComponent{}),
        reflect.TypeOf(&components.VelocityComponent{}),
    )

    if len(entities) != 1 || entities[0] != id1 {
        t.Error("Query should return only id1")
    }
}
```

**系统测试重点**:

```go
// pkg/systems/sun_movement_system_test.go 示例

func TestSunFalling(t *testing.T) {
    em := ecs.NewEntityManager()
    system := systems.NewSunMovementSystem(em)

    // 创建测试阳光实体
    id := em.CreateEntity()
    em.AddComponent(id, &components.PositionComponent{X: 100, Y: 0})
    em.AddComponent(id, &components.VelocityComponent{VX: 0, VY: 60})
    em.AddComponent(id, &components.SunComponent{State: components.SunFalling, TargetY: 100})

    // 模拟1秒更新
    system.Update(1.0)

    // 验证位置更新
    posComp, _ := em.GetComponent(id, reflect.TypeOf(&components.PositionComponent{}))
    pos := posComp.(*components.PositionComponent)

    if pos.Y != 60 {  // 初始0 + 60像素/秒 * 1秒
        t.Errorf("Expected Y=60, got Y=%f", pos.Y)
    }
}

func TestSunLanding(t *testing.T) {
    em := ecs.NewEntityManager()
    system := systems.NewSunMovementSystem(em)

    // 创建即将落地的阳光
    id := em.CreateEntity()
    em.AddComponent(id, &components.PositionComponent{X: 100, Y: 90})
    em.AddComponent(id, &components.VelocityComponent{VX: 0, VY: 60})
    em.AddComponent(id, &components.SunComponent{State: components.SunFalling, TargetY: 100})

    // 模拟更新
    system.Update(0.5)  // 90 + 60*0.5 = 120 > 100,应该落地

    // 验证状态变为 Landed
    sunComp, _ := em.GetComponent(id, reflect.TypeOf(&components.SunComponent{}))
    sun := sunComp.(*components.SunComponent)

    if sun.State != components.SunLanded {
        t.Error("Sun should have landed")
    }

    // 验证速度归零
    velComp, _ := em.GetComponent(id, reflect.TypeOf(&components.VelocityComponent{}))
    vel := velComp.(*components.VelocityComponent)

    if vel.VY != 0 {
        t.Error("Velocity should be zero after landing")
    }
}
```

**集成测试验证**:
- 手动运行游戏,观察阳光生成、掉落、停留、消失的完整流程
- 验证多个阳光同时存在且互不干扰
- 验证开场动画完成后才开始生成阳光
- 验证所有单元测试通过: `go test ./...`

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5

### Debug Log References
- 编译成功: `go build -o pvz` - 无错误
- 所有测试通过: `go test ./... -v`
- 测试覆盖率:
  - ECS框架: 96.7% (超出目标90%)
  - Systems: 100.0% (超出目标80%)
  - 所有单元测试通过(17个系统测试)

### Completion Notes
1. **ECS框架实现**: 成功实现完整的Entity-Component-System架构,包括EntityManager核心管理器
2. **组件系统**: 创建了5个组件(Position, Sprite, Velocity, Lifetime, Sun),严格遵循数据-行为分离原则
3. **系统实现**: 实现了4个系统(RenderSystem, SunMovementSystem, LifetimeSystem, SunSpawnSystem)
4. **GameScene集成**: 成功将ECS系统集成到GameScene,移除了Story 2.2的临时测试代码
5. **测试覆盖**: 编写了完整的单元测试,覆盖率超出目标
6. **阳光生成机制**: 实现了每8秒生成一次阳光,从屏幕顶部随机位置掉落到草坪区域

### File List
**新建文件:**
- `pkg/ecs/entity_manager.go` - ECS核心框架
- `pkg/ecs/entity_manager_test.go` - ECS框架测试
- `pkg/components/position.go` - 位置组件
- `pkg/components/sprite.go` - 精灵组件
- `pkg/components/velocity.go` - 速度组件
- `pkg/components/lifetime.go` - 生命周期组件
- `pkg/components/sun.go` - 阳光组件
- `pkg/entities/sun_factory.go` - 阳光实体工厂
- `pkg/systems/render_system.go` - 渲染系统
- `pkg/systems/render_system_test.go` - 渲染系统测试
- `pkg/systems/sun_movement_system.go` - 阳光移动系统
- `pkg/systems/sun_movement_system_test.go` - 移动系统测试
- `pkg/systems/lifetime_system.go` - 生命周期系统
- `pkg/systems/lifetime_system_test.go` - 生命周期测试
- `pkg/systems/sun_spawn_system.go` - 阳光生成系统
- `pkg/systems/sun_spawn_system_test.go` - 生成系统测试

**修改文件:**
- `pkg/scenes/game_scene.go` - 集成ECS系统,移除临时测试代码

## QA Results

### Review Date: 2025-10-11

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: EXCELLENT**

本Story实现了高质量的ECS(Entity-Component-System)架构框架,这是整个游戏的核心基础设施。实现展现了优秀的架构设计和工程实践:

**架构亮点:**
1. **ECS框架设计精良**: EntityManager实现清晰,支持实体创建、组件管理、查询和延迟删除
2. **完美的关注点分离**: 组件只包含数据,系统包含逻辑,严格遵循数据-行为分离原则
3. **零耦合设计**: 系统之间通过EntityManager通信,无直接依赖
4. **可扩展性强**: 新增游戏元素只需添加组件和系统,无需修改现有代码

**代码质量:**
- GoDoc注释完整清晰
- 变量命名语义化
- 逻辑简洁易懂
- 无代码重复

**测试质量:**
- 测试覆盖率优秀(ECS: 96.7%, Systems: 100%)
- 17个单元测试覆盖所有核心场景
- 测试用例设计合理,包含边界情况

### Refactoring Performed

**File**: pkg/systems/sun_spawn_system.go (line 59-62)
- **Change**: 移除了调试println语句
- **Why**: 生产代码不应包含调试输出语句,违反编码标准
- **How**: 删除了`sunID`变量赋值和println调试输出,直接调用`entities.NewSunEntity`而不保存返回值

### Requirements Traceability (需求可追溯性)

所有验收标准都有完整的测试覆盖:

**AC 1: 定时生成阳光**
- **Given**: 游戏场景初始化完成,intro动画结束
- **When**: 每8秒时间间隔到达
- **Then**: 从屏幕顶部随机X坐标(250-900)生成阳光实体
- **Tests**: TestSunSpawnTimer, TestSunSpawnMultiple, TestSunSpawnPositionRange
- **Status**: ✓ PASS

**AC 2: 阳光平滑下落并停留**
- **Given**: 阳光实体处于SunFalling状态
- **When**: SunMovementSystem每帧更新
- **Then**: Y坐标以60像素/秒速度增加,达到TargetY后状态变为SunLanded并停止移动
- **Tests**: TestSunFalling, TestSunLanding, TestSunLandedStaysStill
- **Status**: ✓ PASS

**AC 3: 阳光自动消失**
- **Given**: 阳光实体存在
- **When**: 生命周期超过15秒(掉落2秒+停留13秒)
- **Then**: LifetimeSystem标记实体过期,EntityManager清理删除
- **Tests**: TestLifetimeExpiration, TestLifetimeMultipleUpdates
- **Status**: ✓ PASS

**AC 4: 多阳光同时存在**
- **Given**: 系统正在运行
- **When**: 多次生成间隔到达
- **Then**: 创建多个阳光实体,各自独立移动和生命周期管理
- **Tests**: TestMultipleSuns, TestMultipleEntitiesWithDifferentLifetimes
- **Status**: ✓ PASS

### Compliance Check

- **Coding Standards**: ✓ PASS
  - 严格遵循Go命名约定(PascalCase for structs, camelCase for variables)
  - 所有代码已格式化(gofmt)
  - GoDoc注释完整
  - 零耦合原则完美执行
  - 数据-行为分离严格遵守
  - 移除调试代码后无违规项

- **Project Structure**: ✓ PASS
  - ECS框架位于`pkg/ecs/`
  - 组件位于`pkg/components/`
  - 系统位于`pkg/systems/`
  - 实体工厂位于`pkg/entities/`
  - 完全符合架构规范

- **Testing Strategy**: ✓ PASS (EXCELLENT)
  - 单元测试覆盖率超出目标(ECS: 96.7% > 90%, Systems: 100% > 80%)
  - 测试设计合理,包含正常流程和边界情况
  - 测试独立性好,无依赖关系

- **All ACs Met**: ✓ PASS
  - 4个验收标准全部实现并有测试覆盖
  - 功能完整,无遗漏

### Test Architecture Assessment

**测试层级: 单元测试为主** (符合测试金字塔)

**测试覆盖分析:**
- ECS Framework: 7个测试 → 96.7%覆盖率
- SunMovementSystem: 4个测试 → 100%覆盖率
- LifetimeSystem: 4个测试 → 100%覆盖率
- SunSpawnSystem: 5个测试 → 100%覆盖率
- RenderSystem: 4个测试 → 100%覆盖率

**测试设计质量: EXCELLENT**
- 每个系统都有独立的测试文件
- 测试用例命名清晰(Test + 功能描述)
- 使用table-driven tests适合的场景
- 边界条件覆盖完整(空场景、多实体、过期等)

**测试可维护性: HIGH**
- 测试代码简洁易读
- 无重复测试逻辑
- 使用共享的testAudioContext避免重复初始化

### Security Review

**Status**: ✓ PASS (N/A for this story)
- 本Story实现游戏逻辑,不涉及安全敏感操作
- 无用户输入处理
- 无网络通信
- 无数据持久化

### Performance Considerations

**Status**: ✓ PASS

**优点:**
1. **ECS架构对性能友好**: 数据局部性好,便于CPU缓存优化
2. **延迟删除机制**: 避免遍历时修改集合,防止迭代器失效
3. **批量查询处理**: 系统批量处理实体而非逐个调用

**潜在优化点(非阻塞):**
- 当实体数量达到数千级别时,可考虑为GetEntitiesWith添加缓存
- 可考虑使用对象池复用阳光实体(当前实现已足够,可作为未来优化)

**当前性能评估**: 优秀 - 2D游戏实体数量有限(< 1000),当前实现性能充足

### Non-Functional Requirements Validation

**Reliability (可靠性)**: ✓ PASS
- 所有公共API都有错误处理
- 组件获取使用类型断言前已验证存在性
- 边界条件处理完善(nil image跳过渲染)

**Maintainability (可维护性)**: ✓ PASS
- 代码结构清晰,模块化好
- 注释完整,易于理解
- 低耦合高内聚

**Extensibility (可扩展性)**: ✓ EXCELLENT
- 新增植物/僵尸只需添加新组件和系统
- ECS架构天然支持组件组合扩展

### Technical Debt Assessment

**债务等级: MINIMAL** (技术债务极低)

**已识别的轻微技术债务:**
1. **类型安全性**: 使用`interface{}`和`reflect.Type`导致编译时类型检查缺失
   - **影响**: 低 (Go 1.18之前的标准ECS实现方式)
   - **建议**: Go 1.18+可考虑使用泛型重构,但非必需
   - **优先级**: P3 (Nice-to-have)

2. **对象池**: 频繁创建/销毁的阳光实体未使用对象池
   - **影响**: 极低 (阳光生成频率低,GC压力小)
   - **建议**: 当实体数量成为性能瓶颈时再考虑
   - **优先级**: P4 (Future optimization)

**无阻塞性技术债务**

### Files Modified During Review

**Modified Files:**
- `pkg/systems/sun_spawn_system.go` - 移除调试println语句

**请开发者更新Story文件的File List部分,将此文件标记为"修改"状态**

### Gate Status

**Gate**: PASS
**Quality Score**: 95/100

Gate文件路径: `docs/qa/gates/2.3-sun-drop-system.yml`

**决策理由:**
- 所有4个验收标准完全实现并有测试覆盖
- 测试覆盖率优秀(96.7%-100%)
- 代码质量高,严格遵循架构规范
- 发现的唯一问题(调试代码)已在审查中修复
- 无阻塞性问题或技术债务

**证据:**
- 17个单元测试全部通过
- 编译成功无警告
- 代码审查无critical/high问题

### Recommendations

**即时行动 (已完成):**
- ✓ 移除生产代码中的调试输出 (pkg/systems/sun_spawn_system.go)

**未来改进 (可选,非阻塞):**
- [ ] 当Go版本升级到1.18+后,可考虑使用泛型改进EntityManager类型安全性
- [ ] 如果未来性能分析显示GC压力,可为阳光实体实现对象池
- [ ] 考虑添加集成测试验证完整的阳光生成-下落-消失流程

### Recommended Status

**✓ Ready for Done**

本Story实现质量优秀,已满足所有验收标准,测试覆盖全面,无阻塞问题。建议立即合并到主分支。

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-11 | 1.0 | Initial story creation with complete ECS framework and sun drop system | Scrum Master (Bob) |
| 2025-10-11 | 1.1 | Corrected sun image path from sun.png to Sun.gif | Scrum Master (Bob) |
| 2025-10-11 | 2.0 | Implemented complete ECS framework and sun drop system with all tests passing | Dev Agent (James) |
| 2025-10-11 | 2.1 | Fixed sun image path to use correct location: assets/images/interface/Sun.gif | Dev Agent (James) |
