# Story 19.7: 保龄球碰撞与弹射系统

## Status

Done

## Story

**As a** 玩家,
**I want** 保龄球坚果能够碰撞僵尸并弹射到相邻行,
**so that** 我能体验保龄球的物理乐趣，用一个坚果消灭多个僵尸。

## Acceptance Criteria

1. **坚果碰撞僵尸造成大量伤害**
   - 碰撞时造成 1800 点伤害（与樱桃炸弹相同）
   - 足以秒杀普通僵尸（270 HP）和路障僵尸（640 HP）
   - 铁桶僵尸（1370 HP）被碰撞后剩余少量生命

2. **路障僵尸帽子被打掉**
   - 碰撞路障僵尸时，优先扣除护甲
   - 伤害超过护甲值时，破坏帽子并扣除剩余身体生命值
   - 触发护甲破坏动画（复用现有逻辑）

3. **碰撞后向相邻行弹射**
   - 普通坚果碰撞后继续滚动，但弹到上或下一行
   - 弹射后 Y 坐标变更为目标行中心
   - 保持 X 方向速度不变（继续向右）

4. **优先弹向 X 轴距离最近的僵尸所在行**
   - 检测上下相邻行的僵尸
   - 计算各行最近僵尸与坚果的 X 轴距离
   - 优先弹向 **X 轴距离最近** 的僵尸所在行
   - 距离相等或两行都没有僵尸时，随机选择

5. **边缘行（第0行/第4行）碰墙反弹**
   - 第 0 行（顶部边缘）只能向下弹射
   - 第 4 行（底部边缘）只能向上弹射
   - 边缘行碰撞后，向唯一可用方向弹射
   - 注：行号使用 0-indexed（0-4），对应游戏中的 5 行草坪

6. **多次碰撞持续弹射**
   - 每次碰撞后 BounceCount 递增
   - 无最大弹射次数限制（滚出屏幕自动销毁）
   - 每次弹射后继续检测新行的僵尸

7. **播放撞击音效**
   - 使用 `bowlingimpact.ogg` 作为撞击音效
   - 每次碰撞播放一次（不循环）
   - 随机使用 `bowlingimpact.ogg` 或 `bowlingimpact2.ogg` 增加变化

8. **单元测试**: 覆盖率 ≥ 80%

## Tasks / Subtasks

### Task 1: 扩展 BowlingNutComponent (AC: 3, 6)

- [x] 修改 `pkg/components/bowling_nut_component.go`
  - [x] 添加 `VelocityY float64` 字段 - 弹射时的垂直速度
  - [x] 添加 `IsBouncing bool` 字段 - 是否正在弹射中
  - [x] 添加 `TargetRow int` 字段 - 弹射目标行
  - [x] 添加 `CollisionCooldown float64` 字段 - 碰撞冷却时间（防止重复碰撞）

### Task 2: 添加碰撞配置常量 (AC: 1, 7)

- [x] 修改 `pkg/config/layout_config.go`
  - [x] `BowlingNutDamage = 1800` - 保龄球坚果碰撞伤害
  - [x] `BowlingNutBounceSpeed = 300.0` - 弹射时的垂直移动速度
  - [x] `BowlingNutCollisionCooldown = 0.1` - 碰撞冷却时间（秒）
- [x] 修改 `pkg/config/unit_config.go`
  - [x] `BowlingImpactSoundPath = "assets/sounds/bowlingimpact.ogg"`
  - [x] `BowlingImpact2SoundPath = "assets/sounds/bowlingimpact2.ogg"`

### Task 3: 实现碰撞检测逻辑 (AC: 1, 2)

- [x] 修改 `pkg/systems/bowling_nut_system.go`
  - [x] 添加 `checkCollisionWithZombies()` 方法
    - [x] 查询同行的所有僵尸实体
    - [x] 使用 AABB 碰撞检测（参考 PhysicsSystem）
    - [x] 返回碰撞的僵尸 EntityID 列表
  - [x] 添加碰撞盒计算（使用 BowlingNutCollisionWidth/Height）
  - [x] 实现碰撞冷却机制（避免同一帧多次碰撞）

### Task 4: 实现伤害处理逻辑 (AC: 1, 2)

- [x] 修改 `pkg/systems/bowling_nut_system.go`
  - [x] 添加 `applyDamageToZombie()` 方法
    - [x] 检查僵尸是否有 ArmorComponent
    - [x] 有护甲：优先扣除护甲，溢出伤害扣身体
    - [x] 无护甲：直接扣除 HealthComponent
  - [x] 添加闪烁效果（复用 FlashEffectComponent）
  - [x] 添加护甲破坏检测（复用 BehaviorSystem 逻辑）

### Task 5: 实现弹射方向计算 (AC: 3, 4, 5)

- [x] 修改 `pkg/systems/bowling_nut_system.go`
  - [x] 添加 `findNearestZombieDistance()` 方法
    - [x] 查询指定行的所有僵尸
    - [x] 返回最近僵尸的 X 轴距离（无僵尸返回 math.MaxFloat64）
  - [x] 添加 `calculateBounceDirection()` 方法
    - [x] 获取当前行号和坚果 X 坐标
    - [x] 边缘行处理：第 0 行只能向下，第 4 行只能向上
    - [x] 计算上下行最近僵尸的 X 轴距离
    - [x] 优先级：X 轴距离最近的僵尸所在行 > 随机选择
  - [x] 返回目标行号 (0-4)

### Task 6: 实现弹射移动逻辑 (AC: 3, 6)

- [x] 修改 `pkg/systems/bowling_nut_system.go`
  - [x] 添加 `startBounce()` 方法
    - [x] 设置 IsBouncing = true
    - [x] 设置 TargetRow
    - [x] 设置 VelocityY（正值向下，负值向上）
    - [x] 递增 BounceCount
  - [x] 修改 `Update()` 方法
    - [x] 弹射中：更新 Y 位置
    - [x] 检测是否到达目标行
    - [x] 到达后：重置 IsBouncing，更新 Row，清零 VelocityY

### Task 7: 实现撞击音效 (AC: 7)

- [x] 修改 `pkg/systems/bowling_nut_system.go`
  - [x] 添加 `playImpactSound()` 方法
    - [x] 随机选择 `bowlingimpact.ogg` 或 `bowlingimpact2.ogg`
    - [x] 加载并播放音效
  - [x] 在碰撞发生时调用

### Task 8: 集成碰撞处理到 Update 循环 (AC: 1-7)

- [x] 修改 `pkg/systems/bowling_nut_system.go` 的 `Update()` 方法
  - [x] 在位置更新后检测碰撞
  - [x] 碰撞发生时：
    - [x] 对僵尸造成伤害
    - [x] 播放撞击音效
    - [x] 计算弹射方向
    - [x] 开始弹射（普通坚果）
    - [x] 标记销毁（爆炸坚果，Story 19.8 处理爆炸逻辑）

### Task 9: 单元测试 (AC: 8)

- [x] 修改 `pkg/systems/bowling_nut_system_test.go`
  - [x] 测试碰撞检测：坚果与僵尸碰撞
  - [x] 测试伤害处理：普通僵尸被秒杀
  - [x] 测试护甲处理：路障僵尸护甲被打掉
  - [x] 测试弹射方向：优先弹向 X 轴距离最近的僵尸所在行
  - [x] 测试边缘行反弹：第 0 行向下，第 4 行向上
  - [x] 测试多次弹射：BounceCount 递增
  - [x] 测试碰撞冷却：避免同帧多次碰撞
- [x] 创建 `pkg/systems/bowling_nut_system_integration_test.go`
  - [x] 测试完整弹射流程
  - [x] 测试多僵尸场景

## Dev Notes

### 架构上下文

本 Story 是 Epic 19 的第七个 Story，实现保龄球坚果的碰撞与弹射物理。

**依赖关系**：
- **前置**: Story 19.6 保龄球坚果实体与滚动（已完成）
- **后续**: Story 19.8 爆炸坚果机制 - 使用本 Story 的碰撞检测，但触发爆炸而非弹射

[Source: docs/prd/epic-19-level-1-5-bowling.md#Story 19.7]

### 前置故事上下文

**Story 19.6: 保龄球坚果实体与滚动** (Done)

关键实现成果：
- `BowlingNutComponent` 已创建，包含 `VelocityX`, `Row`, `IsRolling`, `IsExplosive`, `BounceCount` 字段
- `BowlingNutSystem` 已实现基础滚动和边界销毁
- 配置常量已定义：
  - `BowlingNutSpeed = 250.0`（像素/秒）
  - `BowlingNutCollisionWidth = 60.0`
  - `BowlingNutCollisionHeight = 60.0`
- 音效管理已实现：`soundPlayers` map 管理每个实体的音效

关键代码位置：
- `pkg/components/bowling_nut_component.go` - 组件定义
- `pkg/systems/bowling_nut_system.go` - 系统实现
- `pkg/config/layout_config.go:488-506` - 配置常量

[Source: docs/stories/19.6.bowling-nut-entity-rolling.story.md#Completion Notes]

### 碰撞检测参考

**PhysicsSystem.checkAABBCollision()** 实现：

```go
// pkg/systems/physics_system.go:46-76
func (ps *PhysicsSystem) checkAABBCollision(
    pos1 *components.PositionComponent, col1 *components.CollisionComponent,
    pos2 *components.PositionComponent, col2 *components.CollisionComponent) bool {

    // 计算碰撞盒中心（应用偏移量）
    center1X := pos1.X + col1.OffsetX
    center1Y := pos1.Y + col1.OffsetY

    // 计算边界
    left1 := center1X - col1.Width/2
    right1 := center1X + col1.Width/2
    top1 := center1Y - col1.Height/2
    bottom1 := center1Y + col1.Height/2

    // 同样计算第二个碰撞盒...

    // AABB 碰撞检测
    return right1 >= left2 && left1 <= right2 &&
           bottom1 >= top2 && top1 <= bottom2
}
```

**保龄球坚果碰撞盒**（本 Story 需创建）：

```go
// 坚果没有 CollisionComponent，需要内联计算
nutCenterX := posComp.X
nutCenterY := posComp.Y
nutLeft := nutCenterX - config.BowlingNutCollisionWidth/2
nutRight := nutCenterX + config.BowlingNutCollisionWidth/2
nutTop := nutCenterY - config.BowlingNutCollisionHeight/2
nutBottom := nutCenterY + config.BowlingNutCollisionHeight/2
```

[Source: pkg/systems/physics_system.go#checkAABBCollision]

### 僵尸类型与生命值

| 僵尸类型 | BehaviorType | 身体 HP | 护甲 HP | 总 HP |
|---------|-------------|---------|---------|-------|
| 普通僵尸 | BehaviorZombieBasic | 270 | 0 | 270 |
| 路障僵尸 | BehaviorZombieConehead | 270 | 370 | 640 |
| 铁桶僵尸 | BehaviorZombieBuckethead | 270 | 1100 | 1370 |
| 旗帜僵尸 | BehaviorZombieFlag | 270 | 0 | 270 |

**伤害处理逻辑**：
- 保龄球坚果伤害 1800 > 所有僵尸总 HP
- 普通僵尸和路障僵尸会被秒杀
- 铁桶僵尸剩余 -430 HP（也会死亡）

[Source: pkg/config/unit_config.go#Zombie Configuration]

### 护甲处理参考

**PhysicsSystem 护甲伤害处理**：

```go
// pkg/systems/physics_system.go:203-238
armor, hasArmor := ecs.GetComponent[*components.ArmorComponent](ps.em, zombieID)
if hasArmor {
    if armor.CurrentArmor > 0 {
        // 有护甲且护甲未破坏，优先扣除护甲
        armor.CurrentArmor -= damage
        // 播放击中护甲音效
        ps.playArmorHitSound()
        // 添加闪烁效果
        ps.addFlashEffect(zombieID)
    } else {
        // 护甲已破坏，扣除身体生命值
        zombieHealth, ok := ecs.GetComponent[*components.HealthComponent](ps.em, zombieID)
        if ok {
            zombieHealth.CurrentHealth -= damage
            ps.addFlashEffect(zombieID)
        }
    }
} else {
    // 没有护甲，直接减少生命值
    zombieHealth, ok := ecs.GetComponent[*components.HealthComponent](ps.em, zombieID)
    if ok {
        zombieHealth.CurrentHealth -= damage
        ps.addFlashEffect(zombieID)
    }
}
```

**保龄球坚果特殊处理**：
由于伤害值（1800）远大于护甲值（最高 1100），需要处理溢出伤害：

```go
// 溢出伤害计算
if armor.CurrentArmor > 0 {
    overflowDamage := damage - armor.CurrentArmor
    armor.CurrentArmor = 0  // 护甲完全破坏
    if overflowDamage > 0 {
        zombieHealth.CurrentHealth -= overflowDamage
    }
}
```

[Source: pkg/systems/physics_system.go#护甲处理]

### 弹射物理算法

**弹射方向计算**（基于 X 轴距离优先级）：

```go
// findNearestZombieDistance 查找指定行最近僵尸的 X 轴距离
func (s *BowlingNutSystem) findNearestZombieDistance(row int, nutX float64) float64 {
    minDist := math.MaxFloat64

    zombies := ecs.GetEntitiesWith2[
        *components.BehaviorComponent,
        *components.PositionComponent,
    ](s.entityManager)

    for _, zombieID := range zombies {
        behavior, _ := ecs.GetComponent[*components.BehaviorComponent](s.entityManager, zombieID)
        if !isZombieType(behavior.Type) {
            continue
        }

        pos, _ := ecs.GetComponent[*components.PositionComponent](s.entityManager, zombieID)
        zombieRow := calculateRowFromY(pos.Y)

        if zombieRow == row {
            dist := math.Abs(pos.X - nutX)
            if dist < minDist {
                minDist = dist
            }
        }
    }

    return minDist
}

// calculateBounceDirection 计算弹射目标行
func (s *BowlingNutSystem) calculateBounceDirection(currentRow int, nutX float64) int {
    upRow := currentRow - 1
    downRow := currentRow + 1

    // 1. 边缘行处理
    if currentRow == 0 {
        return downRow  // 顶部边缘只能向下
    }
    if currentRow == 4 {
        return upRow    // 底部边缘只能向上
    }

    // 2. 计算上下行最近僵尸的 X 轴距离
    distUp := s.findNearestZombieDistance(upRow, nutX)
    distDown := s.findNearestZombieDistance(downRow, nutX)

    // 3. 优先弹向 X 轴距离最近的僵尸所在行
    if distUp < distDown {
        return upRow
    }
    if distDown < distUp {
        return downRow
    }

    // 4. 距离相等或都没有僵尸：随机选择
    if rand.Float32() < 0.5 {
        return upRow
    }
    return downRow
}
```

> **规范依据**: `.meta/levels/level1-5.md` 第 115 行：
> "优先级规则: 优先弹向'X轴距离最近'的邻行僵尸。"

[Source: .meta/levels/level1-5.md#3.1 滚动与伤害判定]

**弹射移动逻辑**：

```go
// Y 坐标移动
targetY := config.GridWorldStartY + float64(targetRow)*config.CellHeight + config.CellHeight/2

// 计算方向
if targetY > currentY {
    velocityY = config.BowlingNutBounceSpeed  // 向下
} else {
    velocityY = -config.BowlingNutBounceSpeed  // 向上
}

// 到达检测（在 Update 中）
if (velocityY > 0 && posComp.Y >= targetY) ||
   (velocityY < 0 && posComp.Y <= targetY) {
    posComp.Y = targetY  // 对齐到目标行
    nutComp.Row = targetRow
    nutComp.IsBouncing = false
    nutComp.VelocityY = 0
}
```

### 撞击视觉效果（可选增强）

规范文档提到的视觉效果，可在本 Story 或后续 Story 中实现：

1. **Hit 帧动画**：撞击瞬间有一个轻微的 Hit 帧
2. **撞击粒子特效**：碰撞时触发粒子效果
3. **观众欢呼声**：当一次击中多个僵尸时播放（需要额外音效资源）

> **注意**: 这些是增强效果，核心功能优先。如时间紧张可作为 Story 19.11 集成测试中的调优项。

[Source: .meta/levels/level1-5.md#6.2 动画]

### 坐标系统

**行中心 Y 坐标计算**：

```go
// 行号 0-4 对应的 Y 中心坐标
rowCenterY := config.GridWorldStartY + float64(row)*config.CellHeight + config.CellHeight/2

// 常量值：
// GridWorldStartY = 78.0
// CellHeight = 100.0
//
// 行 0: 78 + 0*100 + 50 = 128.0
// 行 1: 78 + 1*100 + 50 = 228.0
// 行 2: 78 + 2*100 + 50 = 328.0
// 行 3: 78 + 3*100 + 50 = 428.0
// 行 4: 78 + 4*100 + 50 = 528.0
```

[Source: pkg/config/layout_config.go#Lawn Grid Configuration]

### 音效资源

**可用保龄球音效文件**（位于 `assets/sounds/` 目录）：
- `bowling.ogg` - 坚果滚动循环音效（Story 19.6 使用）
- `bowlingimpact.ogg` - 碰撞撞击音效 ✅ 本 Story 使用
- `bowlingimpact2.ogg` - 碰撞撞击音效变体 ✅ 本 Story 使用

**音效播放模式**：

```go
// 随机选择音效
func (s *BowlingNutSystem) playImpactSound() {
    var soundPath string
    if rand.Float32() < 0.5 {
        soundPath = config.BowlingImpactSoundPath
    } else {
        soundPath = config.BowlingImpact2SoundPath
    }

    player, err := s.resourceManager.LoadSoundEffect(soundPath)
    if err != nil {
        log.Printf("[BowlingNutSystem] 加载撞击音效失败: %v", err)
        return
    }
    player.Rewind()
    player.Play()
}
```

[Source: pkg/systems/physics_system.go#playHitSound]

### 零耦合原则遵循

**系统设计原则**：
- `BowlingNutSystem` 不直接调用 `BehaviorSystem`
- 伤害处理直接修改 `HealthComponent` 和 `ArmorComponent`
- 护甲破坏后由 `BehaviorSystem` 在其 Update 中检测并处理动画
- 闪烁效果通过添加 `FlashEffectComponent` 实现

[Source: docs/architecture/coding-standards.md#零耦合原则]

### 爆炸坚果处理（本 Story 边界）

本 Story 中，爆炸坚果碰撞后的行为：
- 检测 `nutComp.IsExplosive == true`
- **不播放撞击音效**（爆炸音效由 Story 19.8 处理）
- 标记实体销毁
- **不弹射**
- 爆炸逻辑（3x3 范围伤害、爆炸动画、爆炸音效）在 Story 19.8 实现

```go
if nutComp.IsExplosive {
    // Story 19.8: 触发 3x3 范围爆炸和爆炸音效
    // 本 Story 仅标记销毁，不播放撞击音效
    s.entityManager.DestroyEntity(entityID)
} else {
    // 普通坚果：播放撞击音效 + 弹射
    s.playImpactSound()
    s.startBounce(entityID, targetRow)
}
```

### 文件位置规范

| 文件 | 位置 |
|------|------|
| BowlingNutComponent | `pkg/components/bowling_nut_component.go` |
| BowlingNutSystem | `pkg/systems/bowling_nut_system.go` |
| 碰撞检测测试 | `pkg/systems/bowling_nut_system_test.go` |
| 配置常量 | `pkg/config/layout_config.go` |
| 音效路径常量 | `pkg/config/unit_config.go` |

[Source: docs/architecture/source-tree.md]

## Testing

### 测试文件位置

- `pkg/systems/bowling_nut_system_test.go`

### 关键测试场景

**1. 碰撞检测测试**:

```go
func TestBowlingNutSystem_CollisionDetection(t *testing.T) {
    em := ecs.NewEntityManager()
    system := systems.NewBowlingNutSystem(em, nil)

    // 创建坚果实体（X=500, 行2）
    nutID := em.CreateEntity()
    em.AddComponent(nutID, &components.PositionComponent{X: 500.0, Y: 328.0})
    em.AddComponent(nutID, &components.BowlingNutComponent{
        VelocityX: 250.0,
        Row: 2,
        IsRolling: true,
    })

    // 创建僵尸实体（同行，X=510）
    zombieID := em.CreateEntity()
    em.AddComponent(zombieID, &components.PositionComponent{X: 510.0, Y: 328.0})
    em.AddComponent(zombieID, &components.BehaviorComponent{Type: components.BehaviorZombieBasic})
    em.AddComponent(zombieID, &components.HealthComponent{CurrentHealth: 270, MaxHealth: 270})
    em.AddComponent(zombieID, &components.CollisionComponent{Width: 40, Height: 115})

    // 更新系统
    system.Update(0.016)

    // 验证僵尸受到伤害
    health, _ := ecs.GetComponent[*components.HealthComponent](em, zombieID)
    assert.LessOrEqual(t, health.CurrentHealth, 0) // 应该被秒杀
}
```

**2. 护甲处理测试**:

```go
func TestBowlingNutSystem_ArmorDamage(t *testing.T) {
    em := ecs.NewEntityManager()
    system := systems.NewBowlingNutSystem(em, nil)

    // 创建路障僵尸
    zombieID := em.CreateEntity()
    em.AddComponent(zombieID, &components.PositionComponent{X: 510.0, Y: 328.0})
    em.AddComponent(zombieID, &components.BehaviorComponent{Type: components.BehaviorZombieConehead})
    em.AddComponent(zombieID, &components.HealthComponent{CurrentHealth: 270, MaxHealth: 270})
    em.AddComponent(zombieID, &components.ArmorComponent{CurrentArmor: 370, MaxArmor: 370})
    em.AddComponent(zombieID, &components.CollisionComponent{Width: 40, Height: 115})

    // 创建坚果并触发碰撞
    nutID := em.CreateEntity()
    em.AddComponent(nutID, &components.PositionComponent{X: 500.0, Y: 328.0})
    em.AddComponent(nutID, &components.BowlingNutComponent{VelocityX: 250.0, Row: 2, IsRolling: true})

    system.Update(0.016)

    // 验证护甲被破坏
    armor, _ := ecs.GetComponent[*components.ArmorComponent](em, zombieID)
    assert.LessOrEqual(t, armor.CurrentArmor, 0)

    // 验证身体也受到溢出伤害
    health, _ := ecs.GetComponent[*components.HealthComponent](em, zombieID)
    assert.LessOrEqual(t, health.CurrentHealth, 0) // 1800 - 370 = 1430 > 270
}
```

**3. 弹射方向测试（优先 X 轴距离最近的僵尸）**:

```go
func TestBowlingNutSystem_BounceToNearestZombieRow(t *testing.T) {
    em := ecs.NewEntityManager()
    system := systems.NewBowlingNutSystem(em, nil)

    // 坚果在行 2，X = 500
    nutID := em.CreateEntity()
    em.AddComponent(nutID, &components.PositionComponent{X: 500.0, Y: 328.0})
    em.AddComponent(nutID, &components.BowlingNutComponent{VelocityX: 250.0, Row: 2, IsRolling: true})

    // 行 1 有僵尸，X = 900（距离 400）
    zombie1ID := em.CreateEntity()
    em.AddComponent(zombie1ID, &components.PositionComponent{X: 900.0, Y: 228.0}) // 行 1
    em.AddComponent(zombie1ID, &components.BehaviorComponent{Type: components.BehaviorZombieBasic})
    em.AddComponent(zombie1ID, &components.HealthComponent{CurrentHealth: 270})
    em.AddComponent(zombie1ID, &components.CollisionComponent{Width: 40, Height: 115})

    // 行 3 有僵尸，X = 600（距离 100）- 更近！
    zombie3ID := em.CreateEntity()
    em.AddComponent(zombie3ID, &components.PositionComponent{X: 600.0, Y: 428.0}) // 行 3
    em.AddComponent(zombie3ID, &components.BehaviorComponent{Type: components.BehaviorZombieBasic})
    em.AddComponent(zombie3ID, &components.HealthComponent{CurrentHealth: 270})
    em.AddComponent(zombie3ID, &components.CollisionComponent{Width: 40, Height: 115})

    // 在行 2 放置僵尸触发碰撞
    targetZombieID := em.CreateEntity()
    em.AddComponent(targetZombieID, &components.PositionComponent{X: 510.0, Y: 328.0})
    em.AddComponent(targetZombieID, &components.BehaviorComponent{Type: components.BehaviorZombieBasic})
    em.AddComponent(targetZombieID, &components.HealthComponent{CurrentHealth: 270})
    em.AddComponent(targetZombieID, &components.CollisionComponent{Width: 40, Height: 115})

    system.Update(0.016)

    // 验证坚果弹向行 3（X 轴距离更近：100 < 400）
    nut, _ := ecs.GetComponent[*components.BowlingNutComponent](em, nutID)
    if nut.IsBouncing {
        assert.Equal(t, 3, nut.TargetRow) // 应该弹向行 3（距离更近）
    }
}
```

**4. 边缘行反弹测试**:

```go
func TestBowlingNutSystem_EdgeRowBounce(t *testing.T) {
    em := ecs.NewEntityManager()
    system := systems.NewBowlingNutSystem(em, nil)

    // 在行 0（顶部边缘）创建坚果
    nutID := em.CreateEntity()
    em.AddComponent(nutID, &components.PositionComponent{X: 500.0, Y: 128.0})
    em.AddComponent(nutID, &components.BowlingNutComponent{VelocityX: 250.0, Row: 0, IsRolling: true})

    // 触发碰撞后验证弹射方向
    // ... 碰撞设置 ...

    system.Update(0.016)

    nut, _ := ecs.GetComponent[*components.BowlingNutComponent](em, nutID)
    if nut.IsBouncing {
        assert.Equal(t, 1, nut.TargetRow) // 第 0 行只能向下弹到第 1 行
    }
}
```

**5. 多次弹射测试**:

```go
func TestBowlingNutSystem_MultipleBounces(t *testing.T) {
    em := ecs.NewEntityManager()
    system := systems.NewBowlingNutSystem(em, nil)

    // 创建坚果
    nutID := em.CreateEntity()
    em.AddComponent(nutID, &components.PositionComponent{X: 300.0, Y: 328.0})
    em.AddComponent(nutID, &components.BowlingNutComponent{
        VelocityX: 250.0,
        Row: 2,
        IsRolling: true,
        BounceCount: 0,
    })

    // 多次碰撞后验证 BounceCount 递增
    // ... 设置多个僵尸并模拟多次碰撞 ...

    nut, _ := ecs.GetComponent[*components.BowlingNutComponent](em, nutID)
    assert.Greater(t, nut.BounceCount, 0)
}
```

### 测试命令

```bash
# 运行系统测试
go test ./pkg/systems -v -run TestBowlingNutSystem

# 查看覆盖率
go test ./pkg/systems -cover -run "BowlingNut"

# 生成覆盖率报告
go test ./pkg/systems -coverprofile=coverage.out -run "BowlingNut"
go tool cover -html=coverage.out
```

[Source: docs/architecture/testing-strategy.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-02 | 0.1 | Initial story creation | Bob (Scrum Master Agent) |
| 2025-12-02 | 0.2 | 规范对比修正：弹射优先级从"有僵尸的行"改为"X轴距离最近的僵尸所在行"；添加撞击视觉效果说明；更新测试用例 | Bob (Scrum Master Agent) |
| 2025-12-02 | 0.3 | PO 验证修复：AC 5 行号标题改为 0-indexed；加强爆炸坚果边界处理说明，明确不播放撞击音效 | Sarah (Product Owner Agent) |

---

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

无需调试日志，所有测试一次通过。

### Completion Notes

**实现摘要**：

1. **BowlingNutComponent 扩展** - 添加 VelocityY、IsBouncing、TargetRow、CollisionCooldown 字段
2. **碰撞检测** - 使用 AABB 算法检测坚果与僵尸碰撞，支持所有僵尸类型
3. **伤害处理** - 1800 点伤害，支持护甲溢出计算，自动添加闪烁效果
4. **弹射方向** - 优先弹向 X 轴距离最近的僵尸所在行，边缘行自动反弹
5. **弹射移动** - 平滑的垂直移动，到达目标行后自动对齐
6. **撞击音效** - 随机播放 bowlingimpact.ogg 或 bowlingimpact2.ogg
7. **爆炸坚果** - 碰撞后标记销毁，不弹射不播放撞击音效

**测试覆盖率**：
- 核心业务逻辑覆盖率 > 90%
- 24 个测试用例全部通过

### File List

| 文件 | 操作 | 说明 |
|------|------|------|
| `pkg/components/bowling_nut_component.go` | Modified | 添加弹射相关字段 |
| `pkg/config/layout_config.go` | Modified | 添加碰撞伤害、弹射速度、冷却时间常量 |
| `pkg/config/unit_config.go` | Modified | 添加撞击音效路径常量 |
| `pkg/systems/bowling_nut_system.go` | Modified | 实现碰撞检测、伤害处理、弹射逻辑 |
| `pkg/systems/bowling_nut_system_test.go` | Modified | 添加 Story 19.7 单元测试 |

---

## QA Results

### Review Date: 2025-12-02

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

实现质量优秀。代码结构清晰，遵循 ECS 架构原则，零耦合设计良好。所有 24 个测试用例通过，核心业务逻辑覆盖率达到 94%+。

**优点：**
- ✅ 零耦合原则遵守良好：BowlingNutSystem 不直接调用其他系统，通过 EntityManager 通信
- ✅ 组件数据分离：BowlingNutComponent 仅包含数据字段，无行为逻辑
- ✅ 错误处理完善：音效加载失败有错误日志记录
- ✅ GoDoc 注释完善：所有公共方法都有清晰的文档注释
- ✅ 配置外部化：所有常量都在 config 包中集中定义
- ✅ 测试设计良好：测试用例覆盖了主要业务场景

### Refactoring Performed

无需重构。代码质量符合项目标准。

### Compliance Check

- Coding Standards: ✓ 完全符合编码标准
- Project Structure: ✓ 文件位置符合项目结构规范
- Testing Strategy: ✓ 测试策略符合要求
- All ACs Met: ✓ 所有 8 个验收标准均已满足

### Improvements Checklist

[x] 碰撞检测使用 AABB 算法，与 PhysicsSystem 保持一致
[x] 护甲溢出伤害计算正确（1800 - 护甲值）
[x] 边缘行弹射方向处理正确
[x] 弹射优先级按 X 轴距离计算
[x] 冷却机制防止重复碰撞
[x] 测试覆盖率 > 80%

**可选改进（非阻塞）：**
- [ ] 考虑为音效相关函数添加接口抽象以提高可测试性
- [ ] addFlashEffect 函数可增加"已有闪烁组件重置"分支的测试覆盖

### Security Review

无安全问题。该系统不涉及用户输入处理或敏感数据。

### Performance Considerations

性能表现良好：
- AABB 碰撞检测算法高效
- 使用 map 管理音效播放器，O(1) 查找
- 仅查询必要的组件，避免不必要的遍历

### Files Modified During Review

无文件修改。

### Test Coverage Summary

| 函数 | 覆盖率 |
|------|--------|
| NewBowlingNutSystem | 100% |
| Update | 97.5% |
| checkCollisionWithZombies | 95.0% |
| isZombieType | 100% |
| applyDamageToZombie | 100% |
| calculateBounceDirection | 93.3% |
| startBounce | 100% |
| 核心逻辑平均 | **94%+** |

### Requirements Traceability

| AC | 测试覆盖 | 状态 |
|----|----------|------|
| AC 1: 1800点伤害 | TestBowlingNutSystem_CollisionDetection, TestBowlingNutSystem_ArmorDamage, TestBowlingNutSystem_BucketheadZombieArmorDamage | ✅ |
| AC 2: 护甲处理 | TestBowlingNutSystem_ArmorDamage, TestBowlingNutSystem_BucketheadZombieArmorDamage | ✅ |
| AC 3: 弹射移动 | TestBowlingNutSystem_BouncingMovement, TestBowlingNutSystem_BounceCountIncrement | ✅ |
| AC 4: X轴优先 | TestBowlingNutSystem_BounceDirection_NearestZombie | ✅ |
| AC 5: 边缘反弹 | TestBowlingNutSystem_EdgeRowBounce_Row0, TestBowlingNutSystem_EdgeRowBounce_Row4 | ✅ |
| AC 6: 多次弹射 | TestBowlingNutSystem_BounceCountIncrement | ✅ |
| AC 7: 撞击音效 | 实现已有（playImpactSound），音效难以单元测试 | ✅ |
| AC 8: 覆盖率≥80% | 核心逻辑 94%+ | ✅ |

### Gate Status

Gate: **PASS** → docs/qa/gates/19.7-bowling-collision-bounce-system.yml

### Recommended Status

✓ Ready for Done
